From 198705dfcece036025ef69637859b3014788231b Mon Sep 17 00:00:00 2001
From: Francesco Pham <francesco.pham@huawei.com>
Date: Sat, 2 Mar 2024 12:38:51 +0100
Subject: [PATCH] integrate porting/linux/user/*

Patch generated from OpenHarmony-v4.0-Release version, with the following commands:

    cp -r porting/linux/user/* .
    git add -A
    git diff --staged > openharmony-linux-user.patch
---
 Makefile                                      |    3 +-
 arch/aarch64/syscall_arch.h                   |   19 +
 arch/arm/bits/fenv.h                          |    4 +-
 arch/generic/bits/shm.h                       |    2 +-
 arch/generic/crtbrand.s                       |   10 +
 arch/x86_64/bits/float.h                      |   14 +-
 config/README_zh.md                           |   40 +
 config/ld-musl-namespace-aarch64-test.ini     |   62 +
 config/ld-musl-namespace-aarch64.ini          |   12 +
 config/ld-musl-namespace-arm-test.ini         |   62 +
 config/ld-musl-namespace-arm.ini              |   12 +
 config/ld-musl-namespace-x86_64-test.ini      |   62 +
 config/ld-musl-namespace-x86_64.ini           |   12 +
 crt/aarch64/crti.s                            |    4 +
 crt/arm/crti.s                                |    4 +
 crt/crtplus.c                                 |   25 +
 crt/x86_64/crti.s                             |    2 +
 etc/musl.para                                 |   31 +
 etc/musl.para.dac                             |   14 +
 include/ctype.h                               |    5 +
 include/dlfcn.h                               |  143 +-
 include/dlfcn_ext.h                           |   81 +
 include/elf.h                                 |   10 +-
 include/fcntl.h                               |    1 +
 include/fortify/fcntl.h                       |  129 +
 include/fortify/fortify.h                     |  137 +
 include/fortify/poll.h                        |   72 +
 include/fortify/socket.h                      |  104 +
 include/fortify/stat.h                        |   47 +
 include/fortify/stdio.h                       |  136 +
 include/fortify/stdlib.h                      |   34 +
 include/fortify/string.h                      |  246 ++
 include/fortify/unistd.h                      |  171 +
 include/info/application_target_sdk_version.h |   44 +
 include/info/device_api_version.h             |   33 +
 include/info/fatal_message.h                  |   47 +
 include/langinfo.h                            |   18 +
 include/locale.h                              |   84 +-
 include/malloc.h                              |   25 +
 include/poll.h                                |    2 +
 include/pthread.h                             |  177 +
 include/sched.h                               |  301 +-
 include/sigchain.h                            |   52 +
 include/signal.h                              |   13 +-
 include/stdio.h                               |    2 +
 include/stdlib.h                              |    2 +
 include/string.h                              |    2 +
 include/sys/capability.h                      |   48 +
 include/sys/reboot.h                          |   49 +-
 include/sys/socket.h                          |    8 +
 include/sys/sspret.h                          |   55 +
 include/sys/stat.h                            |    2 +
 include/sys/syscall.h                         |   41 +
 include/sys/sysinfo.h                         |    2 +
 include/sys/tgkill.h                          |   36 +
 include/trace/trace_marker.h                  |   81 +
 include/unistd.h                              |   15 +
 ldso/README.md                                |   18 +
 ldso/cfi.c                                    |  509 +++
 ldso/cfi.h                                    |   32 +
 ldso/dynlink.c                                | 3857 +++++++++++++++--
 ldso/dynlink_rand.c                           |  244 ++
 ldso/dynlink_rand.h                           |   93 +
 ldso/ld_log.c                                 |  110 +
 ldso/ld_log.h                                 |   73 +
 ldso/namespace.c                              |  613 +++
 ldso/namespace.h                              |  108 +
 ldso/ns_config.c                              |  680 +++
 ldso/ns_config.h                              |   80 +
 ldso/strops.c                                 |  138 +
 ldso/strops.h                                 |   47 +
 ldso/zip_archive.h                            |  120 +
 src/aio/aio.c                                 |    8 +-
 src/conf/legacy.c                             |   60 +-
 src/conf/sysconf.c                            |   10 +-
 src/env/__init_tls.c                          |   12 +-
 src/env/__libc_start_main.c                   |    5 +
 src/env/getenv.c                              |   21 +-
 src/exit/atexit.c                             |   78 +-
 src/fortify/fortify.c                         |  410 ++
 src/hilog/hilog_adapter.c                     |  175 +
 src/hilog/hilog_common.h                      |   54 +
 src/hilog/output_p.inl                        | 1300 ++++++
 src/hilog/vsnprintf_s_p.c                     |  293 ++
 src/hilog/vsnprintf_s_p.h                     |   38 +
 src/hook/common_def.h                         |   10 +
 src/hook/malloc_common.c                      |  118 +
 src/hook/memory_trace.c                       |   26 +
 src/hook/memory_trace.h                       |   14 +
 src/hook/musl_malloc.h                        |   58 +
 src/hook/musl_malloc_dispatch.h               |   65 +
 src/hook/musl_malloc_dispatch_table.h         |   15 +
 src/hook/musl_preinit.c                       |  687 +++
 src/hook/musl_preinit_common.c                |   24 +
 src/hook/musl_preinit_common.h                |  136 +
 src/hook/musl_socket.h                        |   21 +
 src/hook/musl_socket_dispatch.h               |   26 +
 src/hook/musl_socket_preinit.c                |  150 +
 src/hook/musl_socket_preinit_common.c         |   16 +
 src/hook/musl_socket_preinit_common.h         |   83 +
 src/hook/socket_common.c                      |   18 +
 src/info/application_target_sdk_version.c     |   31 +
 src/info/device_api_version.c                 |   25 +
 src/info/fatal_message.c                      |   71 +
 src/internal/dynlink.h                        |  144 +-
 src/internal/hilog_adapter.h                  |   63 +
 src/internal/libc.h                           |   25 +-
 src/internal/locale_impl.h                    |    3 +
 src/internal/malloc_config.h                  |   42 +
 src/internal/malloc_random.h                  |   20 +
 src/internal/musl_log.h                       |   44 +
 src/internal/pthread_impl.h                   |  153 +-
 src/internal/stdio_impl.h                     |   25 +-
 src/internal/syscall.h                        |   12 +-
 src/internal/vdso.c                           |   77 +-
 src/ldso/aarch64/dlvsym.s                     |   21 +
 src/ldso/arm/dlvsym.s                         |   23 +
 src/ldso/dlclose.c                            |    9 +-
 src/ldso/dlerror.c                            |    6 +-
 src/ldso/riscv64/dlvsym.s                     |   21 +
 src/ldso/x86_64/dlvsym.s                      |   22 +
 src/legacy/ulimit.c                           |    3 +-
 src/linux/cache.c                             |   17 +-
 src/linux/clone.c                             |   64 +-
 src/linux/prctl.c                             |    8 +
 src/linux/reboot.c                            |   20 +-
 src/linux/tgkill.c                            |   22 +
 src/locale/c_locale.c                         |    3 +-
 src/locale/dcngettext.c                       |  499 ++-
 src/locale/langinfo.c                         |  132 +-
 src/locale/locale_map.c                       |   69 +-
 src/locale/newlocale.c                        |    2 +-
 src/locale/setlocale.c                        |   21 +-
 src/malloc/calloc.c                           |   47 +-
 src/malloc/free.c                             |    9 +
 src/malloc/jemalloc/jemalloc.c                |    1 +
 src/malloc/libc_calloc.c                      |   63 +-
 src/malloc/lite_malloc.c                      |    7 +
 src/malloc/mallocng/aligned_alloc.c           |    7 +
 src/malloc/mallocng/donate.c                  |    2 +-
 src/malloc/mallocng/malloc.c                  |  116 +-
 src/malloc/mallocng/malloc_usable_size.c      |   10 +
 src/malloc/mallocng/meta.h                    |   17 +-
 src/malloc/realloc.c                          |    9 +
 src/malloc/stats.c                            |   65 +
 src/misc/aarch64/syscall.s                    |   13 +
 src/mq/mq_notify.c                            |    5 +
 src/network/getnameinfo.c                     |   27 +-
 src/network/inet_legacy.c                     |    6 +-
 src/network/lookup_name.c                     |   47 +-
 src/network/resolvconf.c                      |  122 +-
 src/network/socket.c                          |   21 +-
 src/passwd/getspnam_r.c                       |    7 +
 src/process/_Fork.c                           |    3 +-
 src/process/arm/__vfork.s                     |   10 +
 src/process/vfork.c                           |   15 +-
 src/process/x86_64/__vfork.s                  |   10 +
 src/sched/sched_cpualloc.c                    |   11 +
 src/sched/sched_getcpu.c                      |   17 +-
 src/sched/sched_getparam.c                    |   28 +-
 src/sched/sched_getscheduler.c                |   17 +-
 src/sched/sched_setparam.c                    |   23 +-
 src/sched/sched_setscheduler.c                |   11 +-
 src/sigchain/sigchain.c                       |  478 ++
 src/signal/sigaction.c                        |   57 +-
 src/signal/siginterrupt.c                     |   26 +-
 src/signal/signal.c                           |   25 +-
 src/stdio/__fdopen.c                          |  117 +-
 src/stdio/__fmodeflags.c                      |   61 +-
 src/stdio/__stdio_read.c                      |   22 +-
 src/stdio/__stdio_write.c                     |   66 +-
 src/stdio/__stdout_write.c                    |    9 +-
 src/stdio/__toread.c                          |    8 +
 src/stdio/__towrite.c                         |    7 +-
 src/stdio/fclose.c                            |   11 +-
 src/stdio/fgets.c                             |    4 +-
 src/stdio/fileno.c                            |   12 +-
 src/stdio/fmemopen.c                          |    1 +
 src/stdio/fopen.c                             |   28 +-
 src/stdio/fread.c                             |   72 +-
 src/stdio/freopen.c                           |   15 +-
 src/stdio/ofl.c                               |   81 +-
 src/stdio/setvbuf.c                           |    2 +
 src/stdio/stderr.c                            |    2 +-
 src/stdio/stdin.c                             |    1 +
 src/stdio/vfprintf.c                          |   34 +-
 src/stdio/vfscanf.c                           |   34 +-
 src/stdio/vsnprintf.c                         |   29 +-
 src/stdio/vsscanf.c                           |   16 +-
 src/stdlib/strtod.c                           |    4 +-
 src/string/stpncpy.c                          |   52 +-
 src/string/strcasecmp.c                       |   11 +-
 src/string/strcspn.c                          |   37 +-
 src/string/strncasecmp.c                      |   13 +-
 src/string/strncat.c                          |    2 +-
 src/string/strncpy.c                          |   21 +-
 src/thread/arm/clone.s                        |    8 +
 src/thread/arm/syscall_cp.s                   |   10 +-
 src/thread/pthread_cancel.c                   |   10 +
 src/thread/pthread_cond_clockwait.c           |   34 +
 src/thread/pthread_cond_init.c                |    2 +-
 .../pthread_cond_timedwait_monotonic_np.c     |   26 +
 src/thread/pthread_cond_timeout_np.c          |   25 +
 src/thread/pthread_create.c                   |  112 +-
 src/thread/pthread_mutex_clocklock.c          |   35 +
 src/thread/pthread_mutex_init.c               |    2 +-
 src/thread/pthread_mutex_lock.c               |    4 +-
 src/thread/pthread_mutex_lock_timeout_np.c    |   27 +
 src/thread/pthread_mutex_timedlock.c          |   52 +-
 .../pthread_mutex_timedlock_monotonic_np.c    |   25 +
 src/thread/pthread_once.c                     |   12 +
 src/thread/pthread_rwlock_clockrdlock.c       |   34 +
 src/thread/pthread_rwlock_clockwrlock.c       |   34 +
 src/thread/pthread_rwlock_init.c              |    2 +-
 src/thread/pthread_rwlock_timedrdlock.c       |   50 +-
 .../pthread_rwlock_timedrdlock_monotonic_np.c |   25 +
 src/thread/pthread_rwlock_timedwrlock.c       |   53 +-
 .../pthread_rwlock_timedwrlock_monotonic_np.c |   25 +
 src/thread/pthread_setcancelstate.c           |    2 +
 src/thread/pthread_setcanceltype.c            |    2 +
 src/thread/pthread_sigmask.c                  |   57 +-
 src/thread/sem_timedwait.c                    |   15 +-
 src/time/__tz.c                               |  660 +--
 src/time/clock_getres.c                       |   49 +-
 src/time/clock_gettime.c                      |   20 +-
 src/time/gettimeofday.c                       |   48 +
 src/time/gmtime_r.c                           |   35 +-
 src/time/strftime.c                           |  579 +--
 src/time/strptime.c                           |  636 ++-
 src/time/time.c                               |   44 +
 src/time/time_impl.h                          |   21 +
 src/time/timer_create.c                       |    4 +-
 src/trace/trace_marker.c                      |  243 ++
 src/unistd/getpid.c                           |   10 +
 234 files changed, 18203 insertions(+), 2132 deletions(-)
 create mode 100644 arch/generic/crtbrand.s
 create mode 100755 config/README_zh.md
 create mode 100644 config/ld-musl-namespace-aarch64-test.ini
 create mode 100644 config/ld-musl-namespace-aarch64.ini
 create mode 100644 config/ld-musl-namespace-arm-test.ini
 create mode 100644 config/ld-musl-namespace-arm.ini
 create mode 100644 config/ld-musl-namespace-x86_64-test.ini
 create mode 100644 config/ld-musl-namespace-x86_64.ini
 create mode 100644 crt/crtplus.c
 create mode 100644 etc/musl.para
 create mode 100644 etc/musl.para.dac
 create mode 100644 include/dlfcn_ext.h
 create mode 100644 include/fortify/fcntl.h
 create mode 100644 include/fortify/fortify.h
 create mode 100644 include/fortify/poll.h
 create mode 100644 include/fortify/socket.h
 create mode 100644 include/fortify/stat.h
 create mode 100644 include/fortify/stdio.h
 create mode 100644 include/fortify/stdlib.h
 create mode 100644 include/fortify/string.h
 create mode 100644 include/fortify/unistd.h
 create mode 100644 include/info/application_target_sdk_version.h
 create mode 100644 include/info/device_api_version.h
 create mode 100644 include/info/fatal_message.h
 create mode 100644 include/sigchain.h
 create mode 100644 include/sys/capability.h
 create mode 100644 include/sys/sspret.h
 create mode 100644 include/sys/tgkill.h
 create mode 100644 include/trace/trace_marker.h
 create mode 100644 ldso/README.md
 create mode 100644 ldso/cfi.c
 create mode 100644 ldso/cfi.h
 create mode 100644 ldso/dynlink_rand.c
 create mode 100644 ldso/dynlink_rand.h
 create mode 100644 ldso/ld_log.c
 create mode 100644 ldso/ld_log.h
 create mode 100644 ldso/namespace.c
 create mode 100644 ldso/namespace.h
 create mode 100644 ldso/ns_config.c
 create mode 100644 ldso/ns_config.h
 create mode 100644 ldso/strops.c
 create mode 100644 ldso/strops.h
 create mode 100644 ldso/zip_archive.h
 create mode 100644 src/fortify/fortify.c
 create mode 100644 src/hilog/hilog_adapter.c
 create mode 100644 src/hilog/hilog_common.h
 create mode 100644 src/hilog/output_p.inl
 create mode 100644 src/hilog/vsnprintf_s_p.c
 create mode 100644 src/hilog/vsnprintf_s_p.h
 create mode 100644 src/hook/common_def.h
 create mode 100644 src/hook/malloc_common.c
 create mode 100644 src/hook/memory_trace.c
 create mode 100644 src/hook/memory_trace.h
 create mode 100644 src/hook/musl_malloc.h
 create mode 100644 src/hook/musl_malloc_dispatch.h
 create mode 100644 src/hook/musl_malloc_dispatch_table.h
 create mode 100644 src/hook/musl_preinit.c
 create mode 100644 src/hook/musl_preinit_common.c
 create mode 100644 src/hook/musl_preinit_common.h
 create mode 100644 src/hook/musl_socket.h
 create mode 100644 src/hook/musl_socket_dispatch.h
 create mode 100644 src/hook/musl_socket_preinit.c
 create mode 100644 src/hook/musl_socket_preinit_common.c
 create mode 100644 src/hook/musl_socket_preinit_common.h
 create mode 100644 src/hook/socket_common.c
 create mode 100644 src/info/application_target_sdk_version.c
 create mode 100644 src/info/device_api_version.c
 create mode 100644 src/info/fatal_message.c
 create mode 100644 src/internal/hilog_adapter.h
 create mode 100644 src/internal/malloc_config.h
 create mode 100644 src/internal/malloc_random.h
 create mode 100644 src/internal/musl_log.h
 create mode 100644 src/ldso/aarch64/dlvsym.s
 create mode 100644 src/ldso/arm/dlvsym.s
 create mode 100644 src/ldso/riscv64/dlvsym.s
 create mode 100644 src/ldso/x86_64/dlvsym.s
 create mode 100644 src/linux/tgkill.c
 create mode 100644 src/malloc/jemalloc/jemalloc.c
 create mode 100644 src/malloc/stats.c
 create mode 100644 src/misc/aarch64/syscall.s
 create mode 100644 src/process/arm/__vfork.s
 create mode 100644 src/process/x86_64/__vfork.s
 create mode 100644 src/sched/sched_cpualloc.c
 create mode 100644 src/sigchain/sigchain.c
 create mode 100644 src/thread/pthread_cond_clockwait.c
 create mode 100644 src/thread/pthread_cond_timedwait_monotonic_np.c
 create mode 100644 src/thread/pthread_cond_timeout_np.c
 create mode 100644 src/thread/pthread_mutex_clocklock.c
 create mode 100644 src/thread/pthread_mutex_lock_timeout_np.c
 create mode 100644 src/thread/pthread_mutex_timedlock_monotonic_np.c
 create mode 100644 src/thread/pthread_rwlock_clockrdlock.c
 create mode 100644 src/thread/pthread_rwlock_clockwrlock.c
 create mode 100644 src/thread/pthread_rwlock_timedrdlock_monotonic_np.c
 create mode 100644 src/thread/pthread_rwlock_timedwrlock_monotonic_np.c
 create mode 100644 src/trace/trace_marker.c

diff --git a/Makefile b/Makefile
index d2f458fa..466d9afd 100755
--- a/Makefile
+++ b/Makefile
@@ -47,8 +47,7 @@ CFLAGS_AUTO = -Os -pipe
 CFLAGS_C99FSE = -std=c99 -ffreestanding -nostdinc 
 
 CFLAGS_ALL = $(CFLAGS_C99FSE)
-CFLAGS_ALL += -D_XOPEN_SOURCE=700 -DSYSLIBDIR='"$(syslibdir)"' -DLIBDIR='"$(libdir)"'
-CFLAGS_ALL += -I$(srcdir)/arch/$(ARCH) -I$(srcdir)/arch/generic -Iobj/src/internal -I$(srcdir)/src/include -I$(srcdir)/src/internal -Iobj/include -I$(srcdir)/include
+CFLAGS_ALL += -D_XOPEN_SOURCE=700 -I$(srcdir)/arch/$(ARCH) -I$(srcdir)/arch/generic -Iobj/src/internal -I$(srcdir)/src/include -I$(srcdir)/src/internal -Iobj/include -I$(srcdir)/include
 CFLAGS_ALL += $(CPPFLAGS) $(CFLAGS_AUTO) $(CFLAGS)
 
 LDFLAGS_ALL = $(LDFLAGS_AUTO) $(LDFLAGS)
diff --git a/arch/aarch64/syscall_arch.h b/arch/aarch64/syscall_arch.h
index 504983aa..ecc7d75d 100644
--- a/arch/aarch64/syscall_arch.h
+++ b/arch/aarch64/syscall_arch.h
@@ -1,3 +1,18 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #define __SYSCALL_LL_E(x) (x)
 #define __SYSCALL_LL_O(x) (x)
 
@@ -74,5 +89,9 @@ static inline long __syscall6(long n, long a, long b, long c, long d, long e, lo
 #define VDSO_USEFUL
 #define VDSO_CGT_SYM "__kernel_clock_gettime"
 #define VDSO_CGT_VER "LINUX_2.6.39"
+#define VDSO_CGR_SYM "__kernel_clock_getres"
+#define VDSO_CGR_VER "LINUX_2.6.39"
+#define VDSO_GTD_SYM "__kernel_gettimeofday"
+#define VDSO_GTD_VER "LINUX_2.6.39"
 
 #define IPC_64 0
diff --git a/arch/arm/bits/fenv.h b/arch/arm/bits/fenv.h
index d85fc86d..b497a987 100644
--- a/arch/arm/bits/fenv.h
+++ b/arch/arm/bits/fenv.h
@@ -9,10 +9,10 @@
 #define FE_INEXACT    16
 #define FE_ALL_EXCEPT 31
 #define FE_TONEAREST  0
-#define FE_DOWNWARD   0x800000
-#define FE_UPWARD     0x400000
 #define FE_TOWARDZERO 0xc00000
 #endif
+#define FE_DOWNWARD   0x800000
+#define FE_UPWARD     0x400000
 
 typedef unsigned long fexcept_t;
 
diff --git a/arch/generic/bits/shm.h b/arch/generic/bits/shm.h
index 8d193781..da07a2a0 100644
--- a/arch/generic/bits/shm.h
+++ b/arch/generic/bits/shm.h
@@ -1,4 +1,4 @@
-#define SHMLBA 4096
+#define SHMLBA (4*4096)
 
 struct shmid_ds {
 	struct ipc_perm shm_perm;
diff --git a/arch/generic/crtbrand.s b/arch/generic/crtbrand.s
new file mode 100644
index 00000000..7866d547
--- /dev/null
+++ b/arch/generic/crtbrand.s
@@ -0,0 +1,10 @@
+  .section .note.ohos.ident,"a",%note
+  .balign 4
+  .type abitag, %object
+abitag:
+  .long 2f-1f                 // int32_t namesz
+  .long 3f-2f                 // int32_t descsz
+1:.ascii "OHOS\0"          // char name[]
+2:.long 1  // int32_t ohos_api
+3:
+  .size abitag, .-abitag
diff --git a/arch/x86_64/bits/float.h b/arch/x86_64/bits/float.h
index 4d8e7864..e188cb61 100644
--- a/arch/x86_64/bits/float.h
+++ b/arch/x86_64/bits/float.h
@@ -4,17 +4,17 @@
 #define FLT_EVAL_METHOD 0
 #endif
 
-#define LDBL_TRUE_MIN 3.6451995318824746025e-4951L
-#define LDBL_MIN     3.3621031431120935063e-4932L
-#define LDBL_MAX     1.1897314953572317650e+4932L
-#define LDBL_EPSILON 1.0842021724855044340e-19L
+#define LDBL_TRUE_MIN 6.47517511943802511092443895822764655e-4966L
+#define LDBL_MIN 3.36210314311209350626267781732175260e-4932L
+#define LDBL_MAX 1.18973149535723176508575932662800702e+4932L
+#define LDBL_EPSILON 1.92592994438723585305597794258492732e-34L
 
-#define LDBL_MANT_DIG 64
+#define LDBL_MANT_DIG 113
 #define LDBL_MIN_EXP (-16381)
 #define LDBL_MAX_EXP 16384
 
-#define LDBL_DIG 18
+#define LDBL_DIG 33
 #define LDBL_MIN_10_EXP (-4931)
 #define LDBL_MAX_10_EXP 4932
 
-#define DECIMAL_DIG 21
+#define DECIMAL_DIG 36
diff --git a/config/README_zh.md b/config/README_zh.md
new file mode 100755
index 00000000..fe4cf401
--- /dev/null
+++ b/config/README_zh.md
@@ -0,0 +1,40 @@
+## 简介
+
+本目录放置了部分预置的musl linker配置文件。
+关于musl linker配置文件可以参考其[README](../ldso/README.md)说明。
+
+
+## 说明
+
+1.  musl linker加载的配置文件为：
+
+    ```
+    /etc/ld-musl-namespace-$ARCH.ini
+    ```
+
+    其中`$ARCH`为系统的CPU架构，比如`arm`或`aarch64`等。
+
+2.  配置动态库查找路径：
+
+    配置文件中`namespace.default.lib.paths`项用于指定musl linker加载动态库时的查找路径，多个路径中间使用`:`号分隔。
+
+    配置文件中`namespace.default.asan.lib.paths`项用于指定musl asan linker加载动态库时的查找路径，多个路径中间使用`:`号分隔，判断是否为asan linker是看linker的名字中是否含有`-asan`，比如`ld-musl-aarch64.so.1`是正常版本的linker，`ld-musl-aarch64-asan.so.1`是asan版本的linker。
+
+3.  关于asan双库版本中的动态库查找路径配置：
+
+    在asan双库版本构建脚本`build/common/asan/build_mixed_asan.sh`中，是通过将asan版本的lib和bin放到`/data`目录下，然后调整系统服务进程的配置文件(`/system/etc/init/*.cfg`及`/vendor/etc/init/*.cfg`)中相关路径来实现的，因此当前目录下的预置配置文件中的`namespace.default.asan.lib.paths`配置并未被使用，而是**自动生成**的。生成规则为将`namespace.default.lib.paths`中所有以`/system/`及`/vendor/`开头的路径换成以`/data/`开头。
+
+
+## 常见问题说明
+
+**如何构建asan双库版本？**
+
+[参考wiki](https://gitee.com/caoruihong/build/wikis)
+
+
+## 相关仓
+
+编译构建子系统
+
+[**build**](https://gitee.com/openharmony/build)
+
diff --git a/config/ld-musl-namespace-aarch64-test.ini b/config/ld-musl-namespace-aarch64-test.ini
new file mode 100644
index 00000000..33519afc
--- /dev/null
+++ b/config/ld-musl-namespace-aarch64-test.ini
@@ -0,0 +1,62 @@
+[section.dir.map]
+    acquiescence = /
+    test = /data/tests/libc-test/src
+
+[acquiescence]
+    namespace.default.lib.paths = /data/tests/libc-test/src:/system/lib64:/vendor/lib64:/vendor/lib64/chipsetsdk:/vendor/lib64/chipset-sdk:/system/lib64/chipset-pub-sdk:/system/lib64/chipset-sdk:/system/lib64/platformsdk:/system/lib64/module:/system/lib64/module/data:/system/lib64/module/multimedia:/system/lib64/module/security:/system/lib:/lib64/platformsdk:/lib64/chipset-pub-sdk:/sys_prod/lib64:/lib64:/lib:/usr/local/lib:/usr/lib
+    namespace.default.asan.lib.paths = /data/tests/libc-test/src:/system/lib64:/system/lib64/module:/vendor/lib64:/vendor/lib64/chipsetsdk:/vendor/lib64/chipset-sdk:/system/lib64/module/data:/system/lib64/module/multimedia:/system/lib64/module/security:/system/lib:/system/lib/module:/system/lib/module/data:/system/lib/module/multimedia:/lib64:/lib:/usr/local/lib:/usr/lib:/lib64/platformsdk:/lib64/chipset-pub-sdk:/sys_prod/lib64
+
+[test] 
+    added.nslist=ndk,ns_no_allowed_libs,ns_normal,ns_wrong_lib_path,ns_wrong_allowed_path,for_inherit_A,for_inherit_AA,inherited_class,ns_separated_flase,ns_asan_lib_path,ns_asan_permit_path
+
+    namespace.ndk.lib.paths = /system/lib64/ndk
+    namespace.default.inherits = ndk
+    namespace.default.inherit.ndk.shared.libs = allow_all_shared_libs
+    namespace.ndk.inherits = default
+    namespace.ndk.inherit.default.shared.libs = allow_all_shared_libs
+
+    #ns_no_allowed_libs ,allowed libs not configed
+    namespace.ns_no_allowed_libs.separated = true
+    namespace.ns_no_allowed_libs.lib.paths = /data/tests/libc-test/src
+
+    #ns_normal ,normal namespace
+    namespace.ns_normal.separated = true
+    namespace.ns_normal.lib.paths = /data/tests/libc-test/src
+    namespace.ns_normal.allowed.libs = libdlopen_ns_dso.so
+
+    #ns_wrong_lib_path ,path in allowed_libs,but not in env or lib or permitted Path
+    namespace.ns_wrong_lib_path.separated = true
+    namespace.ns_wrong_lib_path.lib.paths = src/common/
+    namespace.ns_wrong_lib_path.allowed.libs =  libdlopen_ns_dso.so
+    namespace.ns_wrong_lib_path.permitted.paths = /data/tests
+
+    #ns_wrong_allowed_path ,path not in allowed_libs
+    namespace.ns_wrong_allowed_path.separated = true
+    namespace.ns_wrong_allowed_path.lib.paths = /data/tests/libc-test/src/functionalext/dlns
+    namespace.ns_wrong_allowed_path.allowed.libs =  libdlopen_dso.so
+
+    #for testing inheritance
+    namespace.for_inherit_A.separated = true
+    #for testing inheritance
+    namespace.for_inherit_AA.separated = true
+
+    #inherited_class
+    namespace.inherited_class.separated = true
+    namespace.inherited_class.lib.paths = /data/tests/libc-test/src
+    namespace.inherited_class.allowed.libs= libdlopen_ns_dso.so:sharedlibtest.so
+
+    #ns_separated_flase
+    namespace.ns_separated_flase.separated = false
+    namespace.ns_separated_flase.lib.paths = /data/tests/libc-test/src
+    namespace.ns_separated_flase.allowed.libs =  libdlopen_ns_dso.so
+
+    #ns_asan_lib_path ,testing asan.lib.paths
+    namespace.ns_asan_lib_path.separated = true
+    namespace.ns_asan_lib_path.lib.paths = /data/tests/libc-test/src
+    namespace.ns_asan_lib_path.asan.lib.paths = /data/tests/libc-test/src/B
+
+    #ns_asan_permit_path ,testing asan.permitted.paths
+    namespace.ns_asan_permit_path.separated = true
+    namespace.ns_asan_permit_path.permitted.paths = /data/tests/libc-test/src/C
+    namespace.ns_asan_permit_path.asan.permitted.paths = /data/tests/libc-test/src/B
+
diff --git a/config/ld-musl-namespace-aarch64.ini b/config/ld-musl-namespace-aarch64.ini
new file mode 100644
index 00000000..b95863c8
--- /dev/null
+++ b/config/ld-musl-namespace-aarch64.ini
@@ -0,0 +1,12 @@
+[section.dir.map]
+    acquiescence = /system/bin:/vendor/bin:/data/local/tmp
+
+[acquiescence]
+    added.nslist = ndk
+    namespace.ndk.lib.paths = /system/lib64/ndk
+    namespace.default.lib.paths = /system/lib64:/vendor/lib64:/vendor/lib64/chipsetsdk:/vendor/lib64/chipset-sdk:/system/lib64/chipset-pub-sdk:/system/lib64/chipset-sdk:/system/lib64/platformsdk:/system/lib64/module:/system/lib64/module/data:/system/lib64/module/multimedia:/system/lib64/module/security:/vendor/lib64/hw:/lib64/platformsdk:/lib64/chipset-pub-sdk:/sys_prod/lib64:/system/lib:/lib:/usr/local/lib:/usr/lib:/lib64
+    namespace.default.asan.lib.paths = /system/lib64:/system/lib64/module:/vendor/lib64:/vendor/lib64/chipsetsdk:/vendor/lib64/chipset-sdk:/system/lib64/module/data:/system/lib64/module/multimedia:/system/lib64/module/security:/system/lib:/system/lib/module:/system/lib/module/data:/system/lib/module/multimedia:/lib64:/lib:/usr/local/lib:/usr/lib:/vendor/lib64/hw:/lib64/platformsdk:/lib64/chipset-pub-sdk:/sys_prod/lib64
+    namespace.default.inherits = ndk
+    namespace.default.inherit.ndk.shared.libs = allow_all_shared_libs
+    namespace.ndk.inherits = default
+    namespace.ndk.inherit.default.shared.libs = allow_all_shared_libs
\ No newline at end of file
diff --git a/config/ld-musl-namespace-arm-test.ini b/config/ld-musl-namespace-arm-test.ini
new file mode 100644
index 00000000..5fb20d28
--- /dev/null
+++ b/config/ld-musl-namespace-arm-test.ini
@@ -0,0 +1,62 @@
+[section.dir.map]
+    acquiescence = /
+    test = /data/tests/libc-test/src
+
+[acquiescence]
+    namespace.default.lib.paths = /data/tests/libc-test/src:/system/lib:/vendor/lib:/vendor/lib/chipsetsdk:/vendor/lib/chipset-sdk:/system/lib/chipset-pub-sdk:/system/lib/chipset-sdk:/system/lib/platformsdk:/system/lib/module:/system/lib/module/data:/system/lib/module/multimedia:/system/lib/module/security:/lib:/usr/local/lib:/usr/lib:/lib/platformsdk:/lib/chipset-pub-sdk:/sys_prod/lib
+    namespace.default.asan.lib.paths = /data/tests/libc-test/src:/system/lib:/system/lib/module:/vendor/lib:/vendor/lib/chipsetsdk:/vendor/lib/chipset-sdk:/system/lib/module/data:/system/lib/module/multimedia:/system/lib/module/security:/lib:/usr/local/lib:/usr/lib:/lib/platformsdk:/lib/chipset-pub-sdk:/sys_prod/lib
+
+[test] 
+    added.nslist=ndk,ns_no_allowed_libs,ns_normal,ns_wrong_lib_path,ns_wrong_allowed_path,for_inherit_A,for_inherit_AA,inherited_class,ns_separated_flase,ns_asan_lib_path,ns_asan_permit_path
+
+    namespace.ndk.lib.paths = /system/lib/ndk
+    namespace.default.inherits = ndk
+    namespace.default.inherit.ndk.shared.libs = allow_all_shared_libs
+    namespace.ndk.inherits = default
+    namespace.ndk.inherit.default.shared.libs = allow_all_shared_libs
+
+    #ns_no_allowed_libs ,allowed libs not configed
+    namespace.ns_no_allowed_libs.separated = true
+    namespace.ns_no_allowed_libs.lib.paths = /data/tests/libc-test/src
+
+    #ns_normal ,normal namespace
+    namespace.ns_normal.separated = true
+    namespace.ns_normal.lib.paths = /data/tests/libc-test/src
+    namespace.ns_normal.allowed.libs = libdlopen_ns_dso.so
+
+    #ns_wrong_lib_path ,path in allowed_libs,but not in env or lib or permitted Path
+    namespace.ns_wrong_lib_path.separated = true
+    namespace.ns_wrong_lib_path.lib.paths = src/common/
+    namespace.ns_wrong_lib_path.allowed.libs =  libdlopen_ns_dso.so
+    namespace.ns_wrong_lib_path.permitted.paths = /data/tests
+
+    #ns_wrong_allowed_path ,path not in allowed_libs
+    namespace.ns_wrong_allowed_path.separated = true
+    namespace.ns_wrong_allowed_path.lib.paths = /data/tests/libc-test/src/functionalext/dlns
+    namespace.ns_wrong_allowed_path.allowed.libs =  libdlopen_dso.so
+
+    #for testing inheritance
+    namespace.for_inherit_A.separated = true
+    #for testing inheritance
+    namespace.for_inherit_AA.separated = true
+
+    #inherited_class
+    namespace.inherited_class.separated = true
+    namespace.inherited_class.lib.paths = /data/tests/libc-test/src
+    namespace.inherited_class.allowed.libs= libdlopen_ns_dso.so:sharedlibtest.so
+
+    #ns_separated_flase
+    namespace.ns_separated_flase.separated = false
+    namespace.ns_separated_flase.lib.paths = /data/tests/libc-test/src
+    namespace.ns_separated_flase.allowed.libs =  libdlopen_ns_dso.so
+
+    #ns_asan_lib_path ,testing asan.lib.paths
+    namespace.ns_asan_lib_path.separated = true
+    namespace.ns_asan_lib_path.lib.paths = /data/tests/libc-test/src
+    namespace.ns_asan_lib_path.asan.lib.paths = /data/tests/libc-test/src/B
+
+    #ns_asan_permit_path ,testing asan.permitted.paths
+    namespace.ns_asan_permit_path.separated = true
+    namespace.ns_asan_permit_path.permitted.paths = /data/tests/libc-test/src/C
+    namespace.ns_asan_permit_path.asan.permitted.paths = /data/tests/libc-test/src/B
+
diff --git a/config/ld-musl-namespace-arm.ini b/config/ld-musl-namespace-arm.ini
new file mode 100644
index 00000000..708d8e7e
--- /dev/null
+++ b/config/ld-musl-namespace-arm.ini
@@ -0,0 +1,12 @@
+[section.dir.map]
+    acquiescence = /system/bin:/vendor/bin:/data/local/tmp
+
+[acquiescence]
+    added.nslist = ndk
+    namespace.ndk.lib.paths = /system/lib/ndk
+    namespace.default.lib.paths = /system/lib:/vendor/lib:/vendor/lib/chipsetsdk:/vendor/lib/chipset-sdk:/system/lib/chipset-pub-sdk:/system/lib/chipset-sdk:/system/lib/platformsdk:/system/lib/module:/system/lib/module/data:/system/lib/module/multimedia:/system/lib/module/security:/sys_prod/lib:/lib:/usr/local/lib:/usr/lib:/lib/platformsdk:/lib/chipset-pub-sdk
+    namespace.default.asan.lib.paths = /system/lib:/system/lib/module:/vendor/lib:/vendor/lib/chipsetsdk:/vendor/lib/chipset-sdk:/system/lib/module/data:/system/lib/module/multimedia:/system/lib/module/security:/lib:/usr/local/lib:/usr/lib:/lib/platformsdk:/lib/chipset-pub-sdk:/sys_prod/lib
+    namespace.default.inherits = ndk
+    namespace.default.inherit.ndk.shared.libs = allow_all_shared_libs
+    namespace.ndk.inherits = default
+    namespace.ndk.inherit.default.shared.libs = allow_all_shared_libs
\ No newline at end of file
diff --git a/config/ld-musl-namespace-x86_64-test.ini b/config/ld-musl-namespace-x86_64-test.ini
new file mode 100644
index 00000000..06453d0f
--- /dev/null
+++ b/config/ld-musl-namespace-x86_64-test.ini
@@ -0,0 +1,62 @@
+[section.dir.map]
+    acquiescence = /
+    test = /data/tests/libc-test/src
+
+[acquiescence]
+    namespace.default.lib.paths = /data/tests/libc-test/src:/system/lib64:/vendor/lib64:/vendor/lib64/chipsetsdk:/vendor/lib64/chipset-sdk:/system/lib64/chipset-pub-sdk:/system/lib64/chipset-sdk:/system/lib64/platformsdk:/system/lib64/priv-platformsdk:/system/lib64/priv-module:/system/lib64/module:/system/lib64/module/data:/system/lib64/module/multimedia:/system/lib64/module/security:/lib64:/lib64/platformsdk:/lib64/chipset-pub-sdk:/sys_prod/lib64
+    namespace.default.asan.lib.paths = /data/tests/libc-test/src:/system/lib64:/system/lib64/module:/vendor/lib64:/vendor/lib64/chipsetsdk:/vendor/lib64/chipset-sdk:/system/lib64/module/data:/system/lib64/module/multimedia:/system/lib64/module/security:/lib64:/lib64/platformsdk:/lib64/chipset-pub-sdk:/sys_prod/lib64
+
+[test] 
+    added.nslist=ndk,ns_no_allowed_libs,ns_normal,ns_wrong_lib_path,ns_wrong_allowed_path,for_inherit_A,for_inherit_AA,inherited_class,ns_separated_flase,ns_asan_lib_path,ns_asan_permit_path
+
+    namespace.ndk.lib.paths = /system/lib/ndk
+    namespace.default.inherits = ndk
+    namespace.default.inherit.ndk.shared.libs = allow_all_shared_libs
+    namespace.ndk.inherits = default
+    namespace.ndk.inherit.default.shared.libs = allow_all_shared_libs
+
+    #ns_no_allowed_libs ,allowed libs not configed
+    namespace.ns_no_allowed_libs.separated = true
+    namespace.ns_no_allowed_libs.lib.paths = /data/tests/libc-test/src
+
+    #ns_normal ,normal namespace
+    namespace.ns_normal.separated = true
+    namespace.ns_normal.lib.paths = /data/tests/libc-test/src
+    namespace.ns_normal.allowed.libs = libdlopen_ns_dso.so
+
+    #ns_wrong_lib_path ,path in allowed_libs,but not in env or lib or permitted Path
+    namespace.ns_wrong_lib_path.separated = true
+    namespace.ns_wrong_lib_path.lib.paths = src/common/
+    namespace.ns_wrong_lib_path.allowed.libs =  libdlopen_ns_dso.so
+    namespace.ns_wrong_lib_path.permitted.paths = /data/tests
+
+    #ns_wrong_allowed_path ,path not in allowed_libs
+    namespace.ns_wrong_allowed_path.separated = true
+    namespace.ns_wrong_allowed_path.lib.paths = /data/tests/libc-test/src/functionalext/dlns
+    namespace.ns_wrong_allowed_path.allowed.libs =  libdlopen_dso.so
+
+    #for testing inheritance
+    namespace.for_inherit_A.separated = true
+    #for testing inheritance
+    namespace.for_inherit_AA.separated = true
+
+    #inherited_class
+    namespace.inherited_class.separated = true
+    namespace.inherited_class.lib.paths = /data/tests/libc-test/src
+    namespace.inherited_class.allowed.libs= libdlopen_ns_dso.so:sharedlibtest.so
+
+    #ns_separated_flase
+    namespace.ns_separated_flase.separated = false
+    namespace.ns_separated_flase.lib.paths = /data/tests/libc-test/src
+    namespace.ns_separated_flase.allowed.libs =  libdlopen_ns_dso.so
+
+    #ns_asan_lib_path ,testing asan.lib.paths
+    namespace.ns_asan_lib_path.separated = true
+    namespace.ns_asan_lib_path.lib.paths = /data/tests/libc-test/src
+    namespace.ns_asan_lib_path.asan.lib.paths = /data/tests/libc-test/src/B
+
+    #ns_asan_permit_path ,testing asan.permitted.paths
+    namespace.ns_asan_permit_path.separated = true
+    namespace.ns_asan_permit_path.permitted.paths = /data/tests/libc-test/src/C
+    namespace.ns_asan_permit_path.asan.permitted.paths = /data/tests/libc-test/src/B
+
diff --git a/config/ld-musl-namespace-x86_64.ini b/config/ld-musl-namespace-x86_64.ini
new file mode 100644
index 00000000..d5a6fb02
--- /dev/null
+++ b/config/ld-musl-namespace-x86_64.ini
@@ -0,0 +1,12 @@
+[section.dir.map]
+    acquiescence = /system/bin:/vendor/bin:/data/local/tmp
+
+[acquiescence]
+    added.nslist = ndk
+    namespace.ndk.lib.paths = /system/lib64/ndk:/system/lib/ndk
+    namespace.default.lib.paths = /system/lib64:/vendor/lib64:/vendor/lib64/chipsetsdk:/vendor/lib64/chipset-sdk:/system/lib64/chipset-pub-sdk:/system/lib64/chipset-sdk:/system/lib64/platformsdk:/system/lib64/priv-platformsdk:/system/lib64/priv-module:/system/lib64/module:/system/lib64/module/data:/system/lib64/module/multimedia:/system/lib64/module/security:/lib64:/lib64/platformsdk:/lib64/chipset-pub-sdk:/sys_prod/lib64
+    namespace.default.asan.lib.paths = /system/lib64:/system/lib64/module:/vendor/lib64:/vendor/lib64/chipsetsdk:/vendor/lib64/chipset-sdk:/system/lib64/module/data:/system/lib64/module/multimedia:/system/lib64/module/security:/lib64:/lib64/platformsdk:/lib64/chipset-pub-sdk:/sys_prod/lib64
+    namespace.default.inherits = ndk
+    namespace.default.inherit.ndk.shared.libs = allow_all_shared_libs
+    namespace.ndk.inherits = default
+    namespace.ndk.inherit.default.shared.libs = allow_all_shared_libs
\ No newline at end of file
diff --git a/crt/aarch64/crti.s b/crt/aarch64/crti.s
index 775df0ac..d82bcb31 100644
--- a/crt/aarch64/crti.s
+++ b/crt/aarch64/crti.s
@@ -1,6 +1,9 @@
+.include "crtbrand.s"
+
 .section .init
 .global _init
 .type _init,%function
+.balign 4
 _init:
 	stp x29,x30,[sp,-16]!
 	mov x29,sp
@@ -8,6 +11,7 @@ _init:
 .section .fini
 .global _fini
 .type _fini,%function
+.balign 4
 _fini:
 	stp x29,x30,[sp,-16]!
 	mov x29,sp
diff --git a/crt/arm/crti.s b/crt/arm/crti.s
index 18dc1e41..aae0ddca 100644
--- a/crt/arm/crti.s
+++ b/crt/arm/crti.s
@@ -1,13 +1,17 @@
+.include "crtbrand.s"
+
 .syntax unified
 
 .section .init
 .global _init
 .type _init,%function
+.balign 4
 _init:
 	push {r0,lr}
 
 .section .fini
 .global _fini
 .type _fini,%function
+.balign 4
 _fini:
 	push {r0,lr}
diff --git a/crt/crtplus.c b/crt/crtplus.c
new file mode 100644
index 00000000..14ed7d79
--- /dev/null
+++ b/crt/crtplus.c
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+__attribute__((weak, visibility("hidden")))
+void __emutls_unregister_key(void)
+{
+}
+
+__attribute__((destructor(0)))
+static void __on_dlclose_late(void)
+{
+    __emutls_unregister_key();
+}
\ No newline at end of file
diff --git a/crt/x86_64/crti.s b/crt/x86_64/crti.s
index 4788968b..104d9183 100644
--- a/crt/x86_64/crti.s
+++ b/crt/x86_64/crti.s
@@ -1,3 +1,5 @@
+.include "crtbrand.s"
+
 .section .init
 .global _init
 _init:
diff --git a/etc/musl.para b/etc/musl.para
new file mode 100644
index 00000000..d95e23a4
--- /dev/null
+++ b/etc/musl.para
@@ -0,0 +1,31 @@
+# Copyright (c) 2022 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+musl.log.enable=false
+
+# ================================
+# sample:
+# 
+# * enable ld log for all apps
+# musl.log.ld.all=true
+#
+# * enable ld log for specified app
+# musl.log.ld.all=false
+# musl.log.ld.app.your_app_name=true
+#
+# * enable ld log for apps excluding the specified app
+# musl.log.ld.all=true
+# musl.log.ld.app.your_app_name=false
+# ================================
+
+musl.log.ld.all=true
\ No newline at end of file
diff --git a/etc/musl.para.dac b/etc/musl.para.dac
new file mode 100644
index 00000000..6e830d09
--- /dev/null
+++ b/etc/musl.para.dac
@@ -0,0 +1,14 @@
+# Copyright (c) 2023 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+llvm.debug.service. = root:root:0700
\ No newline at end of file
diff --git a/include/ctype.h b/include/ctype.h
index 32bcef4d..fe72b3ff 100644
--- a/include/ctype.h
+++ b/include/ctype.h
@@ -68,6 +68,11 @@ int   toascii(int);
 #define isascii(a) (0 ? isascii(a) : (unsigned)(a) < 128)
 #endif
 
+#include <stdint.h>
+
+const int32_t **__ctype_tolower_loc(void);
+const int32_t **__ctype_toupper_loc(void);
+
 #endif
 
 #ifdef __cplusplus
diff --git a/include/dlfcn.h b/include/dlfcn.h
index 13ab71dd..07f810db 100644
--- a/include/dlfcn.h
+++ b/include/dlfcn.h
@@ -1,12 +1,13 @@
 #ifndef	_DLFCN_H
 #define	_DLFCN_H
 
+#include <features.h>
+#include <stdbool.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#include <features.h>
-
 #define RTLD_LAZY   1
 #define RTLD_NOW    2
 #define RTLD_NOLOAD 4
@@ -19,10 +20,148 @@ extern "C" {
 
 #define RTLD_DI_LINKMAP 2
 
+
+/* create flags for dlns_create */
+#define CREATE_INHERIT_DEFAULT 0x1
+#define CREATE_INHERIT_CURRENT 0x2
+#define LOCAL_NS_PREFERED 0x4 /* Use app's library when app's library has same name as system library. */
+
 int    dlclose(void *);
 char  *dlerror(void);
 void  *dlopen(const char *, int);
 void  *dlsym(void *__restrict, const char *__restrict);
+void  *dlvsym(void *__restrict, const char *__restrict, const char *__restrict);
+
+/* namespace apis */
+#define NS_NAME_MAX 255
+typedef struct {
+	char name[NS_NAME_MAX+1];
+} Dl_namespace;
+
+/**
+  * @brief Initialize a namespace structure for operating namespaces through related functional interfaces.
+  * @param Dl_namespace * namespace handle.
+  * @param char * namespace name.
+  * @return void.
+  * @retval none.
+  */
+void dlns_init(Dl_namespace *, const char *);
+
+/**
+  * @brief Gets the current namespace handle, or verifies that the given name namespace exists.
+  * @param char * Namespace name.Gets the current caller namespace handle when name is null.
+  * @param Dl_namespace * namespace handle.
+  * @return return 0 on success,fail other values.
+  * @retval
+  *    EINVAL(22) Invalid argument.
+  *    ENOKEY(126) Required key not available.
+  */
+int dlns_get(const char *, Dl_namespace *);
+
+/**
+  * @brief open dso in given namespace which has own lib search paths, when namespace is null, it's same to dlopen().
+  *        avoid using "default" as namespace, which is the default namespace.
+  * @param Dl_namespace * namespace handle.
+  * @param char * the name of the so file you want to open.
+  * @param int open file mode.
+  *    -- RTLD_LAZY.
+  *    -- RTLD_NOW.
+  *    -- RTLD_NOLOAD.
+  *    -- RTLD_NODELETE.
+  *    -- RTLD_GLOBAL.
+  *    -- RTLD_LOCAL.
+  * @return success: dynamic library handleoid,failed: NULL.
+  * @retval none.
+  */
+void *dlopen_ns(Dl_namespace *, const char *, int);
+
+/**
+  * @brief create the namespace and set lib search paths of namespace,
+  *        the paths should be splited by ':'. When namespace already exist,return error.
+  *        avoid using "default" as namespace, which is the default namespace.
+  * @param Dl_namespace * namespace handle.
+  * @param char * lib path library that can be specified.
+  * @return return 0 on success,fail other values.
+  * @retval
+  *    EINVAL(22) Invalid argument.
+  *    EEXIST(17) File exists.
+  *    ENOMEM(12) Out of memory.
+  */
+int dlns_create(Dl_namespace *, const char *);
+
+/**
+  * @brief create the namespace and set lib search paths of namespace,
+  *        like dlns_create, except can use flags to set parent ns.
+  * @param Dl_namespace * namespace handle.
+  * @param char * lib path library that can be specified.
+  * #param int flags for create namespace, CREATE_INHERIT_CURRENT or CREATE_INHERIT_DEFAULT.
+  * @return return 0 on success,fail other values.
+  * @retval
+  *    EINVAL(22) Invalid argument.
+  *    EEXIST(17) File exists.
+  *    ENOMEM(12) Out of memory.
+  */
+int dlns_create2(Dl_namespace *, const char *, int);
+
+/**
+  * @brief make one namespace inherit another, and so it can use shared libs by the inherited one.
+  *        param1: namespace, param2: inherited namespace, param3: shared libs.
+  *        the shared libs should be splited by ':'. when it is null or empty, all libs can be shared.
+  *        one namespace can inherit or be inherited by multiple ones.
+  *        When namespaces do not exist, return error.
+  * @param Dl_namespace * The first parameter is the namespace to inherit from.
+  * @param Dl_namespace * The second parameter is the inherited namespace.
+  * @param char * some library names to inherit.
+  * @return return 0 on success,fail other values.
+  * @retval
+  *    EINVAL(22) Invalid argument.
+  *    ENOKEY(126) Required key not available.
+  */
+int dlns_inherit(Dl_namespace *, Dl_namespace *, const char *);
+
+/**
+  * @brief Set namespace lib_path.
+  * @param name namespace name.
+  * @param lib_path The lib path name that needs to be reset, it can be multiple, link with ":".
+  * @return Returns 0 on success, other on failure.
+  * @retval
+  *    EINVAL(22) Invalid argument.
+  *    ENOKEY(126) Required key not available.
+  */
+int dlns_set_namespace_lib_path(const char *name, const char *lib_path);
+
+/**
+  * @brief Set namespace separated.
+  * @param name namespace name.
+  * @param separated separated.
+  * @return Returns 0 on success, other on failure.
+  * @retval
+  *    EINVAL(22) Invalid argument.
+  *    ENOKEY(126) Required key not available.
+  */
+int dlns_set_namespace_separated(const char *name, const bool separated);
+
+/**
+  * @brief Set namespace permitted_paths.
+  * @param name namespace name.
+  * @param permitted_paths set new permitted_paths.
+  * @return Returns 0 on success, other on failure.
+  * @retval
+  *    EINVAL(22) Invalid argument.
+  *    ENOKEY(126) Required key not available.
+  */
+int dlns_set_namespace_permitted_paths(const char *name, const char *permitted_paths);
+
+/**
+  * @brief Set namespace allowed_libs.
+  * @param name namespace name.
+  * @param allowed_libs set new allowed_libs.
+  * @return Returns 0 on success, other on failure.
+  * @retval
+  *    EINVAL(22) Invalid argument.
+  *    ENOKEY(126) Required key not available.
+  */
+int dlns_set_namespace_allowed_libs(const char *name, const char *allowed_libs);
 
 #if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
 typedef struct {
diff --git a/include/dlfcn_ext.h b/include/dlfcn_ext.h
new file mode 100644
index 00000000..72d5ae1a
--- /dev/null
+++ b/include/dlfcn_ext.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef DLFCN_EXT_H
+#define DLFCN_EXT_H
+
+#include <dlfcn.h>
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* for dl_extinfo flag */
+#define DL_EXT_WRITE_RELRO 0x1
+#define DL_EXT_USE_RELRO 0x2
+#define DL_EXT_RESERVED_ADDRESS_RECURSIVE 0x4
+#define DL_EXT_RESERVED_ADDRESS 0x8
+#define DL_EXT_RESERVED_ADDRESS_HINT 0x10
+
+/** Mask of valid bits. */
+#define DL_EXT_VALID_FLAG_BITS                                                                             \
+    (DL_EXT_WRITE_RELRO | DL_EXT_USE_RELRO | DL_EXT_RESERVED_ADDRESS_RECURSIVE | DL_EXT_RESERVED_ADDRESS | \
+        DL_EXT_RESERVED_ADDRESS_HINT)
+
+typedef struct {
+    int flag;
+    int relro_fd;
+    void *reserved_addr;
+    size_t reserved_size;
+} dl_extinfo;
+
+/**
+ * @brief Loads the dynamic shared object (shared library) file with the extended feature.
+ *        If extinfo is NULL, it is equivalent to dlopen.
+ *        If DL_EXT_WRITE_RELRO is set in extinfo, the GNU RELRO section will be written to relro_fd and allowed to
+ *        reused by other process loading the same library at the same address.
+ *        IF DL_EXT_USE_RELRO is set in extinfo, the GNU RELRO section written in relro_fd will be reused.
+ * @param file Equivalent to the argument of dlopen.
+ * @param mode Equivalent to the argument of dlopen.
+ * @param extinfo Indicates the dl_extinfo struct.
+ * @return Returns a non-NULL handle for the loaded object on success. On error returns NULL.
+ */
+void *dlopen_ext(const char *file, int mode, const dl_extinfo *extinfo);
+
+/**
+  * @brief open dso in given namespace which has own lib search paths,
+  *        when namespace is null, it's same to dlopen_ext().
+  *        avoid using "default" as namespace, which is the default namespace.
+  * @param Dl_namespace * Carry the naming information of the namespace.
+  * @param char * the name of the so file you want to open.
+  * @param int open file mode.
+  *    -- RTLD_LAZY.
+  *    -- RTLD_NOW.
+  *    -- RTLD_NOLOAD.
+  *    -- RTLD_NODELETE.
+  *    -- RTLD_GLOBAL.
+  *    -- RTLD_LOCAL.
+  * @param dl_extinfo * indicates the dl_extinfo struct,include flag and relro_fd.
+  * @return success: dynamic library handleoid,failed: NULL.
+  * @retval none.
+  */
+void *dlopen_ns_ext(Dl_namespace *, const char *, int, const dl_extinfo *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/include/elf.h b/include/elf.h
index 86e2f0bb..d3020899 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -385,7 +385,8 @@ typedef struct {
 #define SHT_PREINIT_ARRAY 16
 #define SHT_GROUP	  17
 #define SHT_SYMTAB_SHNDX  18
-#define	SHT_NUM		  19
+#define	SHT_RELR		  19
+#define	SHT_NUM		  20
 #define SHT_LOOS	  0x60000000
 #define SHT_GNU_ATTRIBUTES 0x6ffffff5
 #define SHT_GNU_HASH	  0x6ffffff6
@@ -612,6 +613,7 @@ typedef struct {
 #define PT_LOPROC	0x70000000
 #define PT_HIPROC	0x7fffffff
 
+#define PT_OHOS_RANDOMDATA	0x6788fc60
 
 #define PN_XNUM 0xffff
 
@@ -754,7 +756,10 @@ typedef struct {
 #define DT_PREINIT_ARRAY 32
 #define DT_PREINIT_ARRAYSZ 33
 #define DT_SYMTAB_SHNDX	34
-#define	DT_NUM		35
+#define DT_RELRSZ	35
+#define DT_RELR		36
+#define DT_RELRENT	37
+#define	DT_NUM		38
 #define DT_LOOS		0x6000000d
 #define DT_HIOS		0x6ffff000
 #define DT_LOPROC	0x70000000
@@ -1091,7 +1096,6 @@ typedef struct {
 #define NT_GNU_PROPERTY_TYPE_0	5
 
 
-
 typedef struct {
   Elf32_Xword m_value;
   Elf32_Word m_info;
diff --git a/include/fcntl.h b/include/fcntl.h
index b664cdc4..98c165f1 100644
--- a/include/fcntl.h
+++ b/include/fcntl.h
@@ -20,6 +20,7 @@ extern "C" {
 #include <bits/alltypes.h>
 
 #include <bits/fcntl.h>
+#include <fortify/fcntl.h>
 
 struct flock {
 	short l_type;
diff --git a/include/fortify/fcntl.h b/include/fortify/fcntl.h
new file mode 100644
index 00000000..af46bd13
--- /dev/null
+++ b/include/fortify/fcntl.h
@@ -0,0 +1,129 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _FCNTL_H
+#error "Never include this file directly; instead, include <fcntl.h>"
+#endif
+
+#include "fortify.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int __open_chk(const char*, int);
+int __openat_chk(int, const char*, int);
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+int __open64_chk(const char*, int);
+int __openat64_chk(int, const char*, int);
+#endif
+/*
+ * Even in musl FORTIFY, the following is the easiest way to call a real open.
+ */
+int __open_real(const char*, int, ...) __DIAGNOSE_RENAME(open);
+int __openat_real(int, const char*, int, ...) __DIAGNOSE_RENAME(openat);
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+int __open64_real(const char*, int, ...) __DIAGNOSE_RENAME(open64);
+int __openat64_real(int, const char*, int, ...) __DIAGNOSE_RENAME(openat64);
+#endif
+
+#ifdef __FORTIFY_COMPILATION
+__DIAGNOSE_FORTIFY_INLINE
+int open(const char* const __DIAGNOSE_PASS_OBJECT_SIZE path, int flags)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_OPEN_MODES_USEFUL(flags), "'open' " OPEN_TOO_FEW_ARGS_ERROR)
+{
+#ifdef __FORTIFY_RUNTIME
+    return __open_chk(path, flags);
+#else
+    return __open_real(path, flags);
+#endif
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+int open(const char* const __DIAGNOSE_PASS_OBJECT_SIZE path, int flags, unsigned modes)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_WARNING_IF(!__DIAGNOSE_OPEN_MODES_USEFUL(flags) && modes, "'open' " OPEN_USELESS_MODES_WARNING)
+{
+    return __open_real(path, flags, modes);
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+int openat(int dirfd, const char* const __DIAGNOSE_PASS_OBJECT_SIZE path, int flags)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_OPEN_MODES_USEFUL(flags), "'openat' " OPEN_TOO_FEW_ARGS_ERROR)
+{
+#ifdef __FORTIFY_RUNTIME
+    return __openat_chk(dirfd, path, flags);
+#else
+    return __openat_real(dirfd, path, flags);
+#endif
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+int openat(int dirfd, const char* const __DIAGNOSE_PASS_OBJECT_SIZE path, int flags, mode_t modes)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_WARNING_IF(!__DIAGNOSE_OPEN_MODES_USEFUL(flags) && modes, "'openat' " OPEN_USELESS_MODES_WARNING)
+{
+    return __openat_real(dirfd, path, flags, modes);
+}
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+__DIAGNOSE_FORTIFY_INLINE
+int open64(const char* const __DIAGNOSE_PASS_OBJECT_SIZE path, int flags)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_OPEN_MODES_USEFUL(flags), "'open64' " OPEN_TOO_FEW_ARGS_ERROR)
+{
+#ifdef __FORTIFY_RUNTIME
+    return __open64_chk(path, flags);
+#else
+    return __open64_real(path, flags);
+#endif
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+int open64(const char* const __DIAGNOSE_PASS_OBJECT_SIZE path, int flags, mode_t modes)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_WARNING_IF(!__DIAGNOSE_OPEN_MODES_USEFUL(flags) && modes, "'open64' " OPEN_USELESS_MODES_WARNING)
+{
+    return __open64_real(path, flags, modes);
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+int openat64(int dirfd, const char* const __DIAGNOSE_PASS_OBJECT_SIZE path, int flags)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_OPEN_MODES_USEFUL(flags), "'openat64' " OPEN_TOO_FEW_ARGS_ERROR)
+{
+#ifdef __FORTIFY_RUNTIME
+    return __openat64_chk(dirfd, path, flags);
+#else
+    return __openat64_real(dirfd, path, flags);
+#endif
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+int openat64(int dirfd, const char* const __DIAGNOSE_PASS_OBJECT_SIZE path, int flags, mode_t modes)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_WARNING_IF(!__DIAGNOSE_OPEN_MODES_USEFUL(flags) && modes, "'openat64' " OPEN_USELESS_MODES_WARNING)
+{
+    return __openat64_real(dirfd, path, flags, modes);
+}
+#endif
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/include/fortify/fortify.h b/include/fortify/fortify.h
new file mode 100644
index 00000000..961a163b
--- /dev/null
+++ b/include/fortify/fortify.h
@@ -0,0 +1,137 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef	_FORTIFY_FORTIFY_H
+#define	_FORTIFY_FORTIFY_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if (_FORTIFY_SOURCE == 1) || (_FORTIFY_SOURCE == 2)
+#ifndef __FORTIFY_COMPILATION
+#define __FORTIFY_COMPILATION
+#endif
+#endif
+
+#if (_FORTIFY_SOURCE == 2)
+#ifndef __FORTIFY_RUNTIME
+#define __FORTIFY_RUNTIME
+#endif
+#endif
+
+#if defined(__cplusplus)
+#define __DIAGNOSE_CAST(_k, _t, _v) (_k<_t>(_v))
+#else
+#define __DIAGNOSE_CAST(_k, _t, _v) ((_t) (_v))
+#endif
+
+#if defined(__LP64__)
+#ifndef	FORTIFY_LONG_MAX
+#define FORTIFY_LONG_MAX 0x7fffffffffffffffL
+#endif
+#ifndef	FORTIFY_SSIZE_MAX
+#define FORTIFY_SSIZE_MAX FORTIFY_LONG_MAX
+#endif
+#else
+#ifndef	FORTIFY_LONG_MAX
+#define FORTIFY_LONG_MAX 0x7fffffffL
+#endif
+#ifndef	FORTIFY_SSIZE_MAX
+#define FORTIFY_SSIZE_MAX FORTIFY_LONG_MAX
+#endif
+#endif
+#ifndef	FORTIFY_PATH_MAX
+#define FORTIFY_PATH_MAX 4096
+#endif
+
+#define __DIAGNOSE_ALWAYS_INLINE __attribute__((__always_inline__))
+#define	__DIAGNOSE_PREDICT_TRUE(exp)	__builtin_expect((exp) != 0, 1)
+#define	__DIAGNOSE_PREDICT_FALSE(exp)	__builtin_expect((exp) != 0, 0)
+#define __DIAGNOSE_ENABLE_IF(cond, msg) __attribute__((enable_if(cond, msg)))
+#define __DIAGNOSE_ERROR_IF(cond, msg) __attribute__((diagnose_if(cond, msg, "error")))
+#define __DIAGNOSE_WARNING_IF(cond, msg) __attribute__((diagnose_if(cond, msg, "warning")))
+
+#define __DIAGNOSE_BOS_LEVEL (1)
+#define __DIAGNOSE_BOSN(s, n) __builtin_object_size((s), (n))
+#define __DIAGNOSE_BOS(s) __DIAGNOSE_BOSN((s), __DIAGNOSE_BOS_LEVEL)
+
+#define __DIAGNOSE_BOS0(s) __DIAGNOSE_BOSN((s), 0)
+#define __DIAGNOSE_PASS_OBJECT_SIZE_N(n) __attribute__((pass_object_size(n)))
+#define __DIAGNOSE__SIZE_MUL_OVERFLOW(a, b, result) __builtin_umull_overflow(a, b, result)
+#define __DIAGNOSE_PRINTFLIKE(x, y) __attribute__((__format__(printf, x, y)))
+#define __DIAGNOSE_CALL_BYPASSING_FORTIFY(fn) (&(fn))
+#define __DIAGNOSE_FORTIFY_INLINE static __inline__ __attribute__((no_stack_protector)) \
+    __DIAGNOSE_ALWAYS_INLINE
+
+#define __DIAGNOSE_FORTIFY_VARIADIC static __inline__
+
+#define __DIAGNOSE_PASS_OBJECT_SIZE __DIAGNOSE_PASS_OBJECT_SIZE_N(__DIAGNOSE_BOS_LEVEL)
+#define __DIAGNOSE_PASS_OBJECT_SIZE0 __DIAGNOSE_PASS_OBJECT_SIZE_N(0)
+
+#define __DIAGNOSE_FORTIFY_UNKNOWN_SIZE ((unsigned int) -1)
+/* The following are intended for use in unevaluated environments, e.g. diagnose_if conditions. */
+#define __DIAGNOSE_UNEVALUATED_LT(bos_val, val) \
+((bos_val) != __DIAGNOSE_FORTIFY_UNKNOWN_SIZE && (bos_val) < (val))
+
+#define __DIAGNOSE_UNEVALUATED_LE(bos_val, val) \
+    ((bos_val) != __DIAGNOSE_FORTIFY_UNKNOWN_SIZE && (bos_val) <= (val))
+
+/* The following acts in the context of evaluation. */
+#define __DIAGNOSE_BOS_DYNAMIC_CHECK_IMPL_AND(bos_val, op, index, cond) \
+    ((bos_val) == __DIAGNOSE_FORTIFY_UNKNOWN_SIZE ||                 \
+    (__builtin_constant_p(index) && bos_val op index && (cond)))
+
+#define __DIAGNOSE_BOS_DYNAMIC_CHECK_IMPL(bos_val, op, index) \
+    __DIAGNOSE_BOS_DYNAMIC_CHECK_IMPL_AND(bos_val, op, index, 1)
+
+#define __DIAGNOSE_BOS_TRIVIALLY_GE(bos_val, index) __DIAGNOSE_BOS_DYNAMIC_CHECK_IMPL((bos_val), >=, (index))
+#define __DIAGNOSE_BOS_TRIVIALLY_GT(bos_val, index) __DIAGNOSE_BOS_DYNAMIC_CHECK_IMPL((bos_val), >, (index))
+
+#define __DIAGNOSE_OVERLOAD __attribute__((overloadable))
+
+/*
+ * A function to prevent this function from being applied.
+ * Used to rename the function so that the compiler emits a call to "x".
+ */
+#define __DIAGNOSE_RENAME(x) __asm__(#x)
+#define __DIAGNOSE_OPEN_MODES_USEFUL(flags) (((flags) & O_CREAT) || ((flags) & O_TMPFILE) == O_TMPFILE)
+#define __DIAGNOSE_BOS_FD_COUNT_TRIVIALLY_SAFE(bos_val, fds, fd_count)              \
+    __DIAGNOSE_BOS_DYNAMIC_CHECK_IMPL_AND((bos_val), >=, (sizeof(*(fds)) * (fd_count)), \
+    (fd_count) <= __DIAGNOSE_CAST(static_cast, unsigned int, -1) / sizeof(*(fds)))
+
+#define __DIAGNOSE_UNSAFE_CHK_MUL_OVERFLOW(x, y) ((__SIZE_TYPE__)-1 / (x) < (y))
+
+#define __DIAGNOSE_BOS_TRIVIALLY_GE_MUL(bos_val, size, count) \
+    __DIAGNOSE_BOS_DYNAMIC_CHECK_IMPL_AND(bos_val, >=, (size) * (count), \
+    !__DIAGNOSE_UNSAFE_CHK_MUL_OVERFLOW(size, count))
+
+#define FORTIFY_RUNTIME_ERROR_PREFIX "Musl Fortify runtime error: "
+#define OPEN_TOO_MANY_ARGS_ERROR "There are too many arguments"
+#define OPEN_TOO_FEW_ARGS_ERROR "invoking with O_CREAT or O_TMPFILE, but missing pattern."
+#define OPEN_USELESS_MODES_WARNING "having redundant mode bits; but missing O_CREAT."
+#define CALLED_WITH_STRING_BIGGER_BUFFER "called with a string larger than the buffer"
+#define FD_COUNT_LARGE_GIVEN_BUFFER "fd_count is greater than the given buffer"
+#define CALLED_WITH_SIZE_BIGGER_BUFFER "called with bigger size than the buffer"
+#define OUTPUT_PARAMETER_BYTES "the output parameter must be nullptr or a pointer to the buffer with >= FORTIFY_PATH_MAX bytes"
+#define SIZE_LARGER_THEN_DESTINATION_BUFFER "the size is greater than the target buffer"
+
+void __fortify_error(const char* info, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/include/fortify/poll.h b/include/fortify/poll.h
new file mode 100644
index 00000000..69497835
--- /dev/null
+++ b/include/fortify/poll.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _POLL_H
+#error "Never include this file directly; instead, include <poll.h>"
+#endif
+
+#include <signal.h>
+#include "fortify.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int __poll_chk(struct pollfd*, nfds_t, int, size_t);
+#ifdef _GNU_SOURCE
+int __ppoll_chk(struct pollfd*, nfds_t, const struct timespec*, const sigset_t*, size_t);
+#endif
+
+#ifdef __FORTIFY_COMPILATION
+__DIAGNOSE_FORTIFY_INLINE
+int poll(struct pollfd* const fds __DIAGNOSE_PASS_OBJECT_SIZE, nfds_t fd_amount, int timeout)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LT(__DIAGNOSE_BOS(fds), sizeof(*fds) * fd_amount),
+    "in call to 'poll', " FD_COUNT_LARGE_GIVEN_BUFFER)
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos_fds = __DIAGNOSE_BOS(fds);
+
+    if (!__DIAGNOSE_BOS_FD_COUNT_TRIVIALLY_SAFE(bos_fds, fds, fd_amount)) {
+        return __poll_chk(fds, fd_amount, timeout, bos_fds);
+    }
+#endif
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(poll)(fds, fd_amount, timeout);
+}
+
+#ifdef _GNU_SOURCE
+__DIAGNOSE_FORTIFY_INLINE
+int ppoll(struct pollfd* const fds __DIAGNOSE_PASS_OBJECT_SIZE, nfds_t fd_amount,
+    const struct timespec* timeout, const sigset_t* mask)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LT(__DIAGNOSE_BOS(fds), sizeof(*fds) * fd_amount),
+    "in call to 'ppoll', " FD_COUNT_LARGE_GIVEN_BUFFER)
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos_fds = __DIAGNOSE_BOS(fds);
+
+    if (!__DIAGNOSE_BOS_FD_COUNT_TRIVIALLY_SAFE(bos_fds, fds, fd_amount)) {
+        return __ppoll_chk(fds, fd_amount, timeout, mask, bos_fds);
+    }
+#endif
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(ppoll)(fds, fd_amount, timeout, mask);
+}
+#endif
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/include/fortify/socket.h b/include/fortify/socket.h
new file mode 100644
index 00000000..f23dbef0
--- /dev/null
+++ b/include/fortify/socket.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _SYS_SOCKET_H
+#error "Never include this file directly; instead, include <sys/socket.h>"
+#endif
+
+#include "fortify.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+ssize_t __sendto_chk(int, const void*, size_t, size_t, int, const struct sockaddr*,
+    socklen_t);
+ssize_t __recvfrom_chk(int, void*, size_t, size_t, int, struct sockaddr*,
+    socklen_t*);
+ssize_t __send_chk(int, const void*, size_t, size_t, int);
+ssize_t __recv_chk(int, void*, size_t, size_t, int);
+
+
+#ifdef __FORTIFY_COMPILATION
+__DIAGNOSE_FORTIFY_INLINE
+ssize_t recvfrom(int fd, void* const buf __DIAGNOSE_PASS_OBJECT_SIZE0, size_t len, int flags,
+    struct sockaddr* src_addr, socklen_t* addr_len)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LT(__DIAGNOSE_BOS0(buf), len),
+    "'recvfrom' " CALLED_WITH_SIZE_BIGGER_BUFFER)
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS0(buf);
+
+    if (!__DIAGNOSE_BOS_TRIVIALLY_GE(bos, len)) {
+        return __recvfrom_chk(fd, buf, len, bos, flags, src_addr, addr_len);
+    }
+#endif
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(recvfrom)(fd, buf, len, flags, src_addr, addr_len);
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+ssize_t sendto(int fd, const void* const buf __DIAGNOSE_PASS_OBJECT_SIZE0, size_t len, int flags,
+    const struct sockaddr* dest_addr, socklen_t addr_len)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LT(__DIAGNOSE_BOS0(buf), len),
+    "'sendto' " CALLED_WITH_SIZE_BIGGER_BUFFER)
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS0(buf);
+
+    if (!__DIAGNOSE_BOS_TRIVIALLY_GE(bos, len)) {
+        return __sendto_chk(fd, buf, len, bos, flags, dest_addr, addr_len);
+    }
+#endif
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(sendto)(fd, buf, len, flags, dest_addr, addr_len);
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+ssize_t recv(int socket, void* const buf __DIAGNOSE_PASS_OBJECT_SIZE0, size_t len, int flags)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LT(__DIAGNOSE_BOS0(buf), len),
+    "'recv' " CALLED_WITH_SIZE_BIGGER_BUFFER)
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS0(buf);
+
+    if (!__DIAGNOSE_BOS_TRIVIALLY_GE(bos, len)) {
+        return __recv_chk(socket, buf, len, bos, flags);
+    }
+#endif
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(recv)(socket, buf, len, flags);
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+ssize_t send(int socket, const void* const buf __DIAGNOSE_PASS_OBJECT_SIZE0, size_t len, int flags)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LT(__DIAGNOSE_BOS0(buf), len),
+    "'send' " CALLED_WITH_SIZE_BIGGER_BUFFER)
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS0(buf);
+
+    if (!__DIAGNOSE_BOS_TRIVIALLY_GE(bos, len)) {
+        return __send_chk(socket, buf, len, bos, flags);
+    }
+#endif
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(send)(socket, buf, len, flags);
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/include/fortify/stat.h b/include/fortify/stat.h
new file mode 100644
index 00000000..bdaee62b
--- /dev/null
+++ b/include/fortify/stat.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _SYS_STAT_H
+#error "Never include this file directly; instead, include <sys/stat.h>"
+#endif
+
+#include "fortify.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+mode_t __umask_chk(mode_t);
+mode_t __umask_real(mode_t mode) __DIAGNOSE_RENAME(umask);
+
+#ifdef __FORTIFY_COMPILATION
+/* Overload of umask. */
+__DIAGNOSE_FORTIFY_INLINE
+mode_t umask(mode_t mode)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ENABLE_IF(1, "")
+__DIAGNOSE_ERROR_IF(mode & ~0777, "'umask' was called in invalid mode")
+{
+#ifdef __FORTIFY_RUNTIME
+    return __umask_chk(mode);
+#else
+    return __umask_real(mode);
+#endif
+}
+#endif
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/include/fortify/stdio.h b/include/fortify/stdio.h
new file mode 100644
index 00000000..1e7de856
--- /dev/null
+++ b/include/fortify/stdio.h
@@ -0,0 +1,136 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _STDIO_H
+#error "Never include this file directly; instead, include <stdio.h>"
+#endif
+
+#include <stdarg.h>
+#include "fortify.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(__FORTIFY_COMPILATION)
+
+#define FORMAT_PLACE_2 (2)
+#define FORMAT_PLACE_3 (3)
+#define VALIST_PLACE_0 (0)
+#define VALIST_PLACE_3 (3)
+#define VALIST_PLACE_4 (4)
+
+size_t __fread_chk(void*, size_t, size_t, FILE*, size_t);
+size_t __fwrite_chk(const void*, size_t, size_t, FILE*, size_t);
+char* __fgets_chk(char*, int, FILE*, size_t);
+
+__DIAGNOSE_FORTIFY_INLINE
+size_t fread(void* const __DIAGNOSE_PASS_OBJECT_SIZE0 buf,
+    size_t size, size_t count, FILE* stream)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNSAFE_CHK_MUL_OVERFLOW(size, count),
+    "in call to 'fread', size * count overflows")
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LT(__DIAGNOSE_BOS0(buf), size * count),
+    "in call to 'fread', size * count is too large for the given buffer")
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS0(buf);
+
+    if (!__DIAGNOSE_BOS_TRIVIALLY_GE_MUL(bos, size, count)) {
+        return __fread_chk(buf, size, count, stream, bos);
+    }
+#endif
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(fread)(buf, size, count, stream);
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+size_t fwrite(const void* const __DIAGNOSE_PASS_OBJECT_SIZE0 buf,
+    size_t size, size_t count, FILE* stream)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNSAFE_CHK_MUL_OVERFLOW(size, count),
+    "in call to 'fwrite', size * count overflows")
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LT(__DIAGNOSE_BOS0(buf), size * count),
+    "in call to 'fwrite', size * count is too large for the given buffer")
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS0(buf);
+
+    if (!__DIAGNOSE_BOS_TRIVIALLY_GE_MUL(bos, size, count)) {
+        return __fwrite_chk(buf, size, count, stream, bos);
+    }
+#endif
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(fwrite)(buf, size, count, stream);
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+char* fgets(char* const __DIAGNOSE_PASS_OBJECT_SIZE dest, int size, FILE* stream)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(size < 0, "in call to 'fgets', size should not be less than 0")
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LT(__DIAGNOSE_BOS(dest), size),
+    "in call to 'fgets', " SIZE_LARGER_THEN_DESTINATION_BUFFER)
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS(dest);
+
+    if (!__DIAGNOSE_BOS_DYNAMIC_CHECK_IMPL_AND(bos, >=, (size_t)size, size >= 0)) {
+        return __fgets_chk(dest, size, stream, bos);
+    }
+#endif
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(fgets)(dest, size, stream);
+}
+
+__DIAGNOSE_FORTIFY_INLINE __DIAGNOSE_PRINTFLIKE(FORMAT_PLACE_3, VALIST_PLACE_0)
+int vsnprintf(char* const __DIAGNOSE_PASS_OBJECT_SIZE dest,
+    size_t size, const char* format, va_list ap)
+__DIAGNOSE_OVERLOAD
+{
+    size_t bos = __DIAGNOSE_BOS(dest);
+    return __builtin___vsnprintf_chk(dest, size, 0, bos, format, ap);
+}
+
+__DIAGNOSE_FORTIFY_INLINE __DIAGNOSE_PRINTFLIKE(FORMAT_PLACE_2, VALIST_PLACE_0)
+int vsprintf(char* const __DIAGNOSE_PASS_OBJECT_SIZE dest, const char* format, va_list ap)
+__DIAGNOSE_OVERLOAD
+{
+    return __builtin___vsprintf_chk(dest, 0, __DIAGNOSE_BOS(dest), format, ap);
+}
+
+__DIAGNOSE_FORTIFY_VARIADIC __DIAGNOSE_PRINTFLIKE(FORMAT_PLACE_2, VALIST_PLACE_3)
+int sprintf(char* const __DIAGNOSE_PASS_OBJECT_SIZE dest, const char* format, ...)
+__DIAGNOSE_OVERLOAD
+{
+    va_list va_l;
+    va_start(va_l, format);
+    int result = __builtin___vsprintf_chk(dest, 0, __DIAGNOSE_BOS(dest), format, va_l);
+    va_end(va_l);
+    return result;
+}
+
+__DIAGNOSE_FORTIFY_VARIADIC __DIAGNOSE_PRINTFLIKE(FORMAT_PLACE_3, VALIST_PLACE_4)
+int snprintf(char* const __DIAGNOSE_PASS_OBJECT_SIZE dest, size_t size, const char* format, ...)
+__DIAGNOSE_OVERLOAD
+{
+    va_list va_l;
+    va_start(va_l, format);
+    int result = __builtin___vsnprintf_chk(dest, size, 0, __DIAGNOSE_BOS(dest), format, va_l);
+    va_end(va_l);
+    return result;
+}
+
+#endif // defined(__FORTIFY_COMPILATION)
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/include/fortify/stdlib.h b/include/fortify/stdlib.h
new file mode 100644
index 00000000..a0d3b467
--- /dev/null
+++ b/include/fortify/stdlib.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _STDLIB_H
+#error "Never include this file directly; instead, include <stdlib.h>"
+#endif
+
+#include "fortify.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(_GNU_SOURCE) && defined(__FORTIFY_COMPILATION)
+char* realpath(const char* path, char* resolved)
+__DIAGNOSE_ERROR_IF(!path, "'realpath': NULL path is never correct; flipped arguments?")
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LT(__DIAGNOSE_BOS(resolved), FORTIFY_PATH_MAX),
+    "'realpath' " OUTPUT_PARAMETER_BYTES);
+#endif
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/include/fortify/string.h b/include/fortify/string.h
new file mode 100644
index 00000000..00846b8e
--- /dev/null
+++ b/include/fortify/string.h
@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _STRING_H
+#error "Never include this file directly; instead, include <string.h>"
+#endif
+
+#include "fortify.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void *__memchr_chk(const void* s, int c, size_t n, size_t actual_size);
+void *__memrchr_chk(const void*, int, size_t, size_t);
+size_t __strlcpy_chk(char*, const char*, size_t, size_t);
+size_t __strlcat_chk(char*, const char*, size_t, size_t);
+char *__strchr_chk(const char* p, int ch, size_t s_len);
+char *__strrchr_chk(const char *p, int ch, size_t s_len);
+size_t __strlen_chk(const char* s, size_t s_len);
+
+#ifdef __FORTIFY_COMPILATION
+__DIAGNOSE_FORTIFY_INLINE
+char *strcpy(char *const dest __DIAGNOSE_PASS_OBJECT_SIZE, const char *src)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LE(__DIAGNOSE_BOS(dest), __builtin_strlen(src)),
+    "'strcpy' " CALLED_WITH_STRING_BIGGER_BUFFER)
+{
+#ifdef __FORTIFY_RUNTIME
+    return __builtin___strcpy_chk(dest, src, __DIAGNOSE_BOS(dest));
+#else
+    return __builtin_strcpy(dest, src);
+#endif
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+char *stpcpy(char *const dest __DIAGNOSE_PASS_OBJECT_SIZE, const char *src)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LE(__DIAGNOSE_BOS(dest), __builtin_strlen(src)),
+    "'stpcpy' " CALLED_WITH_STRING_BIGGER_BUFFER)
+{
+#ifdef __FORTIFY_RUNTIME
+    return __builtin___stpcpy_chk(dest, src, __DIAGNOSE_BOS(dest));
+#else
+    return __builtin_stpcpy(dest, src);
+#endif
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+void *memmove(void *const dest __DIAGNOSE_PASS_OBJECT_SIZE0, const void *src, size_t len)
+__DIAGNOSE_OVERLOAD
+{
+#ifdef __FORTIFY_RUNTIME
+    return __builtin___memmove_chk(dest, src, len, __DIAGNOSE_BOS(dest));
+#else
+    return __builtin_memmove(dest, src, len);
+#endif
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+void *mempcpy(void *const dest __DIAGNOSE_PASS_OBJECT_SIZE, const void *src, size_t copy_amount)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LT(__DIAGNOSE_BOS0(dest), copy_amount),
+    "'mempcpy' " CALLED_WITH_STRING_BIGGER_BUFFER)
+{
+#ifdef __FORTIFY_RUNTIME
+    return __builtin___mempcpy_chk(dest, src, copy_amount, __DIAGNOSE_BOS0(dest));
+#else
+    return __builtin_mempcpy(dest, src, copy_amount);
+#endif
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+char *strcat(char *const dest __DIAGNOSE_PASS_OBJECT_SIZE, const char *src)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LE(__DIAGNOSE_BOS(dest), __builtin_strlen(src)),
+    "'strcat' " CALLED_WITH_STRING_BIGGER_BUFFER)
+{
+#ifdef __FORTIFY_RUNTIME
+    return __builtin___strcat_chk(dest, src, __DIAGNOSE_BOS(dest));
+#else
+    return __builtin_strcat(dest, src);
+#endif
+}
+
+#ifdef __FORTIFY_RUNTIME
+__DIAGNOSE_FORTIFY_INLINE
+char *strncat(char* const dest __DIAGNOSE_PASS_OBJECT_SIZE, const char* src, size_t n)
+__DIAGNOSE_OVERLOAD
+{
+    return __builtin___strncat_chk(dest, src, n, __DIAGNOSE_BOS(dest));
+}
+#endif
+
+#ifdef __FORTIFY_RUNTIME
+__DIAGNOSE_FORTIFY_INLINE
+char *stpncpy(char *const dest __DIAGNOSE_PASS_OBJECT_SIZE,
+    const char *const src __DIAGNOSE_PASS_OBJECT_SIZE, size_t n)
+__DIAGNOSE_OVERLOAD
+{
+    size_t bos_dest = __DIAGNOSE_BOS(dest);
+    return __builtin___stpncpy_chk(dest, src, n, bos_dest);
+}
+#endif
+
+#ifdef __FORTIFY_RUNTIME
+__DIAGNOSE_FORTIFY_INLINE
+char *strncpy(char *const dest __DIAGNOSE_PASS_OBJECT_SIZE,
+    const char *const src __DIAGNOSE_PASS_OBJECT_SIZE, size_t n)
+__DIAGNOSE_OVERLOAD
+{
+    size_t bos_dest = __DIAGNOSE_BOS(dest);
+    return __builtin___strncpy_chk(dest, src, n, bos_dest);
+}
+#endif
+
+#ifdef __FORTIFY_RUNTIME
+__DIAGNOSE_FORTIFY_INLINE
+void *memcpy(void *const dest __DIAGNOSE_PASS_OBJECT_SIZE0, const void *src, size_t copy_amount)
+__DIAGNOSE_OVERLOAD
+{
+    return __builtin___memcpy_chk(dest, src, copy_amount, __DIAGNOSE_BOS0(dest));
+}
+#endif
+
+#if defined(_BSD_SOURCE) || defined(_GNU_SOURCE)
+__DIAGNOSE_FORTIFY_INLINE
+size_t strlcpy(char *const dest __DIAGNOSE_PASS_OBJECT_SIZE, const char *src, size_t size)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LT(__DIAGNOSE_BOS(dest), size),
+    "'strlcpy' called with size bigger than buffer")
+{
+#ifdef __FORTIFY_RUNTIME
+    return __strlcpy_chk(dest, src, size, __DIAGNOSE_BOS(dest));
+#else
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(strlcpy)(dest, src, size);
+#endif
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+size_t strlcat(char* const dest __DIAGNOSE_PASS_OBJECT_SIZE, const char* src, size_t size)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LT(__DIAGNOSE_BOS(dest), size),
+    "'strlcat' called with size bigger than buffer")
+{
+#ifdef __FORTIFY_RUNTIME
+    return __strlcat_chk(dest, src, size, __DIAGNOSE_BOS(dest));
+#else
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(strlcat)(dest, src, size);
+#endif
+}
+#endif // defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+
+__DIAGNOSE_FORTIFY_INLINE
+void *memset(void *const s __DIAGNOSE_PASS_OBJECT_SIZE0, int c, size_t n)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_WARNING_IF(c && !n, "'memset' will set 0 bytes; maybe the arguments got flipped?")
+{
+#ifdef __FORTIFY_RUNTIME
+    return __builtin___memset_chk(s, c, n, __DIAGNOSE_BOS0(s));
+#else
+    return __builtin_memset(s, c, n);
+#endif
+}
+
+#ifdef __FORTIFY_RUNTIME
+__DIAGNOSE_FORTIFY_INLINE
+void *memchr(const void *const s __DIAGNOSE_PASS_OBJECT_SIZE, int c, size_t n)
+__DIAGNOSE_OVERLOAD
+{
+    size_t bos = __DIAGNOSE_BOS(s);
+    if (__DIAGNOSE_BOS_TRIVIALLY_GE(bos, n)) {
+        return __builtin_memchr(s, c, n);
+    }
+    return __memchr_chk(s, c, n, bos);
+}
+#endif // memchr __FORTIFY_RUNTIME
+
+extern void* __memrchr_real(const void*, int, size_t) __DIAGNOSE_RENAME(memrchr);
+
+#ifdef __FORTIFY_RUNTIME
+__DIAGNOSE_FORTIFY_INLINE
+void *memrchr(const void *const __DIAGNOSE_PASS_OBJECT_SIZE s, int c, size_t n)
+__DIAGNOSE_OVERLOAD
+{
+    size_t bos = __DIAGNOSE_BOS(s);
+    if (__DIAGNOSE_BOS_TRIVIALLY_GE(bos, n)) {
+        return __memrchr_real(s, c, n);
+    }
+    return __memrchr_chk(s, c, n, bos);
+}
+#endif
+
+__DIAGNOSE_FORTIFY_INLINE
+char* strchr(const char* const s __DIAGNOSE_PASS_OBJECT_SIZE, int c)
+__DIAGNOSE_OVERLOAD
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS(s);
+
+    if (bos != __DIAGNOSE_FORTIFY_UNKNOWN_SIZE) {
+        return __strchr_chk(s, c, bos);
+    }
+#endif
+    return __builtin_strchr(s, c);
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+char* strrchr(const char* const s __DIAGNOSE_PASS_OBJECT_SIZE, int c)
+__DIAGNOSE_OVERLOAD
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS(s);
+
+    if (bos != __DIAGNOSE_FORTIFY_UNKNOWN_SIZE) {
+        return __strrchr_chk(s, c, bos);
+    }
+#endif
+    return __builtin_strrchr(s, c);
+}
+
+#ifdef __FORTIFY_RUNTIME
+__DIAGNOSE_FORTIFY_INLINE
+size_t strlen(const char* const s __DIAGNOSE_PASS_OBJECT_SIZE0)
+__DIAGNOSE_OVERLOAD
+{
+    return __strlen_chk(s, __DIAGNOSE_BOS0(s));
+}
+#endif
+
+#endif // __FORTIFY_COMPILATION
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/include/fortify/unistd.h b/include/fortify/unistd.h
new file mode 100644
index 00000000..39d0a5b8
--- /dev/null
+++ b/include/fortify/unistd.h
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _UNISTD_H
+#error "Never include this file directly; instead, include <unistd.h>"
+#endif
+
+#include "fortify.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if defined(__FORTIFY_COMPILATION)
+
+#define __DIAGNOSE_ERROR_IF_OVERFLOWS_SSIZET(what, fn) \
+    __DIAGNOSE_ERROR_IF((what) > FORTIFY_SSIZE_MAX, "in call to '" #fn "', '" #what "' must be <= FORTIFY_SSIZE_MAX")
+
+#define __DIAGNOSE_ERROR_IF_OVERFLOWS_OBJECTSIZE(what, objsize, fn) \
+    __DIAGNOSE_ERROR_IF(__DIAGNOSE_UNEVALUATED_LT((objsize), (what)), \
+    "in call to '" #fn "', '" #what "' bytes overflows the given object")
+
+#define __DIAGNOSE_BOS_TRIVIALLY_GE_NO_OVERFLOW(bos_val, index)  \
+    ((__DIAGNOSE_BOS_DYNAMIC_CHECK_IMPL_AND((bos_val), >=, (index), (bos_val) <= (FORTIFY_SSIZE_MAX)) && \
+    __builtin_constant_p(index) && (index) <= (FORTIFY_SSIZE_MAX)))
+
+char* __getcwd_chk(char*, size_t, size_t) ;
+
+ssize_t __pread_chk(int, void*, size_t, off_t, size_t);
+ssize_t __pread_real(int, void*, size_t, off_t) __DIAGNOSE_RENAME(pread);
+
+ssize_t __pwrite_chk(int, const void*, size_t, off_t, size_t);
+ssize_t __pwrite_real(int, const void*, size_t, off_t) __DIAGNOSE_RENAME(pwrite);
+
+ssize_t __read_chk(int, void*, size_t, size_t);
+ssize_t __write_chk(int, const void*, size_t, size_t);
+
+ssize_t __readlink_chk(const char*, char*, size_t, size_t);
+ssize_t __readlinkat_chk(int dirfd, const char*, char*, size_t, size_t);
+
+#define __DIAGNOSE_PREAD_PREFIX(x) __pread_ ## x
+#define __DIAGNOSE_PWRITE_PREFIX(x) __pwrite_ ## x
+
+__DIAGNOSE_FORTIFY_INLINE
+char* getcwd(char* const __DIAGNOSE_PASS_OBJECT_SIZE buf, size_t size)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF_OVERFLOWS_OBJECTSIZE(size, __DIAGNOSE_BOS(buf), getcwd)
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS(buf);
+
+    if (!__DIAGNOSE_BOS_TRIVIALLY_GE(bos, size)) {
+        return __getcwd_chk(buf, size, bos);
+    }
+#endif
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(getcwd)(buf, size);
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+ssize_t pread(int fd, void* const __DIAGNOSE_PASS_OBJECT_SIZE0 buf, size_t count, off_t offset)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF_OVERFLOWS_SSIZET(count, pread)
+__DIAGNOSE_ERROR_IF_OVERFLOWS_OBJECTSIZE(count, __DIAGNOSE_BOS0(buf), pread)
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS0(buf);
+
+    if (!__DIAGNOSE_BOS_TRIVIALLY_GE_NO_OVERFLOW(bos, count)) {
+        return __DIAGNOSE_PREAD_PREFIX(chk)(fd, buf, count, offset, bos);
+    }
+#endif
+    return __DIAGNOSE_PREAD_PREFIX(real)(fd, buf, count, offset);
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+ssize_t pwrite(int fd, const void* const __DIAGNOSE_PASS_OBJECT_SIZE0 buf, size_t count, off_t offset)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF_OVERFLOWS_SSIZET(count, pwrite)
+__DIAGNOSE_ERROR_IF_OVERFLOWS_OBJECTSIZE(count, __DIAGNOSE_BOS0(buf), pwrite)
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS0(buf);
+
+    if (!__DIAGNOSE_BOS_TRIVIALLY_GE_NO_OVERFLOW(bos, count)) {
+        return __DIAGNOSE_PWRITE_PREFIX(chk)(fd, buf, count, offset, bos);
+    }
+#endif
+    return __DIAGNOSE_PWRITE_PREFIX(real)(fd, buf, count, offset);
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+ssize_t read(int fd, void* const __DIAGNOSE_PASS_OBJECT_SIZE0 buf, size_t count)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF_OVERFLOWS_SSIZET(count, read)
+__DIAGNOSE_ERROR_IF_OVERFLOWS_OBJECTSIZE(count, __DIAGNOSE_BOS0(buf), read)
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS0(buf);
+
+    if (!__DIAGNOSE_BOS_TRIVIALLY_GE_NO_OVERFLOW(bos, count)) {
+        return __read_chk(fd, buf, count, bos);
+    }
+#endif
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(read)(fd, buf, count);
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+ssize_t write(int fd, const void* const __DIAGNOSE_PASS_OBJECT_SIZE0 buf, size_t count)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF_OVERFLOWS_SSIZET(count, write)
+__DIAGNOSE_ERROR_IF_OVERFLOWS_OBJECTSIZE(count, __DIAGNOSE_BOS0(buf), write)
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS0(buf);
+
+    if (!__DIAGNOSE_BOS_TRIVIALLY_GE_NO_OVERFLOW(bos, count)) {
+        return __write_chk(fd, buf, count, bos);
+    }
+#endif
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(write)(fd, buf, count);
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+ssize_t readlink(const char* path, char* const __DIAGNOSE_PASS_OBJECT_SIZE buf, size_t size)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF_OVERFLOWS_SSIZET(size, readlink)
+__DIAGNOSE_ERROR_IF_OVERFLOWS_OBJECTSIZE(size, __DIAGNOSE_BOS(buf), readlink)
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS(buf);
+
+    if (!__DIAGNOSE_BOS_TRIVIALLY_GE_NO_OVERFLOW(bos, size)) {
+        return __readlink_chk(path, buf, size, bos);
+    }
+#endif
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(readlink)(path, buf, size);
+}
+
+__DIAGNOSE_FORTIFY_INLINE
+ssize_t readlinkat(int dirfd, const char* path, char* const __DIAGNOSE_PASS_OBJECT_SIZE buf, size_t size)
+__DIAGNOSE_OVERLOAD
+__DIAGNOSE_ERROR_IF_OVERFLOWS_SSIZET(size, readlinkat)
+__DIAGNOSE_ERROR_IF_OVERFLOWS_OBJECTSIZE(size, __DIAGNOSE_BOS(buf), readlinkat)
+{
+#ifdef __FORTIFY_RUNTIME
+    size_t bos = __DIAGNOSE_BOS(buf);
+
+    if (!__DIAGNOSE_BOS_TRIVIALLY_GE_NO_OVERFLOW(bos, size)) {
+        return __readlinkat_chk(dirfd, path, buf, size, bos);
+    }
+#endif
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(readlinkat)(dirfd, path, buf, size);
+}
+
+#endif // defined(__FORTIFY_COMPILATION)
+
+#ifdef __cplusplus
+}
+#endif
\ No newline at end of file
diff --git a/include/info/application_target_sdk_version.h b/include/info/application_target_sdk_version.h
new file mode 100644
index 00000000..1d727afb
--- /dev/null
+++ b/include/info/application_target_sdk_version.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INFO_APPLICATION_TARGET_SDK_VERSION_H
+#define _INFO_APPLICATION_TARGET_SDK_VERSION_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define SDK_VERSION_FUTURE 9999
+#define SDK_VERSION_7 7
+#define SDK_VERSION_8 8
+#define SDK_VERSION_9 9
+
+/**
+  * @brief Get the target sdk version number of the application.
+  * @return The target sdk version number.
+  */
+int get_application_target_sdk_version(void);
+
+/**
+  * @brief Set the target sdk version number of the application.
+  * @param target The target sdk version number.
+  */
+void set_application_target_sdk_version(int target);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _INFO_APPLICATION_TARGET_SDK_VERSION_H
diff --git a/include/info/device_api_version.h b/include/info/device_api_version.h
new file mode 100644
index 00000000..d08dbc87
--- /dev/null
+++ b/include/info/device_api_version.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INFO_DEVICE_API_VERSION_H
+#define _INFO_DEVICE_API_VERSION_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+  * @brief Get the api version number of the device.
+  * @return The api version number of the device.
+  */
+int get_device_api_version(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _INFO_DEVICE_API_VERSION_H
diff --git a/include/info/fatal_message.h b/include/info/fatal_message.h
new file mode 100644
index 00000000..1c25c8e1
--- /dev/null
+++ b/include/info/fatal_message.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INFO_FATAL_MESSAGE_H
+#define _INFO_FATAL_MESSAGE_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct fatal_msg {
+    size_t size;
+    char msg[0];
+} fatal_msg_t;
+
+/**
+  * @brief Set up fatal message
+  * @param msg The fatal message
+  */
+void set_fatal_message(const char *msg);
+
+/**
+  * @brief Get the set fatal message
+  * @return Address of fatal message
+  */
+fatal_msg_t *get_fatal_message(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // _INFO_FATAL_MESSAGE_H
diff --git a/include/langinfo.h b/include/langinfo.h
index 519c0612..436f19a2 100644
--- a/include/langinfo.h
+++ b/include/langinfo.h
@@ -1,3 +1,18 @@
+/**
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #ifndef _LANGINFO_H
 #define _LANGINFO_H
 
@@ -68,6 +83,9 @@ extern "C" {
 #define ERA_D_T_FMT 0x20030
 #define ERA_T_FMT 0x20031
 
+#define AM_STR_LOWER 0x20032
+#define PM_STR_LOWER 0x20033
+
 #define CODESET 14
 
 #define CRNCYSTR 0x4000F
diff --git a/include/locale.h b/include/locale.h
index 11106fea..36b72206 100644
--- a/include/locale.h
+++ b/include/locale.h
@@ -1,3 +1,18 @@
+/**
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #ifndef	_LOCALE_H
 #define	_LOCALE_H
 
@@ -21,41 +36,45 @@ extern "C" {
 #define LC_COLLATE  3
 #define LC_MONETARY 4
 #define LC_MESSAGES 5
-#define LC_ALL      6
+#define LC_PAPER    6
+#define LC_NAME     7
+#define LC_ADDRESS  8
+#define LC_TELEPHONE 9
+#define LC_MEASUREMENT 10
+#define LC_IDENTIFICATION 11
+#define LC_ALL      12
 
 struct lconv {
-	char *decimal_point;
-	char *thousands_sep;
-	char *grouping;
-
-	char *int_curr_symbol;
-	char *currency_symbol;
-	char *mon_decimal_point;
-	char *mon_thousands_sep;
-	char *mon_grouping;
-	char *positive_sign;
-	char *negative_sign;
-	char int_frac_digits;
-	char frac_digits;
-	char p_cs_precedes;
-	char p_sep_by_space;
-	char n_cs_precedes;
-	char n_sep_by_space;
-	char p_sign_posn;
-	char n_sign_posn;
-	char int_p_cs_precedes;
-	char int_p_sep_by_space;
-	char int_n_cs_precedes;
-	char int_n_sep_by_space;
-	char int_p_sign_posn;
-	char int_n_sign_posn;
+    char *decimal_point;
+    char *thousands_sep;
+    char *grouping;
+
+    char *int_curr_symbol;
+    char *currency_symbol;
+    char *mon_decimal_point;
+    char *mon_thousands_sep;
+    char *mon_grouping;
+    char *positive_sign;
+    char *negative_sign;
+    char int_frac_digits;
+    char frac_digits;
+    char p_cs_precedes;
+    char p_sep_by_space;
+    char n_cs_precedes;
+    char n_sep_by_space;
+    char p_sign_posn;
+    char n_sign_posn;
+    char int_p_cs_precedes;
+    char int_p_sep_by_space;
+    char int_n_cs_precedes;
+    char int_n_sep_by_space;
+    char int_p_sign_posn;
+    char int_n_sign_posn;
 };
 
-
 char *setlocale (int, const char *);
 struct lconv *localeconv(void);
 
-
 #if defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE) \
  || defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
 
@@ -71,6 +90,12 @@ struct lconv *localeconv(void);
 #define LC_COLLATE_MASK  (1<<LC_COLLATE)
 #define LC_MONETARY_MASK (1<<LC_MONETARY)
 #define LC_MESSAGES_MASK (1<<LC_MESSAGES)
+#define LC_PAPER_MASK    (1<<LC_PAPER)
+#define LC_NAME_MASK     (1<<LC_NAME)
+#define LC_ADDRESS_MASK  (1<<LC_ADDRESS)
+#define LC_TELEPHONE_MASK (1<<LC_TELEPHONE)
+#define LC_MEASUREMENT_MASK (1<<LC_MEASUREMENT)
+#define LC_IDENTIFICATION_MASK (1<<LC_IDENTIFICATION)
 #define LC_ALL_MASK      0x7fffffff
 
 locale_t duplocale(locale_t);
@@ -79,10 +104,7 @@ locale_t newlocale(int, const char *, locale_t);
 locale_t uselocale(locale_t);
 
 #endif
-
-
 #ifdef __cplusplus
 }
 #endif
-
 #endif
diff --git a/include/malloc.h b/include/malloc.h
index f771196a..d3491885 100644
--- a/include/malloc.h
+++ b/include/malloc.h
@@ -1,11 +1,15 @@
 #ifndef _MALLOC_H
 #define _MALLOC_H
 
+#include <stdio.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 #define __NEED_size_t
+#define __NEED_ssize_t
+#define __NEED_uintptr_t
 
 #include <bits/alltypes.h>
 
@@ -38,6 +42,27 @@ struct mallinfo2 { __MALLINFO_BODY };
 
 struct mallinfo2 mallinfo2(void);
 
+int malloc_iterate(void* base, size_t size, void (*callback)(void* base, size_t size, void* arg), void* arg);
+void malloc_disable(void);
+void malloc_enable(void);
+
+int malloc_info(int options, FILE* fp);
+void malloc_stats_print(void (*write_cb) (void *, const char *), void *cbopaque, const char *opts);
+
+
+#define M_SET_THREAD_CACHE -1001
+#define M_THREAD_CACHE_ENABLE 1
+#define M_THREAD_CACHE_DISABLE 0
+
+#define M_FLUSH_THREAD_CACHE -1002
+
+#define M_DELAYED_FREE -1003
+#define M_DELAYED_FREE_ENABLE 1
+#define M_DELAYED_FREE_DISABLE 0
+
+int mallopt(int param, int value);
+ssize_t malloc_backtrace(void* pointer, uintptr_t* frames, size_t frame_count);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/poll.h b/include/poll.h
index 472e4b84..b7df3dba 100644
--- a/include/poll.h
+++ b/include/poll.h
@@ -50,6 +50,8 @@ __REDIR(ppoll, __ppoll_time64);
 #endif
 #endif
 
+#include <fortify/poll.h>
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/pthread.h b/include/pthread.h
index 89fd9ff7..8a2478e1 100644
--- a/include/pthread.h
+++ b/include/pthread.h
@@ -1,3 +1,18 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #ifndef _PTHREAD_H
 #define _PTHREAD_H
 #ifdef __cplusplus
@@ -6,6 +21,17 @@ extern "C" {
 
 #include <features.h>
 
+/* Musl did not provide the "owner" macro directly,
+ * so users can not access the mutex-ower-ID.
+ * Thus we added this macro for getting the owner-ID
+ * of the mutex. */
+
+/* These macros provides macros for accessing inner
+ * attributes of the pthread_mutex_t struct.
+ * It is intended for solving the coompiling failure
+ * of Dopra codes which claims that .__data.* realm
+ * can not be found in pthread_mutex_t. */
+
 #define __NEED_time_t
 #define __NEED_clockid_t
 #define __NEED_struct_timespec
@@ -81,6 +107,7 @@ int pthread_create(pthread_t *__restrict, const pthread_attr_t *__restrict, void
 int pthread_detach(pthread_t);
 _Noreturn void pthread_exit(void *);
 int pthread_join(pthread_t, void **);
+pid_t pthread_gettid_np(pthread_t);
 
 #ifdef __GNUC__
 __attribute__((const))
@@ -110,6 +137,49 @@ int pthread_mutex_trylock(pthread_mutex_t *);
 int pthread_mutex_timedlock(pthread_mutex_t *__restrict, const struct timespec *__restrict);
 int pthread_mutex_destroy(pthread_mutex_t *);
 int pthread_mutex_consistent(pthread_mutex_t *);
+/**
+  * @brief lock the mutex object referenced by mutex. If the mutex is already locked,
+  *        the calling thread shall block until the mutex becomes available as in the
+  *        pthread_mutex_lock() function. If the mutex cannot be locked without waiting for
+  *        another thread to unlock the mutex, this wait shall be terminated when the specified
+  *        timeout expires. The timeout shall be based on the CLOCK_REALTIME or CLOCK_MONOTONIC clock.
+  *        The resolution of the timeout shall be the resolution of the clock on which it is based.
+  * @param mutex a robust mutex and the process containing the owning thread terminated while holding the mutex lock.
+  * @param clock_id specified CLOCK_REALTIME or CLOCK_MONOTONIC clock.
+  * @param timespec the timeout shall expire specified by abstime passes.
+  * @return clocklock result.
+  * @retval 0 is returned on success.
+  * @retval -1 is returned on failure, and errno is set to indicate the error.
+  */
+int pthread_mutex_clocklock(pthread_mutex_t *__restrict, clockid_t, const struct timespec *__restrict);
+/**
+  * @brief lock the mutex object referenced by mutex. If the mutex is already locked,
+  *        the calling thread shall block until the mutex becomes available as in the
+  *        pthread_mutex_lock() function. If the mutex cannot be locked without waiting for
+  *        another thread to unlock the mutex, this wait shall be terminated when the specified
+  *        timeout expires. The timeout shall be based on the CLOCK_MONOTONIC clock.
+  *        The resolution of the timeout shall be the resolution of the clock on which it is based.
+  * @param mutex a robust mutex and the process containing the owning thread terminated while holding the mutex lock.
+  * @param timespec the timeout shall expire specified by abstime passes.
+  * @return clocklock result.
+  * @retval 0 is returned on success.
+  * @retval -1 is returned on failure, and errno is set to indicate the error.
+  */
+int pthread_mutex_timedlock_monotonic_np(pthread_mutex_t *__restrict, const struct timespec *__restrict);
+/**
+  * @brief lock the mutex object referenced by mutex. If the mutex is already locked,
+  *        the calling thread shall block until the mutex becomes available as in the
+  *        pthread_mutex_lock() function. If the mutex cannot be locked without waiting for
+  *        another thread to unlock the mutex, this wait shall be terminated when the specified
+  *        timeout expires. The timeout shall be based on the CLOCK_MONOTONIC clock.
+  *        The resolution of the timeout shall be the resolution of the clock on which it is based.
+  * @param mutex a robust mutex and the process containing the owning thread terminated while holding the mutex lock.
+  * @param ms the timeout shall expire specified by relative time(ms) passes.
+  * @return clocklock result.
+  * @retval 0 is returned on success.
+  * @retval -1 is returned on failure, and errno is set to indicate the error.
+  */
+int pthread_mutex_lock_timeout_np(pthread_mutex_t *__restrict, unsigned int);
 
 int pthread_mutex_getprioceiling(const pthread_mutex_t *__restrict, int *__restrict);
 int pthread_mutex_setprioceiling(pthread_mutex_t *__restrict, int, int *__restrict);
@@ -118,6 +188,49 @@ int pthread_cond_init(pthread_cond_t *__restrict, const pthread_condattr_t *__re
 int pthread_cond_destroy(pthread_cond_t *);
 int pthread_cond_wait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict);
 int pthread_cond_timedwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict, const struct timespec *__restrict);
+/**
+  * @brief The thread waits for a signal to trigger, and if timeout or signal is triggered,
+  *        the thread wakes up.
+  * @param pthread_cond_t Condition variables for multithreading.
+  * @param pthread_mutex_t Thread mutex variable.
+  * @param clockid_t Clock ID used in clock and timer functions.
+  * @param timespec The timeout shall expire specified by abstime passes.
+  * @return pthread_cond_clockwait result.
+  * @retval 0 pthread_cond_clockwait successful.
+  * @retval ETIMEDOUT pthread_cond_clockwait Connection timed out.
+  * @retval EINVAL pthread_cond_clockwait error.
+  */
+int pthread_cond_clockwait(pthread_cond_t *__restrict, pthread_mutex_t *__restrict,
+                           clockid_t, const struct timespec *__restrict);
+
+/**
+  * @brief Condition variables have an initialization option to use CLOCK_MONOTONIC.
+  *        The thread waits for a signal to trigger, and if timeout or signal is triggered,
+  *        the thread wakes up.
+  * @param pthread_cond_t Condition variables for multithreading.
+  * @param pthread_mutex_t Thread mutex variable.
+  * @param timespec The timeout shall expire specified by abstime passes.
+  * @return pthread_cond_timedwait_monotonic_np result.
+  * @retval 0 pthread_cond_timedwait_monotonic_np successful.
+  * @retval ETIMEDOUT pthread_cond_timedwait_monotonic_np Connection timed out.
+  * @retval EINVAL pthread_cond_timedwait_monotonic_np error.
+  */
+int pthread_cond_timedwait_monotonic_np(pthread_cond_t *__restrict, pthread_mutex_t *__restrict,
+                                        const struct timespec *__restrict);
+
+/**
+  * @brief Condition variables have an initialization option to use CLOCK_MONOTONIC and The time
+  *        parameter is in milliseconds. The thread waits for a signal to trigger, and if timeout or
+  *        signal is triggered, the thread wakes up.
+  * @param pthread_cond_t Condition variables for multithreading.
+  * @param pthread_mutex_t Thread mutex variable.
+  * @param unsigned Timeout, in milliseconds.
+  * @return pthread_cond_timeout_np result.
+  * @retval 0 pthread_cond_timeout_np successful.
+  * @retval ETIMEDOUT pthread_cond_timeout_np Connection timed out.
+  * @retval EINVAL pthread_cond_timeout_np error.
+  */
+int pthread_cond_timeout_np(pthread_cond_t* __restrict, pthread_mutex_t* __restrict, unsigned int);
 int pthread_cond_broadcast(pthread_cond_t *);
 int pthread_cond_signal(pthread_cond_t *);
 
@@ -126,10 +239,74 @@ int pthread_rwlock_destroy(pthread_rwlock_t *);
 int pthread_rwlock_rdlock(pthread_rwlock_t *);
 int pthread_rwlock_tryrdlock(pthread_rwlock_t *);
 int pthread_rwlock_timedrdlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict);
+/**
+  * @brief Apply a read lock to the read-write lock referenced by rwlock as in the
+  *        pthread_rwlock_rdlock() function. However, if the lock cannot be acquired without
+  *        waiting for other threads to unlock the lock, this wait shall be terminated when
+  *        the specified timeout expires. The timeout shall expire when the absolute time specified by
+  *        abstime passes, as measured by the clock on which timeouts are based, or if the absolute time
+  *        specified by abstime has already been passed at the time of the call.
+  *        The timeout shall be based on the CLOCK_REALTIME or CLOCK_MONOTONIC clock.
+  * @param rw a read lock to the read-write lock referenced.
+  * @param clock_id specified CLOCK_REALTIME or CLOCK_MONOTONIC clock.
+  * @param timespec the timeout shall expire specified by abstime passes.
+  * @return clockrdlock result.
+  * @retval 0 is returned on success.
+  * @retval -1 is returned on failure, and errno is set to indicate the error.
+  */
+int pthread_rwlock_clockrdlock(pthread_rwlock_t *__restrict, clockid_t, const struct timespec *__restrict);
+/**
+  * @brief Apply a read lock to the read-write lock referenced by rwlock as in the
+  *        pthread_rwlock_rdlock() function. However, if the lock cannot be acquired without
+  *        waiting for other threads to unlock the lock, this wait shall be terminated when
+  *        the specified timeout expires. The timeout shall expire when the absolute time specified by
+  *        abstime passes, as measured by the clock on which timeouts are based, or if the absolute time
+  *        specified by abstime has already been passed at the time of the call.
+  *        The timeout shall be based on the CLOCK_MONOTONIC clock.
+  * @param rw a read lock to the read-write lock referenced.
+  * @param timespec the timeout shall expire specified by abstime passes.
+  * @return clockrdlock result.
+  * @retval 0 is returned on success.
+  * @retval -1 is returned on failure, and errno is set to indicate the error.
+  */
+int pthread_rwlock_timedrdlock_monotonic_np(pthread_rwlock_t *__restrict, const struct timespec *__restrict);
 int pthread_rwlock_wrlock(pthread_rwlock_t *);
 int pthread_rwlock_trywrlock(pthread_rwlock_t *);
 int pthread_rwlock_timedwrlock(pthread_rwlock_t *__restrict, const struct timespec *__restrict);
 int pthread_rwlock_unlock(pthread_rwlock_t *);
+/**
+  * @brief Read-write lock variables have an initialization option to use CLOCK_MONOTONIC.
+  *        apply a read lock to the read-write lock referenced by rwlock as in the
+  *        pthread_rwlock_wrlock() function. However, if the lock cannot be acquired without
+  *        waiting for other threads to unlock the lock, this wait shall be terminated when
+  *        the specified timeout expires. The timeout shall expire when the absolute time specified by
+  *        abstime passes, as measured by the clock on which timeouts are based, or if the absolute time
+  *        specified by abstime has already been passed at the time of the call.
+  *        The timeout shall be based on the CLOCK_MONOTONIC clock.
+  * @param rw a read lock to the read-write lock referenced.
+  * @param timespec the timeout shall expire specified by abstime passes.
+  * @return clockrdlock result.
+  * @retval 0 is returned on success.
+  * @retval -1 is returned on failure, and errno is set to indicate the error.
+  */
+int pthread_rwlock_timedwrlock_monotonic_np(pthread_rwlock_t *__restrict, const struct timespec *__restrict);
+
+/**
+  * @brief Apply a read lock to the read-write lock referenced by rwlock as in the
+  *        pthread_rwlock_wrlock() function. However, if the lock cannot be acquired without
+  *        waiting for other threads to unlock the lock, this wait shall be terminated when
+  *        the specified timeout expires. The timeout shall expire when the absolute time specified by
+  *        abstime passes, as measured by the clock on which timeouts are based, or if the absolute time
+  *        specified by abstime has already been passed at the time of the call.
+  *        The timeout shall be based on the CLOCK_REALTIME or CLOCK_MONOTONIC clock.
+  * @param rw a read lock to the read-write lock referenced.
+  * @param clock_id specified CLOCK_REALTIME or CLOCK_MONOTONIC clock.
+  * @param timespec the timeout shall expire specified by abstime passes.
+  * @return clockrdlock result.
+  * @retval 0 is returned on success.
+  * @retval -1 is returned on failure, and errno is set to indicate the error.
+  */
+int pthread_rwlock_clockwrlock(pthread_rwlock_t *__restrict, clockid_t, const struct timespec *__restrict);
 
 int pthread_spin_init(pthread_spinlock_t *, int);
 int pthread_spin_destroy(pthread_spinlock_t *);
diff --git a/include/sched.h b/include/sched.h
index fda4b484..a11fe2cf 100644
--- a/include/sched.h
+++ b/include/sched.h
@@ -1,148 +1,153 @@
-#ifndef _SCHED_H
-#define _SCHED_H
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <features.h>
-
-#define __NEED_struct_timespec
-#define __NEED_pid_t
-#define __NEED_time_t
-
-#ifdef _GNU_SOURCE
-#define __NEED_size_t
-#endif
-
-#include <bits/alltypes.h>
-
-struct sched_param {
-	int sched_priority;
-	int __reserved1;
-#if _REDIR_TIME64
-	long __reserved2[4];
-#else
-	struct {
-		time_t __reserved1;
-		long __reserved2;
-	} __reserved2[2];
-#endif
-	int __reserved3;
-};
-
-int    sched_get_priority_max(int);
-int    sched_get_priority_min(int);
-int    sched_getparam(pid_t, struct sched_param *);
-int    sched_getscheduler(pid_t);
-int    sched_rr_get_interval(pid_t, struct timespec *);
-int    sched_setparam(pid_t, const struct sched_param *);
-int    sched_setscheduler(pid_t, int, const struct sched_param *);
-int     sched_yield(void);
-
-#define SCHED_OTHER 0
-#define SCHED_FIFO 1
-#define SCHED_RR 2
-#define SCHED_BATCH 3
-#define SCHED_IDLE 5
-#define SCHED_DEADLINE 6
-#define SCHED_RESET_ON_FORK 0x40000000
-
-#ifdef _GNU_SOURCE
-#define CSIGNAL		0x000000ff
-#define CLONE_NEWTIME	0x00000080
-#define CLONE_VM	0x00000100
-#define CLONE_FS	0x00000200
-#define CLONE_FILES	0x00000400
-#define CLONE_SIGHAND	0x00000800
-#define CLONE_PIDFD	0x00001000
-#define CLONE_PTRACE	0x00002000
-#define CLONE_VFORK	0x00004000
-#define CLONE_PARENT	0x00008000
-#define CLONE_THREAD	0x00010000
-#define CLONE_NEWNS	0x00020000
-#define CLONE_SYSVSEM	0x00040000
-#define CLONE_SETTLS	0x00080000
-#define CLONE_PARENT_SETTID	0x00100000
-#define CLONE_CHILD_CLEARTID	0x00200000
-#define CLONE_DETACHED	0x00400000
-#define CLONE_UNTRACED	0x00800000
-#define CLONE_CHILD_SETTID	0x01000000
-#define CLONE_NEWCGROUP	0x02000000
-#define CLONE_NEWUTS	0x04000000
-#define CLONE_NEWIPC	0x08000000
-#define CLONE_NEWUSER	0x10000000
-#define CLONE_NEWPID	0x20000000
-#define CLONE_NEWNET	0x40000000
-#define CLONE_IO	0x80000000
-int clone (int (*)(void *), void *, int, void *, ...);
-int unshare(int);
-int setns(int, int);
-
-void *memcpy(void *__restrict, const void *__restrict, size_t);
-int memcmp(const void *, const void *, size_t);
-void *memset (void *, int, size_t);
-void *calloc(size_t, size_t);
-void free(void *);
-
-typedef struct cpu_set_t { unsigned long __bits[128/sizeof(long)]; } cpu_set_t;
-int __sched_cpucount(size_t, const cpu_set_t *);
-int sched_getcpu(void);
-int sched_getaffinity(pid_t, size_t, cpu_set_t *);
-int sched_setaffinity(pid_t, size_t, const cpu_set_t *);
-
-#define __CPU_op_S(i, size, set, op) ( (i)/8U >= (size) ? 0 : \
-	(((unsigned long *)(set))[(i)/8/sizeof(long)] op (1UL<<((i)%(8*sizeof(long))))) )
-
-#define CPU_SET_S(i, size, set) __CPU_op_S(i, size, set, |=)
-#define CPU_CLR_S(i, size, set) __CPU_op_S(i, size, set, &=~)
-#define CPU_ISSET_S(i, size, set) __CPU_op_S(i, size, set, &)
-
-#define __CPU_op_func_S(func, op) \
-static __inline void __CPU_##func##_S(size_t __size, cpu_set_t *__dest, \
-	const cpu_set_t *__src1, const cpu_set_t *__src2) \
-{ \
-	size_t __i; \
-	for (__i=0; __i<__size/sizeof(long); __i++) \
-		((unsigned long *)__dest)[__i] = ((unsigned long *)__src1)[__i] \
-			op ((unsigned long *)__src2)[__i] ; \
-}
-
-__CPU_op_func_S(AND, &)
-__CPU_op_func_S(OR, |)
-__CPU_op_func_S(XOR, ^)
-
-#define CPU_AND_S(a,b,c,d) __CPU_AND_S(a,b,c,d)
-#define CPU_OR_S(a,b,c,d) __CPU_OR_S(a,b,c,d)
-#define CPU_XOR_S(a,b,c,d) __CPU_XOR_S(a,b,c,d)
-
-#define CPU_COUNT_S(size,set) __sched_cpucount(size,set)
-#define CPU_ZERO_S(size,set) memset(set,0,size)
-#define CPU_EQUAL_S(size,set1,set2) (!memcmp(set1,set2,size))
-
-#define CPU_ALLOC_SIZE(n) (sizeof(long) * ( (n)/(8*sizeof(long)) \
-	+ ((n)%(8*sizeof(long)) + 8*sizeof(long)-1)/(8*sizeof(long)) ) )
-#define CPU_ALLOC(n) ((cpu_set_t *)calloc(1,CPU_ALLOC_SIZE(n)))
-#define CPU_FREE(set) free(set)
-
-#define CPU_SETSIZE 128
-
-#define CPU_SET(i, set) CPU_SET_S(i,sizeof(cpu_set_t),set)
-#define CPU_CLR(i, set) CPU_CLR_S(i,sizeof(cpu_set_t),set)
-#define CPU_ISSET(i, set) CPU_ISSET_S(i,sizeof(cpu_set_t),set)
-#define CPU_AND(d,s1,s2) CPU_AND_S(sizeof(cpu_set_t),d,s1,s2)
-#define CPU_OR(d,s1,s2) CPU_OR_S(sizeof(cpu_set_t),d,s1,s2)
-#define CPU_XOR(d,s1,s2) CPU_XOR_S(sizeof(cpu_set_t),d,s1,s2)
-#define CPU_COUNT(set) CPU_COUNT_S(sizeof(cpu_set_t),set)
-#define CPU_ZERO(set) CPU_ZERO_S(sizeof(cpu_set_t),set)
-#define CPU_EQUAL(s1,s2) CPU_EQUAL_S(sizeof(cpu_set_t),s1,s2)
-
-#endif
-
-#if _REDIR_TIME64
-__REDIR(sched_rr_get_interval, __sched_rr_get_interval_time64);
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-#endif
+#ifndef _SCHED_H
+#define _SCHED_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+
+#define __NEED_struct_timespec
+#define __NEED_pid_t
+#define __NEED_time_t
+
+#ifdef _GNU_SOURCE
+#define __NEED_size_t
+#endif
+
+#include <bits/alltypes.h>
+#include <stddef.h>
+struct sched_param {
+	int sched_priority;
+	int __reserved1;
+#if _REDIR_TIME64
+	long __reserved2[4];
+#else
+	struct {
+		time_t __reserved1;
+		long __reserved2;
+	} __reserved2[2];
+#endif
+	int __reserved3;
+};
+
+int    sched_get_priority_max(int);
+int    sched_get_priority_min(int);
+int    sched_getparam(pid_t, struct sched_param *);
+int    sched_getscheduler(pid_t);
+int    sched_rr_get_interval(pid_t, struct timespec *);
+int    sched_setparam(pid_t, const struct sched_param *);
+int    sched_setscheduler(pid_t, int, const struct sched_param *);
+int     sched_yield(void);
+
+
+#define SCHED_OTHER 0
+#define SCHED_FIFO 1
+#define SCHED_RR 2
+#define SCHED_BATCH 3
+#define SCHED_IDLE 5
+#define SCHED_DEADLINE 6
+#define SCHED_RESET_ON_FORK 0x40000000
+
+#ifdef _GNU_SOURCE
+#define CSIGNAL		0x000000ff
+#define CLONE_NEWTIME	0x00000080
+#define CLONE_VM	0x00000100
+#define CLONE_FS	0x00000200
+#define CLONE_FILES	0x00000400
+#define CLONE_SIGHAND	0x00000800
+#define CLONE_PIDFD	0x00001000
+#define CLONE_PTRACE	0x00002000
+#define CLONE_VFORK	0x00004000
+#define CLONE_PARENT	0x00008000
+#define CLONE_THREAD	0x00010000
+#define CLONE_NEWNS	0x00020000
+#define CLONE_SYSVSEM	0x00040000
+#define CLONE_SETTLS	0x00080000
+#define CLONE_PARENT_SETTID	0x00100000
+#define CLONE_CHILD_CLEARTID	0x00200000
+#define CLONE_DETACHED	0x00400000
+#define CLONE_UNTRACED	0x00800000
+#define CLONE_CHILD_SETTID	0x01000000
+#define CLONE_NEWCGROUP	0x02000000
+#define CLONE_NEWUTS	0x04000000
+#define CLONE_NEWIPC	0x08000000
+#define CLONE_NEWUSER	0x10000000
+#define CLONE_NEWPID	0x20000000
+#define CLONE_NEWNET	0x40000000
+#define CLONE_IO	0x80000000
+int clone (int (*)(void *), void *, int, void *, ...);
+int unshare(int);
+int setns(int, int);
+
+void *memcpy(void *__restrict, const void *__restrict, size_t);
+int memcmp(const void *, const void *, size_t);
+void *memset (void *, int, size_t);
+void *calloc(size_t, size_t);
+void free(void *);
+
+typedef struct cpu_set_t { unsigned long __bits[128/sizeof(long)]; } cpu_set_t;
+cpu_set_t* __sched_cpualloc(size_t __count);
+int __sched_cpucount(size_t, const cpu_set_t *);
+int sched_getcpu(void);
+int sched_getaffinity(pid_t, size_t, cpu_set_t *);
+int sched_setaffinity(pid_t, size_t, const cpu_set_t *);
+
+#define __CPU_op_S(i, size, set, op) ( (i)/8U >= (size) ? 0 : \
+	(((unsigned long *)(set))[(i)/8/sizeof(long)] op (1UL<<((i)%(8*sizeof(long))))) )
+
+#define CPU_SET_S(i, size, set) __CPU_op_S(i, size, set, |=)
+#define CPU_CLR_S(i, size, set) __CPU_op_S(i, size, set, &=~)
+#define CPU_ISSET_S(i, size, set) __CPU_op_S(i, size, set, &)
+
+#define __CPU_op_func_S(func, op) \
+static __inline void __CPU_##func##_S(size_t __size, cpu_set_t *__dest, \
+	const cpu_set_t *__src1, const cpu_set_t *__src2) \
+{ \
+	size_t __i; \
+	for (__i=0; __i<__size/sizeof(long); __i++) \
+		((unsigned long *)__dest)[__i] = ((unsigned long *)__src1)[__i] \
+			op ((unsigned long *)__src2)[__i] ; \
+}
+
+__CPU_op_func_S(AND, &)
+__CPU_op_func_S(OR, |)
+__CPU_op_func_S(XOR, ^)
+
+#define CPU_AND_S(a,b,c,d) __CPU_AND_S(a,b,c,d)
+#define CPU_OR_S(a,b,c,d) __CPU_OR_S(a,b,c,d)
+#define CPU_XOR_S(a,b,c,d) __CPU_XOR_S(a,b,c,d)
+
+#define CPU_COUNT_S(size,set) __sched_cpucount(size,set)
+#define CPU_ZERO_S(size,set) memset(set,0,size)
+#define CPU_EQUAL_S(size,set1,set2) (!memcmp(set1,set2,size))
+
+#define CPU_ALLOC_SIZE(n) (sizeof(long) * ( (n)/(8*sizeof(long)) \
+	+ ((n)%(8*sizeof(long)) + 8*sizeof(long)-1)/(8*sizeof(long)) ) )
+#define CPU_ALLOC(n) ((cpu_set_t *)calloc(1,CPU_ALLOC_SIZE(n)))
+#define CPU_FREE(set) free(set)
+
+#define CPU_SETSIZE 128
+
+#define CPU_SET(i, set) CPU_SET_S(i,sizeof(cpu_set_t),set)
+#define CPU_CLR(i, set) CPU_CLR_S(i,sizeof(cpu_set_t),set)
+#define CPU_ISSET(i, set) CPU_ISSET_S(i,sizeof(cpu_set_t),set)
+#define CPU_AND(d,s1,s2) CPU_AND_S(sizeof(cpu_set_t),d,s1,s2)
+#define CPU_OR(d,s1,s2) CPU_OR_S(sizeof(cpu_set_t),d,s1,s2)
+#define CPU_XOR(d,s1,s2) CPU_XOR_S(sizeof(cpu_set_t),d,s1,s2)
+#define CPU_COUNT(set) CPU_COUNT_S(sizeof(cpu_set_t),set)
+#define CPU_ZERO(set) CPU_ZERO_S(sizeof(cpu_set_t),set)
+#define CPU_EQUAL(s1,s2) CPU_EQUAL_S(sizeof(cpu_set_t),s1,s2)
+
+
+#endif
+
+#if _REDIR_TIME64
+__REDIR(sched_rr_get_interval, __sched_rr_get_interval_time64);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
+
diff --git a/include/sigchain.h b/include/sigchain.h
new file mode 100644
index 00000000..f9caf037
--- /dev/null
+++ b/include/sigchain.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _SIGCHAIN_H
+#define _SIGCHAIN_H
+
+#ifndef _GNU_SOURCE
+#define _GNU_SOURCE
+#endif
+#include <signal.h>
+#include <stdint.h>
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+static const int SIGCHAIN_ALLOW_NORETURN = 0x1UL;
+
+/* The action of the sigchain. */
+struct signal_chain_action {
+    bool (*sca_sigaction)(int, siginfo_t*, void*);
+    sigset_t sca_mask;
+    int sca_flags;
+};
+
+/* Mark the signal to the sigchain, add the special handler to the sigchain. */
+void add_special_signal_handler(int signo, struct signal_chain_action* sa);
+/* Add the special handler at the last of sigchain chains */
+void add_special_handler_at_last(int signo, struct signal_chain_action* sa);
+/* Remove the special the handler from the sigchain. */
+void remove_special_signal_handler(int signo, bool (*fn)(int, siginfo_t*, void*));
+/* Remove all special the handler from the sigchain */
+void remove_all_special_handler(int signo);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/include/signal.h b/include/signal.h
index c347f861..9d088a80 100644
--- a/include/signal.h
+++ b/include/signal.h
@@ -41,6 +41,7 @@ extern "C" {
 #define SI_USER 0
 #define SI_KERNEL 128
 
+
 typedef struct sigaltstack stack_t;
 
 #endif
@@ -210,8 +211,18 @@ int __libc_current_sigrtmax(void);
 #define SIGRTMIN  (__libc_current_sigrtmin())
 #define SIGRTMAX  (__libc_current_sigrtmax())
 
-int kill(pid_t, int);
+#define MUSL_SIGNAL_NATIVE_REMOTE (SIGRTMIN + 0)
+#define MUSL_SIGNAL_HOOK (SIGRTMIN + 1)
+#define MUSL_SIGNAL_UNHOOK (SIGRTMIN + 2)
+#define MUSL_SIGNAL_NATIVE_LOCAL (SIGRTMIN + 3)
+#define MUSL_SIGNAL_JSHEAP (SIGRTMIN + 4)
+#define MUSL_SIGNAL_JSHEAP_PRIV (SIGRTMIN + 5)
+#ifdef USE_JEMALLOC_RECYCLE_FUNC
+#define MUSL_SIGNAL_RECYCLE_JEMALLOC (SIGRTMIN + 8)
+#endif
+#define MUSL_SIGNAL_MEMCHECK (SIGRTMIN + 9)
 
+int kill(pid_t, int);
 int sigemptyset(sigset_t *);
 int sigfillset(sigset_t *);
 int sigaddset(sigset_t *, int);
diff --git a/include/stdio.h b/include/stdio.h
index d1ed01f0..8692c596 100644
--- a/include/stdio.h
+++ b/include/stdio.h
@@ -217,6 +217,8 @@ FILE *fopencookie(void *, const char *, cookie_io_functions_t);
 #define off64_t off_t
 #endif
 
+#include <fortify/stdio.h>
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/stdlib.h b/include/stdlib.h
index b507ca33..9956b8c2 100644
--- a/include/stdlib.h
+++ b/include/stdlib.h
@@ -172,6 +172,8 @@ long double strtold_l(const char *__restrict, char **__restrict, struct __locale
 #endif
 #endif
 
+#include <fortify/stdlib.h>
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/string.h b/include/string.h
index 43ad0942..15776855 100644
--- a/include/string.h
+++ b/include/string.h
@@ -100,6 +100,8 @@ char *basename();
 #endif
 #endif
 
+#include <fortify/string.h>
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/sys/reboot.h b/include/sys/reboot.h
index 9702eddb..1ff0d09c 100644
--- a/include/sys/reboot.h
+++ b/include/sys/reboot.h
@@ -1,17 +1,50 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #ifndef _SYS_REBOOT_H
 #define _SYS_REBOOT_H
 #ifdef __cplusplus
-extern "C" {
+extern "C"
+{
 #endif
 
-#define RB_AUTOBOOT     0x01234567
-#define RB_HALT_SYSTEM  0xcdef0123
-#define RB_ENABLE_CAD   0x89abcdef
-#define RB_DISABLE_CAD  0
-#define RB_POWER_OFF    0x4321fedc
-#define RB_SW_SUSPEND   0xd000fce2
-#define RB_KEXEC        0x45584543
+#define RB_AUTOBOOT 0x01234567
+#define RB_HALT_SYSTEM 0xcdef0123
+#define RB_ENABLE_CAD 0x89abcdef
+#define RB_DISABLE_CAD 0
+#define RB_POWER_OFF 0x4321fedc
+#define RB_SW_SUSPEND 0xd000fce2
+#define RB_KEXEC 0x45584543
+#define RB_MAGIC1 0xfee1dead
+#define RB_MAGIC2 672274793
 
+/** 
+  * @brief reboots the device, or enables/disables the reboot keystroke.
+  * @param type commands accepted by the reboot() system call.
+  *    -- RESTART     Restart system using default command and mode.
+  *    -- HALT        Stop OS and give system control to ROM monitor, if any.
+  *    -- CAD_ON      Ctrl-Alt-Del sequence causes RESTART command.
+  *    -- CAD_OFF     Ctrl-Alt-Del sequence sends SIGINT to init task.
+  *    -- POWER_OFF   Stop OS and remove all power from system, if possible.
+  *    -- RESTART2    Restart system using given command string.
+  *    -- SW_SUSPEND  Suspend system using software suspend if compiled in.
+  *    -- KEXEC       Restart system using a previously loaded Linux kernel.
+  * @return reboot result.
+  * @retval 0 is returned on success, if CAD was successfully enabled/disabled.
+  * @retval -1 is returned on failure, and errno is set to indicate the error.
+  */
 int reboot(int);
 
 #ifdef __cplusplus
diff --git a/include/sys/socket.h b/include/sys/socket.h
index 6dc1e40a..111a9045 100644
--- a/include/sys/socket.h
+++ b/include/sys/socket.h
@@ -19,6 +19,10 @@ extern "C" {
 
 #include <bits/socket.h>
 
+#ifdef __MUSL__
+#include <linux/socket.h>
+#endif
+
 struct msghdr {
 	void *msg_name;
 	socklen_t msg_namelen;
@@ -371,11 +375,13 @@ struct sockaddr {
 	char sa_data[14];
 };
 
+#ifndef __MUSL__
 struct sockaddr_storage {
 	sa_family_t ss_family;
 	char __ss_padding[128-sizeof(long)-sizeof(sa_family_t)];
 	unsigned long __ss_align;
 };
+#endif
 
 int socket (int, int, int);
 int socketpair (int, int, int, int [2]);
@@ -409,6 +415,8 @@ __REDIR(recvmmsg, __recvmmsg_time64);
 #endif
 #endif
 
+#include <fortify/socket.h>
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/sys/sspret.h b/include/sys/sspret.h
new file mode 100644
index 00000000..da56d090
--- /dev/null
+++ b/include/sys/sspret.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _SSPRET_H
+#define _SSPRET_H
+
+#if defined(__SSP_RET_STRONG__) || defined(__SSP_RET_ALL__)
+#if defined(__aarch64__)
+# define SSPRET_CALC_RETCOOKIE(reg) \
+    eor     reg, reg, x30
+
+# define SSPRET_LOAD_COOKIE(x, reg) \
+    mov     reg, x29
+
+# define SSPRET_SETUP(x, reg) \
+    SSPRET_LOAD_COOKIE(x, reg); \
+    SSPRET_CALC_RETCOOKIE(reg)
+
+# define SSPRET_CHECK(x, reg) \
+    SSPRET_LOAD_COOKIE(x, x9); \
+    SSPRET_CALC_RETCOOKIE(x9); \
+    subs    reg, reg, x9; \
+    cbz     reg, 6788f; \
+    brk     #0x1; \
+6788:
+
+# define SSPRET_PUSH(reg) \
+    str     reg, [sp, #-16]!
+
+# define SSPRET_POP(reg) \
+    ldr     reg, [sp, #16]!
+
+#endif /* __aarch64__ */
+#else
+# define SSPRET_CALC_RETCOOKIE(reg)
+# define SSPRET_LOAD_COOKIE(x, reg)
+# define SSPRET_SETUP(x, reg)
+# define SSPRET_CHECK(x, reg)
+# define SSPRET_PUSH(reg)
+# define SSPRET_POP(reg)
+#endif /* __SSP_RET_STRONG__ || __SSP_RET_ALL__ */
+
+#endif /* _SSPRET_H */
diff --git a/include/sys/stat.h b/include/sys/stat.h
index 10d446c4..450ee53c 100644
--- a/include/sys/stat.h
+++ b/include/sys/stat.h
@@ -119,6 +119,8 @@ __REDIR(futimens, __futimens_time64);
 __REDIR(utimensat, __utimensat_time64);
 #endif
 
+#include <fortify/stat.h>
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/sys/syscall.h b/include/sys/syscall.h
index 24987ddf..f5e82294 100644
--- a/include/sys/syscall.h
+++ b/include/sys/syscall.h
@@ -3,4 +3,45 @@
 
 #include <bits/syscall.h>
 
+/* fixup legacy 16-bit junk */
+#ifdef SYS_getuid32
+#undef SYS_lchown
+#undef SYS_getuid
+#undef SYS_getgid
+#undef SYS_geteuid
+#undef SYS_getegid
+#undef SYS_setreuid
+#undef SYS_setregid
+#undef SYS_getgroups
+#undef SYS_setgroups
+#undef SYS_fchown
+#undef SYS_setresuid
+#undef SYS_getresuid
+#undef SYS_setresgid
+#undef SYS_getresgid
+#undef SYS_chown
+#undef SYS_setuid
+#undef SYS_setgid
+#undef SYS_setfsuid
+#undef SYS_setfsgid
+#define SYS_lchown SYS_lchown32
+#define SYS_getuid SYS_getuid32
+#define SYS_getgid SYS_getgid32
+#define SYS_geteuid SYS_geteuid32
+#define SYS_getegid SYS_getegid32
+#define SYS_setreuid SYS_setreuid32
+#define SYS_setregid SYS_setregid32
+#define SYS_getgroups SYS_getgroups32
+#define SYS_setgroups SYS_setgroups32
+#define SYS_fchown SYS_fchown32
+#define SYS_setresuid SYS_setresuid32
+#define SYS_getresuid SYS_getresuid32
+#define SYS_setresgid SYS_setresgid32
+#define SYS_getresgid SYS_getresgid32
+#define SYS_chown SYS_chown32
+#define SYS_setuid SYS_setuid32
+#define SYS_setgid SYS_setgid32
+#define SYS_setfsuid SYS_setfsuid32
+#define SYS_setfsgid SYS_setfsgid32
+#endif
 #endif
diff --git a/include/sys/sysinfo.h b/include/sys/sysinfo.h
index 6a3931e5..9b095ffb 100644
--- a/include/sys/sysinfo.h
+++ b/include/sys/sysinfo.h
@@ -5,6 +5,7 @@
 extern "C" {
 #endif
 
+#ifndef _LINUX_KERNEL_H
 #define SI_LOAD_SHIFT 16
 
 struct sysinfo {
@@ -22,6 +23,7 @@ struct sysinfo {
 	unsigned mem_unit;
 	char __reserved[256];
 };
+#endif
 
 int sysinfo (struct sysinfo *);
 int get_nprocs_conf (void);
diff --git a/include/sys/tgkill.h b/include/sys/tgkill.h
new file mode 100644
index 00000000..0dd46ec8
--- /dev/null
+++ b/include/sys/tgkill.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _SYS_TGKILL_H
+#define _SYS_TGKILL_H
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/** 
+  * @brief send any signal to any process group or process.
+  * @param tgid the group ID of the calling process.
+  * @param tid the thread ID of the calling process.
+  * @param sig the actual signal.
+  * @return tgkill result.
+  * @retval 0 is returned on success.
+  * @retval -1 is returned on failure, and errno is set to indicate the error.
+  */
+int tgkill(int tgid, int tid, int sig);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
\ No newline at end of file
diff --git a/include/trace/trace_marker.h b/include/trace/trace_marker.h
new file mode 100644
index 00000000..3506f2d7
--- /dev/null
+++ b/include/trace/trace_marker.h
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _TRACE_TRACE_MARKER_H
+#define _TRACE_TRACE_MARKER_H
+
+#include <stdint.h>
+
+#define TRACE_MARKER_MESSAGE_LEN 1024
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+static const uint64_t HITRACE_TAG_ALWAYS = (1ULL << 0); // This tag is always enabled.
+static const uint64_t HITRACE_TAG_MUSL = (1ULL << 12); // musl tag.
+
+/**
+  * @brief Reset trace_marker trace switch status
+  */
+void trace_marker_reset(void);
+
+/**
+  * @brief Write the function call information to the trace_marker node in kernel space,
+  *        used on the same thread as trace_marker_end(),with the symbol "B".
+  * @param label The tagLabel of current sub-system.
+  * @param message The function of information.
+  * @param value The value which want to trace.
+  */
+void trace_marker_begin(uint64_t label, const char *message, const char *value);
+
+/**
+  * @brief Write the terminator to the trace_marker node of the kernel space,
+  *        used on the same thread as trace_marker_begin(),with the symbol "E".
+  * @param label The tagLabel of current sub-system.
+  */
+void trace_marker_end(uint64_t label);
+
+/**
+  * @brief Write the function call information to the trace_marker node in kernel space,
+  *        used in a different thread than trace_marker_async_end(),with the symbol "S".
+  * @param label The tagLabel of current sub-system.
+  * @param message The function of information.
+  * @param value The value which want to trace.
+  */
+void trace_marker_async_begin(uint64_t label, const char *message, const char *value, int taskId);
+
+/**
+  * @brief Write the terminator to the trace_marker node in kernel space,
+  *        used in a different thread than trace_marker_async_begin(),with the symbol "F".
+  * @param label The tagLabel of current sub-system.
+  * @param message The function of information.
+  * @param value The value which want to trace.
+  */
+void trace_marker_async_end(uint64_t label, const char *message, const char *value, int taskId);
+
+/**
+  * @brief Marks a pre-traced numeric variable,with the symbol "C".
+  * @param label The tagLabel of current sub-system.
+  * @param message The function of information.
+  * @param value The value which want to trace.
+  */
+void trace_marker_count(uint64_t label, const char *message, int value);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/include/unistd.h b/include/unistd.h
index 212263a7..594cc877 100644
--- a/include/unistd.h
+++ b/include/unistd.h
@@ -468,6 +468,21 @@ pid_t gettid(void);
 #define _CS_V6_ENV	1148
 #define _CS_V7_ENV	1149
 
+#ifdef _GNU_SOURCE
+#ifndef TEMP_FAILURE_RETRY
+#define MUSL_TEMP_FAILURE_RETRY(expression) \
+    (__extension__ \
+        ({ long int __result; \
+            do __result = (long int)(expression); \
+            while(__result == -1L&& errno == EINTR); \
+        __result;}))
+
+#define TEMP_FAILURE_RETRY(expression) MUSL_TEMP_FAILURE_RETRY(expression)
+#endif
+#endif
+
+#include <fortify/unistd.h>
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/ldso/README.md b/ldso/README.md
new file mode 100644
index 00000000..ea607086
--- /dev/null
+++ b/ldso/README.md
@@ -0,0 +1,18 @@
+## Dynamic Linker Namespace
+
+The dynamic linker provides the namespace mechanism which is based on configures and apis. 
+
+Shared libraries can be isolated in different  namespaces so that libraries with same library name but with different symbols won't conflict. On the other hand, the namespace mechanism provides the flexibility so that some shared libraries can be exported by a linker namespace and used by another linker namespace. 
+
+
+### How does it work
+
+There are two ways to use the linker namespace: 
+
+1. Modify and save the namespace configure file </etc/ld-musl-namespace-arm.ini> or </etc/ld-musl-namespace-aarch64.ini> base on architecture. When it does not exist or is filled in, a default namespace will be created.
+   
+2. Use the apis of namespace in head file <dlfcn.h>, to create a namespace, to set search paths of library, or to use exported libraries of another namespace by inheriting it.
+
+### Usage example
+
+Test usages show some examples of using the linker namespace. The file <ld-musl-namespace-arm.ini> or <ld-musl-namespace-aarch64.ini> in config directory is configures for test. The file <libc-test/src/functionalext/dlns/> gives usages of how apis and configures work.
diff --git a/ldso/cfi.c b/ldso/cfi.c
new file mode 100644
index 00000000..314e740a
--- /dev/null
+++ b/ldso/cfi.c
@@ -0,0 +1,509 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define _GNU_SOURCE
+#include <sys/mman.h>
+#include <sys/prctl.h>
+#include "cfi.h"
+#include "ld_log.h"
+#include "namespace.h"
+
+/* This module provides support for LLVM CFI Cross-DSO by implementing the __cfi_slowpath() and __cfi_slowpath_diag()
+ * functions. These two functions will be called before visiting other dso's resources. The responsibility is to
+ * calculate the __cfi_check() of the target dso, and call it. So use CFI shadow and shadow value to store the
+ * relationship between dso and its __cfi_check addr while loading a dso. CFI shadow is an array which stores shadow
+ * values. Shadow value is used to store the relationship. A shadow value can map 1 LIBRARY_ALIGNMENT memory range. So
+ * each dso will be mapped to one or more shadow values in the CFI shadow, this depends on the address range of the
+ * dso.
+ * There are 3 types for shadow value:
+ * - invalid(0) : the target addr does not belongs to any loaded dso.
+ * - uncheck(1) : this LIBRARY_ALIGNMENT memory range belongs to a dso but it is no need to do the CFI check.
+ * - valid(2 - 0xFFFF) : this LIBRARY_ALIGNMENT memory range belongs to a dso and need to do the CFI check.
+ * The valid shadow value records the distance from the end of a LIBRARY_ALIGNMENT memory range to the __cfi_check addr
+ * of the dso (The unit is 4096, because the __cfi_check is aligned with 4096).
+ * The valid shadow value is calculated as below:
+ *      sv = (AlignUp(__cfi_check, LIBRARY_ALIGNMENT) - __cfi_check + N * LIBRARY_ALIGNMENT) / 4096 + 2;
+ *
+ *      N   : starts at 0, is the index of LIBRARY_ALIGNMENT memory range that belongs to a dso.
+ *      + 2 : to avoid conflict with invalid and uncheck shadow value.
+ * 
+ * Below is a example for calculating shadow values of a dso.
+ *                                               liba.so
+ *                                                /\
+ *           /''''''''''''''''''''''''''''''''''''  '''''''''''''''''''''''''''''''''''''\
+ *           0x40000  __cfi_check addr = 0x42000               0x80000                  0xA0000                0xC0000
+ *           +---------^----------------------------------------^-------------------------^-------------------------+
+ *  Memory   |         |                                        |                         |                         |
+ *           +------------------------------------------------------------------------------------------------------+
+ *           \........... LIBRARY_ALIGNMENT ..................../\........... LIBRARY_ALIGNMENT ..................../
+ *             \                                              /                                               /
+ *               \                                          /                                          /
+ *                 \                                      /                                     /
+ *                   \                                  /                                /
+ *                     \                              /                            /
+ *            +-----------------------------------------------------------------------------------------------------+
+ * CFI shadow |  invalid |           sv1              |           sv2              |            invalid             |
+ *            +-----------------------------------------------------------------------------------------------------+
+ *                          sv1 = (0x80000 - 0x42000 + 0 * LIBRARY_ALIGNMENT) / 4096 + 2 = 64
+ *                          sv2 = (0x80000 - 0x42000 + 1 * LIBRARY_ALIGNMENT) / 4096 + 2 = 126
+ * 
+ * Calculating the __cfi_check address is a reverse process:
+ * - First align up the target addr with LIBRARY_ALIGNMENT to locate the corresponding shadow value.
+ * - Then calculate the __cfi_check addr.
+ * 
+ * In order for the algorithm to work well, the start addr of each dso should be aligned with LIBRARY_ALIGNMENT. */
+
+#define MAX(a,b)                (((a) > (b)) ? (a) : (b))
+#define MIN(a,b)                (((a) < (b)) ? (a) : (b))
+#define ALIGN_UP(a, b)          (((a) + (b) - 1) & -(b))
+#define ALIGN_DOWN(a, b)        ((a) & -(b))
+#if DL_FDPIC
+#define LADDR(p, v)             laddr((p), (v))
+#else
+#define LADDR(p, v)             (void *)((p)->base + (v))
+#endif
+
+/* Function ptr for __cfi_check() */
+typedef int (*cfi_check_t)(uint64_t, void *, void *);
+
+static const uintptr_t shadow_granularity = LIBRARY_ALIGNMENT_BITS;
+static const uintptr_t cfi_check_granularity = 12;
+static const uintptr_t shadow_alignment = 1UL << shadow_granularity;
+static uintptr_t shadow_size = 0;
+/* Start addr of the CFI shadow */
+static char *cfi_shadow_start = NULL;
+/* List head of all the DSOs loaded by the process */
+static struct dso *dso_list_head = NULL;
+static struct dso *pldso = NULL;
+
+/* Shadow value */
+/* The related shadow value(s) will be set to `sv_invalid` when:
+ * - init CFI shadow.
+ * - removing a dso. */
+static const uint16_t sv_invalid = 0;
+/* The related shadow value(s) will be set to `sv_uncheck` if:
+ * - the DSO does not enable CFI Cross-Dso.
+ * - the DSO enabled CFI Cross-Dso, but this DSO is larger than 16G, for the part of the dso that exceeds 16G,
+ *   its shadow value will be set to `sv_uncheck`. */
+static const uint16_t sv_uncheck = 1;
+/* If a DSO enabled CFI Cross-Dso, the DSO's shadow value should be valid. Because of the defination of `sv_invalid`
+ * and `sv_unchecked`, the valid shadow value should be at least 2. */
+static const uint16_t sv_valid_min = 2;
+
+#if defined(__LP64__)
+static const uintptr_t max_target_addr = 0xffffffffffff;
+#else
+static const uintptr_t max_target_addr = 0xffffffff;
+#endif
+
+/* Create a cfi shadow */
+static int create_cfi_shadow(void);
+
+/* Map dsos to CFI shadow */
+static int add_dso_to_cfi_shadow(struct dso *dso);
+static int fill_shadow_value_to_shadow(uintptr_t begin, uintptr_t end, uintptr_t cfi_check, uint16_t type);
+
+/* Find the __cfi_check() of target dso and call it */
+void __cfi_slowpath(uint64_t call_site_type_id, void *func_ptr);
+void __cfi_slowpath_diag(uint64_t call_site_type_id, void *func_ptr, void *diag_data);
+
+static inline uintptr_t addr_to_offset(uintptr_t addr, int bits)
+{
+    /* Convert addr to CFI shadow offset.
+     * Shift left 1 bit because the shadow value is uint16_t. */
+    return (addr >> bits) << 1;
+}
+
+static struct symdef find_cfi_check_sym(struct dso *p)
+{
+    LD_LOGD("[CFI] [%{public}s] start!\n", __FUNCTION__);
+
+    struct verinfo verinfo = { .s = "__cfi_check", .v = "", .use_vna_hash = false };
+    struct sym_info_pair s_info_p = gnu_hash(verinfo.s);
+    return find_sym_impl(p, &verinfo, s_info_p, 0, p->namespace);
+}
+
+static int is_addr_in_ldso(size_t a)
+{
+    size_t i = 0;
+    if (DL_FDPIC) {
+        i = count_syms(pldso);
+        if (a - (size_t)pldso->funcdescs < i * sizeof(*pldso->funcdescs))
+            return 1;
+    }
+    if (DL_FDPIC && pldso->loadmap) {
+        for (i = 0; i < pldso->loadmap->nsegs; i++) {
+            if (a-pldso->loadmap->segs[i].p_vaddr
+                < pldso->loadmap->segs[i].p_memsz)
+                return 1;
+        }
+    } else {
+        Phdr *ph = pldso->phdr;
+        size_t phcnt = pldso->phnum;
+        size_t entsz = pldso->phentsize;
+        size_t base = (size_t)pldso->base;
+        for (; phcnt--; ph = (void *)((char *)ph + entsz)) {
+            if (ph->p_type != PT_LOAD) continue;
+            if (a - base - ph->p_vaddr < ph->p_memsz)
+                return 1;
+        }
+        if (a - (size_t)pldso->map < pldso->map_len)
+            return 0;
+    }
+    return 0;
+}
+
+static uintptr_t get_cfi_check_addr(uint16_t value, void* func_ptr)
+{
+    LD_LOGD("[CFI] [%{public}s] start!\n", __FUNCTION__);
+
+    uintptr_t addr = (uintptr_t)func_ptr;
+    uintptr_t aligned_addr = ALIGN_DOWN(addr, shadow_alignment) + shadow_alignment;
+    uintptr_t cfi_check_func_addr = aligned_addr - ((uintptr_t)(value - sv_valid_min) << cfi_check_granularity);
+#ifdef __arm__
+    LD_LOGD("[CFI] [%{public}s] __arm__ defined!\n", __FUNCTION__);
+    cfi_check_func_addr++;
+#endif
+    LD_LOGD("[CFI] [%{public}s] cfi_check_func_addr[%{public}p] in dso[%{public}s]\n",
+            __FUNCTION__, cfi_check_func_addr, ((struct dso *)addr2dso((size_t)cfi_check_func_addr))->name);
+
+    return cfi_check_func_addr;
+}
+
+static inline void cfi_slowpath_common(uint64_t call_site_type_id, void *func_ptr, void *diag_data)
+{
+    uint16_t value = sv_invalid;
+
+    if (func_ptr == NULL) {
+        return;
+    }
+
+#if defined(__aarch64__)
+    LD_LOGD("[CFI] [%{public}s] __aarch64__ defined!\n", __FUNCTION__);
+    uintptr_t addr = (uintptr_t)func_ptr & ((1ULL << 56) - 1);
+#else
+    LD_LOGD("[CFI] [%{public}s] __aarch64__ not defined!\n", __FUNCTION__);
+    uintptr_t addr = func_ptr;
+#endif
+
+    /* Get shadow value */
+    uintptr_t offset = addr_to_offset(addr, shadow_granularity);
+
+    if (cfi_shadow_start == NULL) {
+        LD_LOGE("[CFI] [%{public}s] the cfi_shadow_start is null!\n", __FUNCTION__);
+        __builtin_trap();
+    }
+
+    if (offset > shadow_size) {
+        value = sv_invalid;
+    } else {
+        value = *((uint16_t*)(cfi_shadow_start + offset));
+    }
+    LD_LOGD("[CFI] [%{public}s] called from %{public}s to %{public}s func_ptr:0x%{public}p shadow value:%{public}d diag_data:0x%{public}p call_site_type_id[%{public}p.\n",
+             __FUNCTION__,
+             ((struct dso *)addr2dso((size_t)__builtin_return_address(0)))->name,
+             ((struct dso *)addr2dso((size_t)func_ptr))->name,
+             func_ptr, value, diag_data, call_site_type_id);
+
+    struct dso *dso = NULL;
+    switch (value)
+    {
+    case sv_invalid:
+        /* The ldso is an exception because it is loaded by kernel and is not mapped to the CFI shadow.
+         * Do not check it. */
+        if (is_addr_in_ldso((size_t)func_ptr)) {
+            LD_LOGI("[CFI] [%{public}s] uncheck for ldso\n", __FUNCTION__);
+            return;
+        }
+
+        dso = (struct dso *)addr2dso((size_t)__builtin_return_address(0));
+        if (dso == NULL) {
+            LD_LOGE("[CFI] [%{public}s] can not find the dso!\n", __FUNCTION__);
+            __builtin_trap();
+        }
+        LD_LOGD("[CFI] [%{public}s] dso name[%{public}s]!\n", __FUNCTION__, dso->name);
+
+        struct symdef cfi_check_sym = find_cfi_check_sym(dso);
+        if (!cfi_check_sym.sym) {
+            LD_LOGE("[CFI] [%{public}s] can not find the __cfi_check in the dso!\n", __FUNCTION__);
+            __builtin_trap();
+        }
+        LD_LOGD("[CFI] [%{public}s] cfi_check addr[%{public}p]!\n", __FUNCTION__,
+                LADDR(cfi_check_sym.dso, cfi_check_sym.sym->st_value));
+        ((cfi_check_t)LADDR(cfi_check_sym.dso, cfi_check_sym.sym->st_value))(call_site_type_id, func_ptr, diag_data);
+        break;
+    case sv_uncheck:
+        break;
+    default:
+        ((cfi_check_t)get_cfi_check_addr(value, func_ptr))(call_site_type_id, func_ptr, diag_data);
+        break;
+    }
+
+    return;
+}
+
+int init_cfi_shadow(struct dso *dso_list, struct dso *ldso)
+{
+    LD_LOGD("[CFI] [%{public}s] start!\n", __FUNCTION__);
+
+    if (dso_list == NULL) {
+        LD_LOGW("[CFI] [%{public}s] has null param!\n", __FUNCTION__);
+        return CFI_SUCCESS;
+    }
+
+    /* Save the head node of dso list */
+    dso_list_head = dso_list;
+    pldso = ldso;
+
+    return map_dso_to_cfi_shadow(dso_list);
+}
+
+int map_dso_to_cfi_shadow(struct dso *dso)
+{
+    bool has_cfi_check = false;
+
+    if (dso == NULL) {
+        LD_LOGW("[CFI] [%{public}s] has null param!\n", __FUNCTION__);
+        return CFI_SUCCESS;
+    }
+
+    /* If the cfi shadow does not exist, create it and map all the dsos and its dependents to it. */
+    if (cfi_shadow_start == NULL) {
+        /* Find __cfi_check symbol in dso list */
+        for (struct dso *p = dso; p; p = p->next) {
+            if (find_cfi_check_sym(p).sym) {
+                LD_LOGD("[CFI] [%{public}s] find __cfi_check function in dso %{public}s!\n", __FUNCTION__, p->name);
+                has_cfi_check = true;
+                break;
+            }
+        }
+
+        if (has_cfi_check) {
+            if (create_cfi_shadow() == CFI_FAILED) {
+                LD_LOGE("[CFI] [%{public}s] create cfi shadow failed!\n", __FUNCTION__);
+                return CFI_FAILED;
+            }
+            add_dso_to_cfi_shadow(dso_list_head);
+            prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, cfi_shadow_start, shadow_size, "cfi_shadow:musl");
+        }
+    /* If the cfi shadow exists, map the current dso and its dependents to it. */
+    } else {
+        add_dso_to_cfi_shadow(dso);
+        prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, cfi_shadow_start, shadow_size, "cfi_shadow:musl");
+    }
+
+    return CFI_SUCCESS;
+}
+
+void unmap_dso_from_cfi_shadow(struct dso *dso)
+{
+    if (dso == NULL) {
+        LD_LOGD("[CFI] [%{public}s] has null param!\n", __FUNCTION__);
+        return;
+    }
+
+    LD_LOGD("[CFI] [%{public}s] unmap dso %{public}s from shadow!\n", __FUNCTION__, dso->name);
+
+    if (cfi_shadow_start == NULL)
+        return;
+
+    if (dso->map == 0 || dso->map_len == 0)
+        return;
+
+    if (dso->is_mapped_to_shadow == false)
+        return;
+
+    /* Set the dso's shadow value as invalid. */
+    fill_shadow_value_to_shadow(dso->map, dso->map + dso->map_len, 0, sv_invalid);
+    dso->is_mapped_to_shadow = false;
+    prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, cfi_shadow_start, shadow_size, "cfi_shadow:musl");
+
+    return;
+}
+
+static int create_cfi_shadow(void)
+{
+    LD_LOGD("[CFI] [%{public}s] start!\n", __FUNCTION__);
+
+    /* Each process can load up to (max_target_addr >> shadow_granularity) dsos. Shift left 1 bit because the shadow 
+     * value is uint16_t. The size passed to mmap() should be aligned with 4096, so shadow_size should be aligned. */
+    shadow_size = ALIGN_UP(((max_target_addr >> shadow_granularity) << 1), PAGE_SIZE);
+
+    uintptr_t *mmap_addr = mmap(NULL, shadow_size, PROT_READ, MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, -1, 0);
+
+    if (mmap_addr == MAP_FAILED) {
+        LD_LOGE("[CFI] [%{public}s] mmap failed!\n", __FUNCTION__);
+        return CFI_FAILED;
+    }
+
+    cfi_shadow_start = (char*)mmap_addr;
+    LD_LOGD("[CFI] [%{public}s] the cfi_shadow_start addr is %{public}p!\n", __FUNCTION__, cfi_shadow_start);
+
+    return CFI_SUCCESS;
+}
+
+static int add_dso_to_cfi_shadow(struct dso *dso)
+{
+    LD_LOGD("[CFI] [%{public}s] start with %{public}s !\n", __FUNCTION__, dso->name);
+    for (struct dso *p = dso; p; p = p->next) {
+        LD_LOGD("[CFI] [%{public}s] adding %{public}s to cfi shadow!\n", __FUNCTION__, p->name);
+        if (p->map == 0 || p->map_len == 0) {
+            LD_LOGW("[CFI] [%{public}s] the dso has no data! map[%{public}p] map_len[0x%{public}x]\n",
+                    __FUNCTION__, p->map, p->map_len);
+            continue;
+        }
+
+        if (p->is_mapped_to_shadow == true) {
+            LD_LOGW("[CFI] [%{public}s] %{public}s is already in shadow!\n", __FUNCTION__, p->name);
+            continue;
+        }
+
+        struct symdef cfi_check_sym = find_cfi_check_sym(p);
+        /* If the dso doesn't have __cfi_check(), set it's shadow value unchecked. */
+        if (!cfi_check_sym.sym) {
+            LD_LOGD("[CFI] [%{public}s] %{public}s has no __cfi_check()!\n", __FUNCTION__, p->name);
+            if (fill_shadow_value_to_shadow(p->map, p->map + p->map_len, 0, sv_uncheck) == CFI_FAILED) {
+                LD_LOGE("[CFI] [%{public}s] add dso to cfi shadow failed!\n", __FUNCTION__);
+                return CFI_FAILED;
+            }
+        /* If the dso has __cfi_check(), set it's shadow value valid. */
+        } else {
+            LD_LOGD("[CFI] [%{public}s] %{public}s has __cfi_check()!\n", __FUNCTION__, p->name);
+            uintptr_t end = p->map + p->map_len;
+            uintptr_t cfi_check = LADDR(cfi_check_sym.dso, cfi_check_sym.sym->st_value);
+
+            if (cfi_check == 0) {
+                LD_LOGE("[CFI] [%{public}s] %{public}s has null cfi_check func!\n", __FUNCTION__, p->name);
+                return CFI_FAILED;
+            }
+            if (fill_shadow_value_to_shadow(p->map, end, cfi_check, sv_valid_min) == CFI_FAILED) {
+                LD_LOGE("[CFI] [%{public}s] add %{public}s to cfi shadow failed!\n", __FUNCTION__, p->name);
+                return CFI_FAILED;
+            }
+        }
+        p->is_mapped_to_shadow = true;
+        LD_LOGD("[CFI] [%{public}s] add %{public}s to cfi shadow succeed.\n", __FUNCTION__, p->name);
+    }
+    LD_LOGD("[CFI] [%{public}s] %{public}s done.\n", __FUNCTION__, dso->name);
+
+    return CFI_SUCCESS;
+}
+
+static int fill_shadow_value_to_shadow(uintptr_t begin, uintptr_t end, uintptr_t cfi_check, uint16_t type)
+{
+    LD_LOGD("[CFI] [%{public}s] begin[%{public}x] end[%{public}x] cfi_check[%{public}x] type[%{public}x]!\n",
+            __FUNCTION__, begin, end, cfi_check, type);
+
+    /* To ensure the atomicity of the CFI shadow operation, we create a temp_shadow, write the shadow value to 
+     * the temp_shadow, and then write it back to the CFI shadow by mremap(). */
+    begin = ALIGN_DOWN(MAX(begin, cfi_check), shadow_alignment);
+    char* shadow_begin = cfi_shadow_start + addr_to_offset(begin, LIBRARY_ALIGNMENT_BITS);
+    char* shadow_end = (char*)(((uint16_t*)(cfi_shadow_start + addr_to_offset(end - 1, LIBRARY_ALIGNMENT_BITS))) + 1);
+    char* aligned_shadow_begin = (char*)ALIGN_DOWN((uintptr_t)shadow_begin, PAGE_SIZE);
+    char* aligned_shadow_end = (char*)ALIGN_UP((uintptr_t)shadow_end, PAGE_SIZE);
+
+    uint16_t tmp_shadow_size = aligned_shadow_end - aligned_shadow_begin;
+    uint16_t offset_begin = shadow_begin - aligned_shadow_begin;
+    uint16_t offset_end = shadow_end - aligned_shadow_begin;
+
+    char* tmp_shadow_start = (char*)mmap(NULL, tmp_shadow_size,
+        PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+
+    if (tmp_shadow_start == MAP_FAILED) {
+        LD_LOGE("[CFI] [%{public}s] mmap failed!\n", __FUNCTION__);
+        return CFI_FAILED;
+    }
+
+    LD_LOGD("[CFI] [%{public}s] tmp_shadow_start is %{public}p\t tmp_shadow_size is 0x%{public}x!\n",
+        __FUNCTION__, tmp_shadow_start, tmp_shadow_size);
+    memcpy(tmp_shadow_start, aligned_shadow_begin, offset_begin);
+    memcpy(tmp_shadow_start + offset_end, shadow_end, aligned_shadow_end - shadow_end);
+
+    /* If the dso has __cfi_check(), calculate valid shadow value */
+    if (type == sv_valid_min) {
+#ifdef __arm__
+        uint16_t shadow_value_begin = ((begin + shadow_alignment - (cfi_check - 1))
+            >> cfi_check_granularity) + sv_valid_min;
+#else
+        uint16_t shadow_value_begin = ((begin + shadow_alignment - cfi_check)
+            >> cfi_check_granularity) + sv_valid_min;
+#endif
+        LD_LOGD("[CFI] [%{public}s] shadow_value_begin is 0x%{public}x!\n", __FUNCTION__, shadow_value_begin);
+        uint16_t shadow_value_step = 1 << (shadow_granularity - cfi_check_granularity);
+        uint16_t shadow_value = shadow_value_begin;
+
+        /* Set shadow_value */
+        for (uint16_t *shadow_addr = tmp_shadow_start + offset_begin;
+            shadow_addr != tmp_shadow_start + offset_end; shadow_addr++) {
+            /* If a dso is larger than 16G( = max_shadow_value * shadow_alignment / 1G),
+             * the excess is not checked. */
+            if (shadow_value < shadow_value_begin) {
+                *shadow_addr = sv_uncheck;
+                continue;
+            }
+            *shadow_addr = (*shadow_addr == sv_invalid) ? shadow_value : sv_uncheck;
+            shadow_value += shadow_value_step;
+        }
+    /* in these cases, shadow_value will always be sv_uncheck or sv_invalid */
+    } else if (type == sv_uncheck || type == sv_invalid) {
+        /* Set shadow_value */
+        for (uint16_t *shadow_addr = tmp_shadow_start + offset_begin;
+            shadow_addr != tmp_shadow_start + offset_end; shadow_addr++) {
+            *shadow_addr = type;
+        }
+    } else {
+        LD_LOGE("[CFI] [%{public}s] has error param!\n", __FUNCTION__);
+        munmap(tmp_shadow_start, tmp_shadow_size);
+        return CFI_FAILED;
+    }
+
+    mprotect(tmp_shadow_start, tmp_shadow_size, PROT_READ);
+    /* Remap temp_shadow to CFI shadow. */
+    uint16_t* mremap_addr = mremap(tmp_shadow_start, tmp_shadow_size, tmp_shadow_size,
+        MREMAP_MAYMOVE | MREMAP_FIXED, aligned_shadow_begin);
+
+    if (mremap_addr == MAP_FAILED) {
+        LD_LOGE("[CFI] [%{public}s] mremap failed!\n", __FUNCTION__);
+        munmap(tmp_shadow_start, tmp_shadow_size);
+        return CFI_FAILED;
+    }
+
+    LD_LOGD("[CFI] [%{public}s] fill completed!\n", __FUNCTION__);
+    return CFI_SUCCESS;
+}
+
+void __cfi_slowpath(uint64_t call_site_type_id, void *func_ptr)
+{
+    LD_LOGD("[CFI] [%{public}s] called from dso[%{public}s] to dso[%{public}s] func_ptr[%{public}p]\n",
+            __FUNCTION__,
+            ((struct dso *)addr2dso((size_t)__builtin_return_address(0)))->name,
+            ((struct dso *)addr2dso((size_t)func_ptr))->name,
+            func_ptr);
+
+    cfi_slowpath_common(call_site_type_id, func_ptr, NULL);
+    return;
+}
+
+void __cfi_slowpath_diag(uint64_t call_site_type_id, void *func_ptr, void *diag_data)
+{
+    LD_LOGD("[CFI] [%{public}s] called from dso[%{public}s] to dso[%{public}s] func_ptr[%{public}p]\n",
+            __FUNCTION__,
+            ((struct dso *)addr2dso((size_t)__builtin_return_address(0)))->name,
+            ((struct dso *)addr2dso((size_t)func_ptr))->name,
+            func_ptr);
+
+    cfi_slowpath_common(call_site_type_id, func_ptr, diag_data);
+    return;
+}
\ No newline at end of file
diff --git a/ldso/cfi.h b/ldso/cfi.h
new file mode 100644
index 00000000..4eb56b7c
--- /dev/null
+++ b/ldso/cfi.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "dynlink.h"
+
+#define CFI_SUCCESS             0
+#define CFI_FAILED              -1
+/* Define LIBRARY_ALIGNMENT to balance the size of CFI shadow and the number of DSOs that each process can load.
+ * The LIBRARY_ALIGNMENT is use to calculate the start address of a DSO. Each DSO should be in the different
+ * LIBRARY_ALIGNMENT memory range so that each DSO can be well mapped to the CFI shadow.
+ */
+#define LIBRARY_ALIGNMENT_BITS  18
+#define LIBRARY_ALIGNMENT       (1UL << LIBRARY_ALIGNMENT_BITS)
+
+/* map all the dso and the dependents to cfi shadow */
+int init_cfi_shadow(struct dso *dso_list, struct dso *ldso);
+/* map a dso and the dependents to cfi shadow */
+int map_dso_to_cfi_shadow(struct dso *dso);
+/* unmap a dso from cfi shadow */
+void unmap_dso_from_cfi_shadow(struct dso *dso);
\ No newline at end of file
diff --git a/ldso/dynlink.c b/ldso/dynlink.c
index 0779c12d..c8832f63 100644
--- a/ldso/dynlink.c
+++ b/ldso/dynlink.c
@@ -1,5 +1,9 @@
 #define _GNU_SOURCE
 #define SYSCALL_NO_TLS 1
+
+#include "dynlink.h"
+
+#include <stdbool.h>
 #include <stdlib.h>
 #include <stdarg.h>
 #include <stddef.h>
@@ -19,25 +23,72 @@
 #include <dlfcn.h>
 #include <semaphore.h>
 #include <sys/membarrier.h>
+#include <sys/time.h>
+#include <time.h>
+#include <sys/prctl.h>
+
+#include "cfi.h"
+#include "dlfcn_ext.h"
+#include "dynlink_rand.h"
+#include "ld_log.h"
+#include "libc.h"
+#include "namespace.h"
+#include "ns_config.h"
 #include "pthread_impl.h"
 #include "fork_impl.h"
-#include "libc.h"
-#include "dynlink.h"
+#include "strops.h"
+#include "trace/trace_marker.h"
+
+#ifdef OHOS_ENABLE_PARAMETER
+#include "sys_param.h"
+#endif
+#ifdef LOAD_ORDER_RANDOMIZATION
+#include "zip_archive.h"
+#endif
 
 #define malloc __libc_malloc
 #define calloc __libc_calloc
 #define realloc __libc_realloc
 #define free __libc_free
 
-#define SYS_PATH_DFLT SYSLIBDIR ":" LIBDIR
-
 static void error(const char *, ...);
 
 #define MAXP2(a,b) (-(-(a)&-(b)))
 #define ALIGN(x,y) ((x)+(y)-1 & -(y))
+#define GNU_HASH_FILTER(ght, ghm, gho)                \
+	const size_t *bloomwords = (const void *)(ght+4); \
+	size_t f = bloomwords[gho & (ght[2]-1)];          \
+	if (!(f & ghm)) continue;                         \
+	f >>= (gh >> ght[3]) % (8 * sizeof f);            \
+	if (!(f & 1)) continue;
 
 #define container_of(p,t,m) ((t*)((char *)(p)-offsetof(t,m)))
 #define countof(a) ((sizeof (a))/(sizeof (a)[0]))
+#define DSO_FLAGS_NODELETE 0x1
+
+#ifdef HANDLE_RANDOMIZATION
+#define NEXT_DYNAMIC_INDEX 2
+#define MIN_DEPS_COUNT 2
+#define NAME_INDEX_ZERO 0
+#define NAME_INDEX_ONE 1
+#define NAME_INDEX_TWO 2
+#define NAME_INDEX_THREE 3
+#define TLS_CNT_INCREASE 3
+#define INVALID_FD_INHIBIT_FURTHER_SEARCH (-2)
+#endif
+
+#define PARENTS_BASE_CAPACITY 8
+#define RELOC_CAN_SEARCH_DSO_BASE_CAPACITY 32
+#define ANON_NAME_MAX_LEN 70
+
+#define KPMD_SIZE (1UL << 21)
+#define HUGEPAGES_SUPPORTED_STR_SIZE (32)
+
+#ifdef UNIT_TEST_STATIC
+    #define UT_STATIC
+#else
+    #define UT_STATIC static
+#endif
 
 struct debug {
 	int ver;
@@ -47,76 +98,20 @@ struct debug {
 	void *base;
 };
 
-struct td_index {
-	size_t args[2];
-	struct td_index *next;
-};
-
-struct dso {
-#if DL_FDPIC
-	struct fdpic_loadmap *loadmap;
-#else
-	unsigned char *base;
-#endif
-	char *name;
-	size_t *dynv;
-	struct dso *next, *prev;
-
-	Phdr *phdr;
-	int phnum;
-	size_t phentsize;
-	Sym *syms;
-	Elf_Symndx *hashtab;
-	uint32_t *ghashtab;
-	int16_t *versym;
-	char *strings;
-	struct dso *syms_next, *lazy_next;
-	size_t *lazy, lazy_cnt;
-	unsigned char *map;
-	size_t map_len;
-	dev_t dev;
-	ino_t ino;
-	char relocated;
-	char constructed;
-	char kernel_mapped;
-	char mark;
-	char bfs_built;
-	char runtime_loaded;
-	struct dso **deps, *needed_by;
-	size_t ndeps_direct;
-	size_t next_dep;
-	pthread_t ctor_visitor;
-	char *rpath_orig, *rpath;
-	struct tls_module tls;
-	size_t tls_id;
-	size_t relro_start, relro_end;
-	uintptr_t *new_dtv;
-	unsigned char *new_tls;
-	struct td_index *td_index;
-	struct dso *fini_next;
-	char *shortname;
-#if DL_FDPIC
-	unsigned char *base;
-#else
-	struct fdpic_loadmap *loadmap;
+struct reserved_address_params {
+	void* start_addr;
+	size_t reserved_size;
+	bool must_use_reserved;
+	bool reserved_address_recursive;
+#ifdef LOAD_ORDER_RANDOMIZATION
+	struct dso *target;
 #endif
-	struct funcdesc {
-		void *addr;
-		size_t *got;
-	} *funcdescs;
-	size_t *got;
-	char buf[];
-};
-
-struct symdef {
-	Sym *sym;
-	struct dso *dso;
 };
 
-typedef void (*stage3_func)(size_t *, size_t *);
+typedef void (*stage3_func)(size_t *, size_t *, size_t *);
 
 static struct builtin_tls {
-	char c;
+	char c[8];
 	struct pthread pt;
 	void *space[16];
 } builtin_tls[1];
@@ -124,7 +119,7 @@ static struct builtin_tls {
 
 #define ADDEND_LIMIT 4096
 static size_t *saved_addends, *apply_addends_to;
-
+static bool g_is_asan;
 static struct dso ldso;
 static struct dso *head, *tail, *fini_head, *syms_tail, *lazy_head;
 static char *env_path, *sys_path;
@@ -159,17 +154,213 @@ extern hidden void (*const __init_array_end)(void), (*const __fini_array_end)(vo
 
 weak_alias(__init_array_start, __init_array_end);
 weak_alias(__fini_array_start, __fini_array_end);
+#ifdef DFX_SIGNAL_LIBC
+UT_STATIC void __InstallSignalHandler()
+{
+}
+weak_alias(__InstallSignalHandler, DFX_InstallSignalHandler);
+#endif
+
+#ifdef HANDLE_RANDOMIZATION
+static int do_dlclose(struct dso *p);
+#endif
+
+#ifdef LOAD_ORDER_RANDOMIZATION
+static bool map_library_header(struct loadtask *task);
+static bool task_map_library(struct loadtask *task, struct reserved_address_params *reserved_params);
+static bool load_library_header(struct loadtask *task);
+static void task_load_library(struct loadtask *task, struct reserved_address_params *reserved_params);
+static void preload_direct_deps(struct dso *p, ns_t *namespace, struct loadtasks *tasks);
+static void unmap_preloaded_sections(struct loadtasks *tasks);
+static void preload_deps(struct dso *p, struct loadtasks *tasks);
+static void run_loadtasks(struct loadtasks *tasks, struct reserved_address_params *reserved_params);
+UT_STATIC void assign_tls(struct dso *p);
+UT_STATIC void load_preload(char *s, ns_t *ns, struct loadtasks *tasks);
+static void open_library_by_path(const char *name, const char *s, struct loadtask *task, struct zip_info *z_info);
+static void handle_asan_path_open_by_task(int fd, const char *name, ns_t *namespace, struct loadtask *task, struct zip_info *z_info);
+#endif
+
+/* Sharing relro */
+static void handle_relro_sharing(struct dso *p, const dl_extinfo *extinfo, ssize_t *relro_fd_offset);
+
+/* asan path open */
+int handle_asan_path_open(int fd, const char *name, ns_t *namespace, char *buf, size_t buf_size);
+
+static void set_bss_vma_name(char *path_name, void *addr, size_t zeromap_size);
+
+static void find_and_set_bss_name(struct dso *p);
+
+/* add namespace function */
+static void get_sys_path(ns_configor *conf);
+static void dlclose_ns(struct dso *p);
+static bool get_app_path(char *path, size_t size)
+{
+	int l = 0;
+	l = readlink("/proc/self/exe", path, size);
+	if (l < 0 || l >= size) {
+		LD_LOGD("get_app_path readlink failed!");
+		return false;
+	}
+	path[l] = 0;
+	LD_LOGD("get_app_path path:%{public}s.", path);
+	return true;
+}
+
+static void init_default_namespace(struct dso *app)
+{
+	ns_t *default_ns = get_default_ns();
+	memset(default_ns, 0, sizeof *default_ns);
+	ns_set_name(default_ns, NS_DEFAULT_NAME);
+	if (env_path) ns_set_env_paths(default_ns, env_path);
+	ns_set_lib_paths(default_ns, sys_path);
+	ns_set_separated(default_ns, false);
+	app->namespace = default_ns;
+	ns_add_dso(default_ns, app);
+	LD_LOGD("init_default_namespace default_namespace:"
+			"nsname: default ,"
+			"lib_paths:%{public}s ,"
+			"env_path:%{public}s ,"
+			"separated: false.",
+			sys_path, env_path);
+	return;
+}
+
+UT_STATIC void set_ns_attrs(ns_t *ns, ns_configor *conf)
+{
+	if(!ns || !conf) {
+		return;
+	}
+
+	char *lib_paths, *asan_lib_paths, *permitted_paths, *asan_permitted_paths, *allowed_libs;
+
+	ns_set_separated(ns, conf->get_separated(ns->ns_name));
+
+	lib_paths = conf->get_lib_paths(ns->ns_name);
+	if (lib_paths) ns_set_lib_paths(ns, lib_paths);
+
+	asan_lib_paths = conf->get_asan_lib_paths(ns->ns_name);
+	if (asan_lib_paths) ns_set_asan_lib_paths(ns, asan_lib_paths);
+
+	permitted_paths = conf->get_permitted_paths(ns->ns_name);
+	if (permitted_paths) ns_set_permitted_paths(ns, permitted_paths);
+
+	asan_permitted_paths = conf->get_asan_permitted_paths(ns->ns_name);
+	if (asan_permitted_paths) ns_set_asan_permitted_paths(ns, asan_permitted_paths);
+
+	allowed_libs = conf->get_allowed_libs(ns->ns_name);
+	if (allowed_libs) ns_set_allowed_libs(ns, allowed_libs);
+
+	LD_LOGD("set_ns_attrs :"
+			"ns_name: %{public}s ,"
+			"separated:%{public}d ,"
+			"lib_paths:%{public}s ,"
+			"asan_lib_paths:%{public}s ,"
+			"permitted_paths:%{public}s ,"
+			"asan_permitted_paths:%{public}s ,"
+			"allowed_libs: %{public}s .",
+			ns->ns_name, ns->separated, ns->lib_paths, ns->asan_lib_paths, permitted_paths,
+			asan_permitted_paths, allowed_libs);
+}
+
+UT_STATIC void set_ns_inherits(ns_t *ns, ns_configor *conf)
+{
+	if(!ns || !conf) {
+		return;
+	}
 
-static int dl_strcmp(const char *l, const char *r)
+	strlist *inherits = conf->get_inherits(ns->ns_name);
+	if (inherits) {
+		for (size_t i=0; i<inherits->num; i++) {
+			ns_t *inherited_ns = find_ns_by_name(inherits->strs[i]);
+			if (inherited_ns) {
+				char *shared_libs = conf->get_inherit_shared_libs(ns->ns_name, inherited_ns->ns_name);
+				ns_add_inherit(ns, inherited_ns, shared_libs);
+				LD_LOGD("set_ns_inherits :"
+						"ns_name: %{public}s ,"
+						"separated:%{public}d ,"
+						"lib_paths:%{public}s ,"
+						"asan_lib_paths:%{public}s ,",
+						inherited_ns->ns_name, inherited_ns->separated, inherited_ns->lib_paths,
+						inherited_ns->asan_lib_paths);
+			}
+		}
+		strlist_free(inherits);
+	} else {
+		LD_LOGD("set_ns_inherits inherits is NULL!");
+	}
+}
+
+static void init_namespace(struct dso *app)
 {
-	for (; *l==*r && *l; l++, r++);
-	return *(unsigned char *)l - *(unsigned char *)r;
+	char app_path[PATH_MAX+1];
+	if (!get_app_path(app_path, sizeof app_path)) {
+		strcpy(app_path, app->name);
+	}
+	char *t = strrchr(app_path, '/');
+	if (t) {
+		*t = 0;
+	} else {
+		app_path[0] = '.';
+		app_path[1] = 0;
+	}
+
+	nslist *nsl = nslist_init();
+	ns_configor *conf = configor_init();
+	char file_path[sizeof "/etc/ld-musl-namespace-" + sizeof (LDSO_ARCH) + sizeof ".ini" + 1] = {0};
+	(void)snprintf(file_path, sizeof file_path, "/etc/ld-musl-namespace-%s.ini", LDSO_ARCH);
+	LD_LOGI("init_namespace file_path:%{public}s", file_path);
+	trace_marker_reset();
+	trace_marker_begin(HITRACE_TAG_MUSL, "parse linker config", file_path);
+	int ret = conf->parse(file_path, app_path);
+	if (ret < 0) {
+		LD_LOGE("init_namespace ini file parse failed!");
+		/* Init_default_namespace is required even if the ini file parsing fails */
+		if (!sys_path) get_sys_path(conf);
+		init_default_namespace(app);
+		configor_free();
+		trace_marker_end(HITRACE_TAG_MUSL);
+		return;
+	}
+
+	/* sys_path needs to be parsed through ini file */
+	if (!sys_path) get_sys_path(conf);
+	init_default_namespace(app);
+
+	/* Init default namespace */
+	ns_t *d_ns = get_default_ns();
+	set_ns_attrs(d_ns, conf);
+
+	/* Init other namespace */
+	if (!nsl) {
+		LD_LOGE("init nslist fail!");
+		configor_free();
+		trace_marker_end(HITRACE_TAG_MUSL);
+		return;
+	}
+	strlist *s_ns = conf->get_namespaces();
+	if (s_ns) {
+		for (size_t i=0; i<s_ns->num; i++) {
+			ns_t *ns = ns_alloc();
+			ns_set_name(ns, s_ns->strs[i]);
+			set_ns_attrs(ns, conf);
+			ns_add_dso(ns, app);
+			nslist_add_ns(ns);
+		}
+		strlist_free(s_ns);
+	} 
+	/* Set inherited namespace */
+	set_ns_inherits(d_ns, conf);
+	for (size_t i = 0; i < nsl->num; i++) {
+		set_ns_inherits(nsl->nss[i], conf);
+	}
+	configor_free();
+	trace_marker_end(HITRACE_TAG_MUSL);
+	return;
 }
-#define strcmp(l,r) dl_strcmp(l,r)
 
 /* Compute load address for a virtual address in a given dso. */
 #if DL_FDPIC
-static void *laddr(const struct dso *p, size_t v)
+void *laddr(const struct dso *p, size_t v)
 {
 	size_t j=0;
 	if (!p->loadmap) return p->base + v;
@@ -210,7 +401,9 @@ static void decode_vec(size_t *v, size_t *a, size_t cnt)
 	size_t i;
 	for (i=0; i<cnt; i++) a[i] = 0;
 	for (; v[0]; v+=2) if (v[0]-1<cnt-1) {
-		a[0] |= 1UL<<v[0];
+		if (v[0] < 8*sizeof(long)) {
+			a[0] |= 1UL<<v[0];
+		}
 		a[v[0]] = v[1];
 	}
 }
@@ -223,71 +416,323 @@ static int search_vec(size_t *v, size_t *r, size_t key)
 	return 1;
 }
 
-static uint32_t sysv_hash(const char *s0)
+UT_STATIC int check_vna_hash(Verdef *def, int16_t vsym, uint32_t vna_hash)
+{
+	int matched = 0;
+
+	vsym &= 0x7fff;
+	Verdef *verdef = def;
+	for(;;) {
+		if ((verdef->vd_ndx & 0x7fff) == vsym) {
+			if (vna_hash == verdef->vd_hash) {
+				matched = 1;
+			}
+			break;
+		}
+		if (matched) {
+			break;
+		}
+		if (verdef->vd_next == 0) {
+			break;
+		}
+		verdef = (Verdef *)((char *)verdef + verdef->vd_next);
+	}
+#if (LD_LOG_LEVEL & LD_LOG_DEBUG)
+	if (!matched) {
+		LD_LOGD("check_vna_hash no matched found. vsym=%{public}d vna_hash=%{public}x", vsym, vna_hash);
+	}
+#endif
+	return matched;
+}
+
+UT_STATIC int check_verinfo(Verdef *def, int16_t *versym, uint32_t index, struct verinfo *verinfo, char *strings)
+{
+	/* if the versym and verinfo is null , then not need version. */
+	if (!versym || !def) {
+		if (strlen(verinfo->v) == 0) {
+			return 1;
+		} else {
+			LD_LOGD("check_verinfo versym or def is null and verinfo->v exist, s:%{public}s v:%{public}s.",
+				verinfo->s, verinfo->v);
+			return 0;
+		}
+	}
+
+	int16_t vsym = versym[index];
+
+	/* find the verneed symbol. */
+	if (verinfo->use_vna_hash) {
+		if (vsym != VER_NDX_LOCAL && versym != VER_NDX_GLOBAL) {
+			return check_vna_hash(def, vsym, verinfo->vna_hash);
+		}
+	}
+
+	/* if the version length is zero and vsym not less than zero, then library hava default version symbol. */
+	if (strlen(verinfo->v) == 0) {
+		if (vsym >= 0) {
+			return 1;
+		} else {
+			LD_LOGD("check_verinfo not default version. vsym:%{public}d s:%{public}s", vsym, verinfo->s);
+			return 0;
+		}
+	}
+
+	/* find the version of symbol. */
+	vsym &= 0x7fff;
+	for (;;) {
+		if (!(def->vd_flags & VER_FLG_BASE) && (def->vd_ndx & 0x7fff) == vsym) {
+			break;
+		}
+		if (def->vd_next == 0) {
+			return 0;
+		}
+		def = (Verdef *)((char *)def + def->vd_next);
+	}
+
+	Verdaux *aux = (Verdaux *)((char *)def + def->vd_aux);
+
+	int ret = !strcmp(verinfo->v, strings + aux->vda_name);
+#if (LD_LOG_LEVEL & LD_LOG_DEBUG)
+	if (!ret) {
+		LD_LOGD("check_verinfo version not match. s=%{public}s v=%{public}s vsym=%{public}d vda_name=%{public}s",
+			verinfo->s, verinfo->v, vsym, strings + aux->vda_name);
+	}
+#endif
+	return ret;
+}
+
+static struct sym_info_pair sysv_hash(const char *s0)
 {
+	struct sym_info_pair s_info_p;
 	const unsigned char *s = (void *)s0;
 	uint_fast32_t h = 0;
 	while (*s) {
 		h = 16*h + *s++;
 		h ^= h>>24 & 0xf0;
 	}
-	return h & 0xfffffff;
+	s_info_p.sym_h = h & 0xfffffff;
+	s_info_p.sym_l = (char *)s - s0;
+	return s_info_p;
 }
 
-static uint32_t gnu_hash(const char *s0)
+struct sym_info_pair gnu_hash(const char *s0)
 {
+	struct sym_info_pair s_info_p;
 	const unsigned char *s = (void *)s0;
 	uint_fast32_t h = 5381;
 	for (; *s; s++)
 		h += h*32 + *s;
-	return h;
+	s_info_p.sym_h = h;
+	s_info_p.sym_l = (char *)s - s0;
+	return s_info_p;
 }
 
-static Sym *sysv_lookup(const char *s, uint32_t h, struct dso *dso)
+static Sym *sysv_lookup(struct verinfo *verinfo,  struct sym_info_pair s_info_p, struct dso *dso)
 {
 	size_t i;
+	uint32_t h = s_info_p.sym_h;
 	Sym *syms = dso->syms;
 	Elf_Symndx *hashtab = dso->hashtab;
 	char *strings = dso->strings;
 	for (i=hashtab[2+h%hashtab[0]]; i; i=hashtab[2+hashtab[0]+i]) {
-		if ((!dso->versym || dso->versym[i] >= 0)
-		    && (!strcmp(s, strings+syms[i].st_name)))
+		if ((!dso->versym || (dso->versym[i] & 0x7fff) >= 0)
+			&& (!memcmp(verinfo->s, strings+syms[i].st_name, s_info_p.sym_l))) {
+			if (!check_verinfo(dso->verdef, dso->versym, i, verinfo, dso->strings)) {
+				continue;
+			}
+
 			return syms+i;
+		}
+
 	}
+	LD_LOGD("sysv_lookup not find the symbol, "
+		"so:%{public}s s:%{public}s v:%{public}s use_vna_hash:%{public}d vna_hash:%{public}x",
+		dso->name, verinfo->s, verinfo->v, verinfo->use_vna_hash, verinfo->vna_hash);
 	return 0;
 }
 
-static Sym *gnu_lookup(uint32_t h1, uint32_t *hashtab, struct dso *dso, const char *s)
+static Sym *gnu_lookup(struct sym_info_pair s_info_p, uint32_t *hashtab, struct dso *dso, struct verinfo *verinfo)
 {
+	uint32_t h1 = s_info_p.sym_h;
 	uint32_t nbuckets = hashtab[0];
 	uint32_t *buckets = hashtab + 4 + hashtab[2]*(sizeof(size_t)/4);
 	uint32_t i = buckets[h1 % nbuckets];
 
-	if (!i) return 0;
+	if (!i) {
+		LD_LOGD("gnu_lookup symbol not found (bloom filter), so:%{public}s s:%{public}s", dso->name, verinfo->s);
+		return 0;
+	}
 
 	uint32_t *hashval = buckets + nbuckets + (i - hashtab[1]);
 
 	for (h1 |= 1; ; i++) {
 		uint32_t h2 = *hashval++;
-		if ((h1 == (h2|1)) && (!dso->versym || dso->versym[i] >= 0)
-		    && !strcmp(s, dso->strings + dso->syms[i].st_name))
+		if ((h1 == (h2|1)) && (!dso->versym || (dso->versym[i] & 0x7fff) >= 0)
+			&& !memcmp(verinfo->s, dso->strings + dso->syms[i].st_name, s_info_p.sym_l)) {
+			if (!check_verinfo(dso->verdef, dso->versym, i, verinfo, dso->strings)) {
+				continue;
+			}
+
 			return dso->syms+i;
+		}
+
 		if (h2 & 1) break;
 	}
 
+	LD_LOGD("gnu_lookup symbol not found, "
+		"so:%{public}s s:%{public}s v:%{public}s use_vna_hash:%{public}d vna_hash:%{public}x",
+		dso->name, verinfo->s, verinfo->v, verinfo->use_vna_hash, verinfo->vna_hash);
 	return 0;
 }
 
-static Sym *gnu_lookup_filtered(uint32_t h1, uint32_t *hashtab, struct dso *dso, const char *s, uint32_t fofs, size_t fmask)
+static bool check_sym_accessible(struct dso *dso, ns_t *ns)
+{
+	if (!dso || !dso->namespace || !ns) {
+		LD_LOGD("check_sym_accessible invalid parameter!");
+		return false;
+	}
+	if (dso->namespace == ns) {
+		return true;
+	}
+	for (int i = 0; i < dso->parents_count; i++) {
+		if (dso->parents[i]->namespace == ns) {
+			return true;
+		}
+	}
+	LD_LOGD(
+		"check_sym_accessible dso name [%{public}s] ns_name [%{public}s] not accessible!", dso->name, ns->ns_name);
+	return false;
+}
+
+static inline bool is_dso_accessible(struct dso *dso, ns_t *ns)
+{
+	if (dso->namespace == ns) {
+		return true;
+	}
+	for (int i = 0; i < dso->parents_count; i++) {
+		if (dso->parents[i]->namespace == ns) {
+			return true;
+		}
+	}
+	LD_LOGD(
+		"check_sym_accessible dso name [%{public}s] ns_name [%{public}s] not accessible!", dso->name, ns->ns_name);
+	return false;
+}
+
+static int find_dso_parent(struct dso *p, struct dso *target)
+{
+	int index = -1;
+	for (int i = 0; i < p->parents_count; i++) {
+		if (p->parents[i] == target) {
+			index = i;
+			break;
+		}
+	}
+	return index;
+}
+
+static void add_dso_parent(struct dso *p, struct dso *parent)
+{
+	int index = find_dso_parent(p, parent);
+	if (index != -1) {
+		return;
+	}
+	if (p->parents_count + 1 > p->parents_capacity) {
+		if (p->parents_capacity == 0) {
+			p->parents = (struct dso **)malloc(sizeof(struct dso *) * PARENTS_BASE_CAPACITY);
+			if (!p->parents) {
+				return;
+			}
+			p->parents_capacity = PARENTS_BASE_CAPACITY;
+		} else {
+			struct dso ** realloced = (struct dso **)realloc(
+				p->parents, sizeof(struct dso *) * (p->parents_capacity + PARENTS_BASE_CAPACITY));
+			if (!realloced) {
+				return;
+			}
+			p->parents = realloced;
+			p->parents_capacity += PARENTS_BASE_CAPACITY;
+		}
+	}
+	p->parents[p->parents_count] = parent;
+	p->parents_count++;
+}
+
+static void remove_dso_parent(struct dso *p, struct dso *parent)
+{
+	int index = find_dso_parent(p, parent);
+	if (index == -1) {
+		return;
+	}
+	int i;
+	for (i = 0; i < index; i++) {
+		p->parents[i] = p->parents[i];
+	}
+	for (i = index; i < p->parents_count - 1; i++) {
+		p->parents[i] = p->parents[i + 1];
+	}
+	p->parents_count--;
+}
+
+static void add_reloc_can_search_dso(struct dso *p, struct dso *can_search_so)
+{
+	if (p->reloc_can_search_dso_count + 1 > p->reloc_can_search_dso_capacity) {
+		if (p->reloc_can_search_dso_capacity == 0) {
+			p->reloc_can_search_dso_list =
+				(struct dso **)malloc(sizeof(struct dso *) * RELOC_CAN_SEARCH_DSO_BASE_CAPACITY);
+			if (!p->reloc_can_search_dso_list) {
+				return;
+			}
+			p->reloc_can_search_dso_capacity = RELOC_CAN_SEARCH_DSO_BASE_CAPACITY;
+		} else {
+			struct dso ** realloced = (struct dso **)realloc(
+				p->reloc_can_search_dso_list,
+				sizeof(struct dso *) * (p->reloc_can_search_dso_capacity + RELOC_CAN_SEARCH_DSO_BASE_CAPACITY));
+			if (!realloced) {
+				return;
+			}
+			p->reloc_can_search_dso_list = realloced;
+			p->reloc_can_search_dso_capacity += RELOC_CAN_SEARCH_DSO_BASE_CAPACITY;
+		}
+	}
+	p->reloc_can_search_dso_list[p->reloc_can_search_dso_count] = can_search_so;
+	p->reloc_can_search_dso_count++;
+}
+
+static void free_reloc_can_search_dso(struct dso *p)
 {
-	const size_t *bloomwords = (const void *)(hashtab+4);
-	size_t f = bloomwords[fofs & (hashtab[2]-1)];
-	if (!(f & fmask)) return 0;
+	if (p->reloc_can_search_dso_list) {
+		free(p->reloc_can_search_dso_list);
+		p->reloc_can_search_dso_list = NULL;
+		p->reloc_can_search_dso_count = 0;
+		p->reloc_can_search_dso_capacity = 0;
+	}
+}
 
-	f >>= (h1 >> hashtab[3]) % (8 * sizeof f);
-	if (!(f & 1)) return 0;
+/* The list of so that can be accessed during relocation include:
+ * - The is_global flag of the so is true which means accessible by default.
+ *   Global so includes exe, ld preload so and ldso.
+ * - We only check whether ns is accessible for the so if is_reloc_head_so_dep is true.
+ *
+ *   How to set is_reloc_head_so_dep:
+ *   When dlopen A, we set is_reloc_head_so_dep to true for
+ *   all direct and indirect dependent sos of A, including A itself. */
+static void add_can_search_so_list_in_dso(struct dso *dso_relocating, struct dso *start_check_dso) {
+	struct dso *p = start_check_dso;
+	for (; p; p = p->syms_next) {
+		if (p->is_global) {
+			add_reloc_can_search_dso(dso_relocating, p);
+			continue;
+		}
+
+		if (p->is_reloc_head_so_dep) {
+			if (dso_relocating->namespace && check_sym_accessible(p, dso_relocating->namespace)) {
+				add_reloc_can_search_dso(dso_relocating, p);
+			}
+		}
+	}
 
-	return gnu_lookup(h1, hashtab, dso, s);
+	return;
 }
 
 #define OK_TYPES (1<<STT_NOTYPE | 1<<STT_OBJECT | 1<<STT_FUNC | 1<<STT_COMMON | 1<<STT_TLS)
@@ -300,24 +745,84 @@ static Sym *gnu_lookup_filtered(uint32_t h1, uint32_t *hashtab, struct dso *dso,
 #if defined(__GNUC__)
 __attribute__((always_inline))
 #endif
-static inline struct symdef find_sym2(struct dso *dso, const char *s, int need_def, int use_deps)
+
+struct symdef find_sym_impl(
+	struct dso *dso, struct verinfo *verinfo, struct sym_info_pair s_info_p, int need_def, ns_t *ns)
+{
+	Sym *sym;
+	uint32_t *ght;
+	uint32_t h = 0;
+	uint32_t gh = s_info_p.sym_h;
+	uint32_t gho = gh / (8 * sizeof(size_t));
+	size_t ghm = 1ul << gh % (8 * sizeof(size_t));
+	struct symdef def = {0};
+	if (ns && !check_sym_accessible(dso, ns))
+		return def;
+
+	if ((ght = dso->ghashtab)) {
+		const size_t *bloomwords = (const void *)(ght + 4);
+		size_t f = bloomwords[gho & (ght[2] - 1)];
+		if (!(f & ghm))
+			return def;
+
+		f >>= (gh >> ght[3]) % (8 * sizeof f);
+		if (!(f & 1))
+			return def;
+
+		sym = gnu_lookup(s_info_p, ght, dso, verinfo);
+	} else {
+		if (!h)
+			s_info_p = sysv_hash(verinfo->s);
+
+		sym = sysv_lookup(verinfo, s_info_p, dso);
+	}
+
+	if (!sym)
+		return def;
+
+	if (!sym->st_shndx)
+		if (need_def || (sym->st_info & 0xf) == STT_TLS || ARCH_SYM_REJECT_UND(sym))
+			return def;
+
+	if (!sym->st_value)
+		if ((sym->st_info & 0xf) != STT_TLS)
+			return def;
+
+	if (!(1 << (sym->st_info & 0xf) & OK_TYPES))
+		return def;
+
+	if (!(1 << (sym->st_info >> 4) & OK_BINDS))
+		return def;
+
+	def.sym = sym;
+	def.dso = dso;
+	return def;
+}
+
+static inline struct symdef find_sym2(struct dso *dso, struct verinfo *verinfo, int need_def, int use_deps, ns_t *ns)
 {
-	uint32_t h = 0, gh = gnu_hash(s), gho = gh / (8*sizeof(size_t)), *ght;
+	struct sym_info_pair s_info_p = gnu_hash(verinfo->s);
+	uint32_t h = 0, gh = s_info_p.sym_h, gho = gh / (8*sizeof(size_t)), *ght;
 	size_t ghm = 1ul << gh % (8*sizeof(size_t));
 	struct symdef def = {0};
 	struct dso **deps = use_deps ? dso->deps : 0;
 	for (; dso; dso=use_deps ? *deps++ : dso->syms_next) {
 		Sym *sym;
+		if (ns && !check_sym_accessible(dso, ns)) {
+			continue;
+		}
 		if ((ght = dso->ghashtab)) {
-			sym = gnu_lookup_filtered(gh, ght, dso, s, gho, ghm);
+			GNU_HASH_FILTER(ght, ghm, gho)
+			sym = gnu_lookup(s_info_p, ght, dso, verinfo);
 		} else {
-			if (!h) h = sysv_hash(s);
-			sym = sysv_lookup(s, h, dso);
+			if (!h) s_info_p = sysv_hash(verinfo->s);
+			sym = sysv_lookup(verinfo, s_info_p, dso);
 		}
+
 		if (!sym) continue;
 		if (!sym->st_shndx)
 			if (need_def || (sym->st_info&0xf) == STT_TLS
-			    || ARCH_SYM_REJECT_UND(sym))
+				|| ARCH_SYM_REJECT_UND(sym))
 				continue;
 		if (!sym->st_value)
 			if ((sym->st_info&0xf) != STT_TLS)
@@ -331,32 +836,149 @@ static inline struct symdef find_sym2(struct dso *dso, const char *s, int need_d
 	return def;
 }
 
-static struct symdef find_sym(struct dso *dso, const char *s, int need_def)
+static inline struct symdef find_sym_by_deps(struct dso *dso, struct verinfo *verinfo, int need_def, ns_t *ns)
 {
-	return find_sym2(dso, s, need_def, 0);
+	struct sym_info_pair s_info_p = gnu_hash(verinfo->s);
+	uint32_t h = 0, gh = s_info_p.sym_h, gho = gh / (8*sizeof(size_t)), *ght;
+	size_t ghm = 1ul << gh % (8*sizeof(size_t));
+	struct symdef def = {0};
+	struct dso **deps = dso->deps;
+	for (; dso; dso=*deps++) {
+		Sym *sym;
+		if (!is_dso_accessible(dso, ns)) {
+			continue;
+		}
+		if ((ght = dso->ghashtab)) {
+			GNU_HASH_FILTER(ght, ghm, gho)
+			sym = gnu_lookup(s_info_p, ght, dso, verinfo);
+		} else {
+			if (!h) s_info_p = sysv_hash(verinfo->s);
+			sym = sysv_lookup(verinfo, s_info_p, dso);
+		}
+
+		if (!sym) continue;
+		if (!sym->st_shndx)
+			if (need_def || (sym->st_info&0xf) == STT_TLS
+				|| ARCH_SYM_REJECT_UND(sym))
+				continue;
+		if (!sym->st_value)
+			if ((sym->st_info&0xf) != STT_TLS)
+				continue;
+		if (!(1<<(sym->st_info&0xf) & OK_TYPES)) continue;
+		if (!(1<<(sym->st_info>>4) & OK_BINDS)) continue;
+		def.sym = sym;
+		def.dso = dso;
+		break;
+	}
+	return def;
 }
 
-static void do_relocs(struct dso *dso, size_t *rel, size_t rel_size, size_t stride)
+static inline struct symdef find_sym_by_saved_so_list(
+	int sym_type, struct dso *dso, struct verinfo *verinfo, int need_def, struct dso *dso_relocating)
 {
-	unsigned char *base = dso->base;
-	Sym *syms = dso->syms;
-	char *strings = dso->strings;
-	Sym *sym;
-	const char *name;
-	void *ctx;
-	int type;
-	int sym_index;
-	struct symdef def;
-	size_t *reloc_addr;
-	size_t sym_val;
-	size_t tls_val;
-	size_t addend;
-	int skip_relative = 0, reuse_addends = 0, save_slot = 0;
-
-	if (dso == &ldso) {
-		/* Only ldso's REL table needs addend saving/reuse. */
-		if (rel == apply_addends_to)
-			reuse_addends = 1;
+	struct sym_info_pair s_info_p = gnu_hash(verinfo->s);
+	uint32_t h = 0, gh = s_info_p.sym_h, gho = gh / (8 * sizeof(size_t)), *ght;
+	size_t ghm = 1ul << gh % (8 * sizeof(size_t));
+	struct symdef def = {0};
+	// skip head dso.
+	int start_search_index = sym_type==REL_COPY ? 1 : 0;
+	struct dso *dso_searching = 0;
+	for (int i = start_search_index; i < dso_relocating->reloc_can_search_dso_count; i++) {
+		dso_searching = dso_relocating->reloc_can_search_dso_list[i];
+		Sym *sym;
+		if ((ght = dso_searching->ghashtab)) {
+			GNU_HASH_FILTER(ght, ghm, gho)
+			sym = gnu_lookup(s_info_p, ght, dso_searching, verinfo);
+		} else {
+			if (!h) s_info_p = sysv_hash(verinfo->s);
+			sym = sysv_lookup(verinfo, s_info_p, dso_searching);
+		}
+		if (!sym) continue;
+		if (!sym->st_shndx)
+			if (need_def || (sym->st_info&0xf) == STT_TLS
+				|| ARCH_SYM_REJECT_UND(sym))
+				continue;
+		if (!sym->st_value)
+			if ((sym->st_info&0xf) != STT_TLS)
+				continue;
+		if (!(1<<(sym->st_info&0xf) & OK_TYPES)) continue;
+		if (!(1<<(sym->st_info>>4) & OK_BINDS)) continue;
+		def.sym = sym;
+		def.dso = dso_searching;
+		break;
+	}
+	return def;
+}
+
+static struct symdef find_sym(struct dso *dso, const char *s, int need_def)
+{
+	struct verinfo verinfo = { .s = s, .v = "", .use_vna_hash = false };
+	return find_sym2(dso, &verinfo, need_def, 0, NULL);
+}
+
+static bool get_vna_hash(struct dso *dso, int sym_index, uint32_t *vna_hash)
+{
+	if (!dso->versym || !dso->verneed) {
+		return false;
+	}
+
+	uint16_t vsym = dso->versym[sym_index];
+	if (vsym == VER_NDX_LOCAL || vsym == VER_NDX_GLOBAL) {
+		return false;
+	}
+
+	bool result = false;
+	Verneed *verneed = dso->verneed;
+	Vernaux *vernaux;
+	vsym &= 0x7fff;
+
+	for(;;) {
+		vernaux = (Vernaux *)((char *)verneed + verneed->vn_aux);
+
+		for (size_t cnt = 0; cnt < verneed->vn_cnt; cnt++) {
+			if ((vernaux->vna_other & 0x7fff) == vsym) {
+				result = true;
+				*vna_hash = vernaux->vna_hash;
+				break;
+			}
+
+			vernaux = (Vernaux *)((char *)vernaux + vernaux->vna_next);
+		}
+
+		if (result) {
+			break;
+		}
+
+		if (verneed->vn_next == 0) {
+			break;
+		}
+
+		verneed = (Verneed *)((char *)verneed + verneed->vn_next);
+	}
+	return result;
+}
+
+static void do_relocs(struct dso *dso, size_t *rel, size_t rel_size, size_t stride)
+{
+	unsigned char *base = dso->base;
+	Sym *syms = dso->syms;
+	char *strings = dso->strings;
+	Sym *sym;
+	const char *name;
+	void *ctx;
+	int type;
+	int sym_index;
+	struct symdef def;
+	size_t *reloc_addr;
+	size_t sym_val;
+	size_t tls_val;
+	size_t addend;
+	int skip_relative = 0, reuse_addends = 0, save_slot = 0;
+
+	if (dso == &ldso) {
+		/* Only ldso's REL table needs addend saving/reuse. */
+		if (rel == apply_addends_to)
+			reuse_addends = 1;
 		skip_relative = 1;
 	}
 
@@ -386,11 +1008,22 @@ static void do_relocs(struct dso *dso, size_t *rel, size_t rel_size, size_t stri
 			sym = syms + sym_index;
 			name = strings + sym->st_name;
 			ctx = type==REL_COPY ? head->syms_next : head;
-			def = (sym->st_info>>4) == STB_LOCAL
-				? (struct symdef){ .dso = dso, .sym = sym }
-				: find_sym(ctx, name, type==REL_PLT);
+			struct verinfo vinfo = { .s = name, .v = "" };
+			vinfo.use_vna_hash = get_vna_hash(dso, sym_index, &vinfo.vna_hash);
+			if (dso->cache_sym_index == sym_index) {
+				def = (struct symdef){ .dso = dso->cache_dso, .sym = dso->cache_sym };
+			} else {
+				def = (sym->st_info>>4) == STB_LOCAL
+					? (struct symdef){ .dso = dso, .sym = sym }
+					: dso != &ldso ? find_sym_by_saved_so_list(type, ctx, &vinfo, type==REL_PLT, dso)
+					: find_sym2(ctx, &vinfo, type==REL_PLT, 0, dso->namespace);
+				dso->cache_sym_index = sym_index;
+				dso->cache_dso = def.dso;
+				dso->cache_sym = def.sym;
+			}
+
 			if (!def.sym && (sym->st_shndx != SHN_UNDEF
-			    || sym->st_info>>4 != STB_WEAK)) {
+				|| sym->st_info>>4 != STB_WEAK)) {
 				if (dso->lazy && (type==REL_PLT || type==REL_GOT)) {
 					dso->lazy[3*dso->lazy_cnt+0] = rel[0];
 					dso->lazy[3*dso->lazy_cnt+1] = rel[1];
@@ -398,6 +1031,9 @@ static void do_relocs(struct dso *dso, size_t *rel, size_t rel_size, size_t stri
 					dso->lazy_cnt++;
 					continue;
 				}
+				LD_LOGE("relocating failed: symbol not found. "
+					"dso=%{public}s s=%{public}s use_vna_hash=%{public}d van_hash=%{public}x",
+					dso->name, name, vinfo.use_vna_hash, vinfo.vna_hash);
 				error("Error relocating %s: %s: symbol not found",
 					dso->name, name);
 				if (runtime) longjmp(*rtld_fail, 1);
@@ -413,7 +1049,7 @@ static void do_relocs(struct dso *dso, size_t *rel, size_t rel_size, size_t stri
 		tls_val = def.sym ? def.sym->st_value : 0;
 
 		if ((type == REL_TPOFF || type == REL_TPOFF_NEG)
-		    && def.dso->tls_id > static_tls_cnt) {
+			&& def.dso->tls_id > static_tls_cnt) {
 			error("Error relocating %s: %s: initial-exec TLS "
 				"resolves to dynamic definition in %s",
 				dso->name, name, def.dso->name);
@@ -577,7 +1213,7 @@ static ssize_t read_loop(int fd, void *p, size_t n)
 	return n;
 }
 
-static void *mmap_fixed(void *p, size_t n, int prot, int flags, int fd, off_t off)
+UT_STATIC void *mmap_fixed(void *p, size_t n, int prot, int flags, int fd, off_t off)
 {
 	static int no_map_fixed;
 	char *q;
@@ -606,23 +1242,117 @@ static void *mmap_fixed(void *p, size_t n, int prot, int flags, int fd, off_t of
 	return p;
 }
 
-static void unmap_library(struct dso *dso)
+UT_STATIC void unmap_library(struct dso *dso)
 {
 	if (dso->loadmap) {
 		size_t i;
 		for (i=0; i<dso->loadmap->nsegs; i++) {
 			if (!dso->loadmap->segs[i].p_memsz)
 				continue;
-			munmap((void *)dso->loadmap->segs[i].addr,
-				dso->loadmap->segs[i].p_memsz);
+			if (!is_dlclose_debug_enable()) {
+				munmap((void *)dso->loadmap->segs[i].addr,
+					dso->loadmap->segs[i].p_memsz);
+			} else {
+				(void)mprotect((void *)dso->loadmap->segs[i].addr,
+					dso->loadmap->segs[i].p_memsz, PROT_NONE);
+			}
 		}
 		free(dso->loadmap);
 	} else if (dso->map && dso->map_len) {
-		munmap(dso->map, dso->map_len);
+		if (!is_dlclose_debug_enable()) {
+			munmap(dso->map, dso->map_len);
+		} else {
+			mprotect(dso->map, dso->map_len, PROT_NONE);
+		}
+	}
+}
+
+UT_STATIC bool get_random(void *buf, size_t buflen)
+{
+	int ret;
+	int fd = open("/dev/urandom", O_RDONLY);
+	if (fd < 0) {
+		return false;
+	}
+
+	ret = read(fd, buf, buflen);
+	if (ret < 0) {
+		close(fd);
+		return false;
+	}
+
+	close(fd);
+	return true;
+}
+
+UT_STATIC void fill_random_data(void *buf, size_t buflen)
+{
+	uint64_t x;
+	int i;
+	int pos = 0;
+	struct timespec ts;
+	/* Try to use urandom to get the random number first */
+	if (!get_random(buf, buflen)) {
+		/* Can't get random number from /dev/urandom, generate from addr based on ASLR and time */
+		for (i = 1; i <= (buflen / sizeof(x)); i++) {
+			(void)clock_gettime(CLOCK_REALTIME, &ts);
+			x = (((uint64_t)get_random) << 32) ^ (uint64_t)fill_random_data ^ ts.tv_nsec;
+			memcpy((char *)buf + pos, &x, sizeof(x));
+			pos += sizeof(x);
+		}
+	}
+	return;
+}
+
+static bool get_transparent_hugepages_supported(void)
+{
+	int fd = -1;
+	ssize_t read_size = 0;
+	bool enable = false;
+	char buf[HUGEPAGES_SUPPORTED_STR_SIZE] = {'0'};
+
+	fd = open("/sys/kernel/mm/transparent_hugepage/enabled", O_RDONLY);
+	if (fd < 0)
+		goto done;
+
+	read_size = read(fd, buf, HUGEPAGES_SUPPORTED_STR_SIZE - 1);
+	if (read_size < 0)
+		goto close_fd;
+
+	buf[HUGEPAGES_SUPPORTED_STR_SIZE - 1] = '\0';
+	if (strstr(buf, "[never]") == NULL)
+		enable = true;
+
+close_fd:
+	close(fd);
+done:
+	return enable;
+}
+
+static size_t phdr_table_get_maxinum_alignment(Phdr *phdr_table, size_t phdr_count)
+{
+#if defined(__LP64__)
+	size_t maxinum_alignment = PAGE_SIZE;
+	size_t i = 0;
+
+	for (i = 0; i < phdr_count; ++i) {
+		const Phdr *phdr = &phdr_table[i];
+
+		/* p_align must be 0, 1, or a positive, integral power of two */
+		if ((phdr->p_type != PT_LOAD) || ((phdr->p_align & (phdr->p_align - 1)) != 0))
+			continue;
+
+		if (phdr->p_align > maxinum_alignment)
+			maxinum_alignment = phdr->p_align;
 	}
+
+	return maxinum_alignment;
+#else
+	return PAGE_SIZE;
+#endif
 }
 
-static void *map_library(int fd, struct dso *dso)
+UT_STATIC void *map_library(int fd, struct dso *dso, struct reserved_address_params *reserved_params)
 {
 	Ehdr buf[(896+sizeof(Ehdr))/sizeof(Ehdr)];
 	void *allocated_buf=0;
@@ -638,6 +1368,10 @@ static void *map_library(int fd, struct dso *dso)
 	size_t dyn=0;
 	size_t tls_image=0;
 	size_t i;
+	int map_flags = MAP_PRIVATE;
+	size_t start_addr;
+	size_t start_alignment = PAGE_SIZE;
+	bool hugepage_enabled = false;
 
 	ssize_t l = read(fd, buf, sizeof buf);
 	eh = buf;
@@ -737,16 +1471,66 @@ static void *map_library(int fd, struct dso *dso)
 	addr_min &= -PAGE_SIZE;
 	off_start &= -PAGE_SIZE;
 	map_len = addr_max - addr_min + off_start;
-	/* The first time, we map too much, possibly even more than
-	 * the length of the file. This is okay because we will not
-	 * use the invalid part; we just need to reserve the right
-	 * amount of virtual address space to map over later. */
-	map = DL_NOMMU_SUPPORT
-		? mmap((void *)addr_min, map_len, PROT_READ|PROT_WRITE|PROT_EXEC,
-			MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
-		: mmap((void *)addr_min, map_len, prot,
-			MAP_PRIVATE, fd, off_start);
-	if (map==MAP_FAILED) goto error;
+	start_addr = addr_min;
+
+	hugepage_enabled = get_transparent_hugepages_supported();
+	if (hugepage_enabled) {
+		size_t maxinum_alignment = phdr_table_get_maxinum_alignment(ph0, eh->e_phnum);
+
+		start_alignment = maxinum_alignment == KPMD_SIZE ? KPMD_SIZE : PAGE_SIZE;
+	}
+
+	if (reserved_params) {
+		if (map_len > reserved_params->reserved_size) {
+			if (reserved_params->must_use_reserved) {
+				goto error;
+			}
+		} else {
+			start_addr = ((size_t)reserved_params->start_addr - 1 + PAGE_SIZE) & -PAGE_SIZE;
+			map_flags |= MAP_FIXED;
+		}
+	}
+
+	/* we will find a mapping_align aligned address as the start of dso
+	 * so we need a tmp_map_len as map_len + mapping_align to make sure
+	 * we have enough space to shift the dso to the correct location. */
+	size_t mapping_align = start_alignment > LIBRARY_ALIGNMENT ? start_alignment : LIBRARY_ALIGNMENT;
+	size_t tmp_map_len = ALIGN(map_len, mapping_align) + mapping_align - PAGE_SIZE;
+
+	/* if reserved_params exists, we should use start_addr as prefered result to do the mmap operation */
+	if (reserved_params) {
+		map = DL_NOMMU_SUPPORT
+			? mmap((void *)start_addr, map_len, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
+			: mmap((void *)start_addr, map_len, prot, map_flags, fd, off_start);
+		if (map == MAP_FAILED) {
+			goto error;
+		}
+		if (reserved_params && map_len < reserved_params->reserved_size) {
+			reserved_params->reserved_size -= (map_len + (start_addr - (size_t)reserved_params->start_addr));
+			reserved_params->start_addr = (void *)((uint8_t *)map + map_len);
+		}
+	/* if reserved_params does not exist, we should use real_map as prefered result to do the mmap operation */
+	} else {
+		/* use tmp_map_len to mmap enough space for the dso with anonymous mapping */
+		unsigned char *temp_map = mmap((void *)NULL, tmp_map_len, PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+		if (temp_map == MAP_FAILED) {
+			goto error;
+		}
+
+		/* find the mapping_align aligned address */
+		unsigned char *real_map = (unsigned char*)ALIGN((uintptr_t)temp_map, mapping_align);
+
+		/* mummap the space we mmap before so that we can mmap correct space again */
+		munmap(temp_map, tmp_map_len);
+
+		map = DL_NOMMU_SUPPORT
+			? mmap(real_map, map_len, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
+			/* use map_len to mmap correct space for the dso with file mapping */
+			: mmap(real_map, map_len, prot, map_flags, fd, off_start);
+		if (map == MAP_FAILED) {
+			goto error;
+		}
+	}
 	dso->map = map;
 	dso->map_len = map_len;
 	/* If the loaded file is not relocatable and the requested address is
@@ -759,11 +1543,15 @@ static void *map_library(int fd, struct dso *dso)
 	dso->phdr = 0;
 	dso->phnum = 0;
 	for (ph=ph0, i=eh->e_phnum; i; i--, ph=(void *)((char *)ph+eh->e_phentsize)) {
+		if (ph->p_type == PT_OHOS_RANDOMDATA) {
+			fill_random_data((void *)(ph->p_vaddr + base), ph->p_memsz);
+			continue;
+		}
 		if (ph->p_type != PT_LOAD) continue;
 		/* Check if the programs headers are in this load segment, and
 		 * if so, record the address for use by dl_iterate_phdr. */
 		if (!dso->phdr && eh->e_phoff >= ph->p_offset
-		    && eh->e_phoff+phsize <= ph->p_offset+ph->p_filesz) {
+			&& eh->e_phoff+phsize <= ph->p_offset+ph->p_filesz) {
 			dso->phdr = (void *)(base + ph->p_vaddr
 				+ (eh->e_phoff-ph->p_offset));
 			dso->phnum = eh->e_phnum;
@@ -779,18 +1567,22 @@ static void *map_library(int fd, struct dso *dso)
 		if ((ph->p_vaddr & -PAGE_SIZE) != addr_min || DL_NOMMU_SUPPORT)
 			if (mmap_fixed(base+this_min, this_max-this_min, prot, MAP_PRIVATE|MAP_FIXED, fd, off_start) == MAP_FAILED)
 				goto error;
+		if ((ph->p_flags & PF_X) && (ph->p_align == KPMD_SIZE) && hugepage_enabled)
+			madvise(base + this_min, this_max - this_min, MADV_HUGEPAGE);
 		if (ph->p_memsz > ph->p_filesz && (ph->p_flags&PF_W)) {
 			size_t brk = (size_t)base+ph->p_vaddr+ph->p_filesz;
 			size_t pgbrk = brk+PAGE_SIZE-1 & -PAGE_SIZE;
+			size_t zeromap_size = (size_t)base+this_max-pgbrk;
 			memset((void *)brk, 0, pgbrk-brk & PAGE_SIZE-1);
-			if (pgbrk-(size_t)base < this_max && mmap_fixed((void *)pgbrk, (size_t)base+this_max-pgbrk, prot, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) == MAP_FAILED)
+			if (pgbrk-(size_t)base < this_max && mmap_fixed((void *)pgbrk, zeromap_size, prot, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) == MAP_FAILED)
 				goto error;
+			set_bss_vma_name(dso->name, (void *)pgbrk, zeromap_size);
 		}
 	}
 	for (i=0; ((size_t *)(base+dyn))[i]; i+=2)
 		if (((size_t *)(base+dyn))[i]==DT_TEXTREL) {
 			if (mprotect(map, map_len, PROT_READ|PROT_WRITE|PROT_EXEC)
-			    && errno != ENOSYS)
+				&& errno != ENOSYS)
 				goto error;
 			break;
 		}
@@ -834,7 +1626,7 @@ static int path_open(const char *name, const char *s, char *buf, size_t buf_size
 	}
 }
 
-static int fixup_rpath(struct dso *p, char *buf, size_t buf_size)
+UT_STATIC int fixup_rpath(struct dso *p, char *buf, size_t buf_size)
 {
 	size_t n, l;
 	const char *s, *t, *origin;
@@ -929,9 +1721,13 @@ static void decode_dyn(struct dso *p)
 		p->ghashtab = laddr(p, *dyn);
 	if (search_vec(p->dynv, dyn, DT_VERSYM))
 		p->versym = laddr(p, *dyn);
+	if (search_vec(p->dynv, dyn, DT_VERDEF))
+		p->verdef = laddr(p, *dyn);
+	if (search_vec(p->dynv, dyn, DT_VERNEED))
+		p->verneed = laddr(p, *dyn);
 }
 
-static size_t count_syms(struct dso *p)
+UT_STATIC size_t count_syms(struct dso *p)
 {
 	if (p->hashtab) return p->hashtab[1];
 
@@ -990,9 +1786,115 @@ static void makefuncdescs(struct dso *p)
 	}
 }
 
-static struct dso *load_library(const char *name, struct dso *needed_by)
+static void get_sys_path(ns_configor *conf)
+{ 
+	LD_LOGD("get_sys_path g_is_asan:%{public}d", g_is_asan);
+	/* Use ini file's system paths when Asan is not enabled */
+	if (!g_is_asan) {
+		sys_path = conf->get_sys_paths();
+	} else {
+		/* Use ini file's asan system paths when the Asan is enabled
+		 * Merge two strings when both sys_paths and asan_sys_paths are valid */
+		sys_path = conf->get_asan_sys_paths();
+		char *sys_path_default = conf->get_sys_paths();
+		if (!sys_path) {
+			sys_path = sys_path_default;
+		} else if (sys_path_default) {
+			size_t newlen = strlen(sys_path) + strlen(sys_path_default) + 2;
+			char *new_syspath = malloc(newlen);
+			memset(new_syspath, 0, newlen);
+			strcpy(new_syspath, sys_path);
+			strcat(new_syspath, ":");
+			strcat(new_syspath, sys_path_default);
+			sys_path = new_syspath;
+		}
+	}
+	if (!sys_path) sys_path = "/lib:/usr/local/lib:/usr/lib:/lib64";
+	LD_LOGD("get_sys_path sys_path:%{public}s", sys_path);
+}
+
+static struct dso *search_dso_by_name(const char *name, const ns_t *ns) {
+	LD_LOGD("search_dso_by_name name:%{public}s, ns_name:%{public}s", name, ns ? ns->ns_name: "NULL");
+	for (size_t i = 0; i < ns->ns_dsos->num; i++){
+		struct dso *p = ns->ns_dsos->dsos[i];
+		if (p->shortname && !strcmp(p->shortname, name)) {
+			LD_LOGD("search_dso_by_name found name:%{public}s, ns_name:%{public}s", name, ns ? ns->ns_name: "NULL");
+			return p;
+		}
+	}
+	return NULL;
+}
+
+static struct dso *search_dso_by_fstat(const struct stat *st, const ns_t *ns, uint64_t file_offset) {
+	LD_LOGD("search_dso_by_fstat ns_name:%{public}s", ns ? ns->ns_name : "NULL");
+	for (size_t i = 0; i < ns->ns_dsos->num; i++){
+		struct dso *p = ns->ns_dsos->dsos[i];
+		if (p->dev == st->st_dev && p->ino == st->st_ino && p->file_offset == file_offset) {
+			LD_LOGD("search_dso_by_fstat found dev:%{public}lu, ino:%{public}lu, ns_name:%{public}s",
+				st->st_dev, st->st_ino, ns ? ns->ns_name : "NULL");
+			return p;
+		}
+	}
+	return NULL;
+}
+
+static inline int app_has_same_name_so(const char *so_name, const ns_t *ns)
+{
+   int fd = -1;
+   /* Only check system app. */
+   if (((ns->flag & LOCAL_NS_PREFERED) != 0) && ns->lib_paths) {
+       char tmp_buf[PATH_MAX+1];
+       fd = path_open(so_name, ns->lib_paths, tmp_buf, sizeof tmp_buf);
+   }
+   return fd;
+}
+
+/* Find loaded so by name */
+static struct dso *find_library_by_name(const char *name, const ns_t *ns, bool check_inherited)
+{
+	LD_LOGD("find_library_by_name name:%{public}s, ns_name:%{public}s, check_inherited:%{public}d",
+		name,
+		ns ? ns->ns_name : "NULL",
+		!!check_inherited);
+	struct dso *p = search_dso_by_name(name, ns);
+	if (p) return p;
+	if (check_inherited && ns->ns_inherits) {
+		for (size_t i = 0; i < ns->ns_inherits->num; i++){
+			ns_inherit * inherit = ns->ns_inherits->inherits[i];
+			p = search_dso_by_name(name, inherit->inherited_ns);
+			if (p && is_sharable(inherit, name)) {
+			    if (app_has_same_name_so(name, ns) != -1) {
+			        return NULL;
+			    }
+			    return p;
+			}
+		}
+	}
+	return NULL;
+}
+/* Find loaded so by file stat */
+UT_STATIC struct dso *find_library_by_fstat(const struct stat *st, const ns_t *ns, bool check_inherited, uint64_t file_offset) {
+	LD_LOGD("find_library_by_fstat ns_name:%{public}s, check_inherited :%{public}d",
+		ns ? ns->ns_name : "NULL",
+		!!check_inherited);
+	struct dso *p = search_dso_by_fstat(st, ns, file_offset);
+	if (p) return p;
+	if (check_inherited && ns->ns_inherits) {
+		for (size_t i = 0; i < ns->ns_inherits->num; i++){
+			ns_inherit *inherit = ns->ns_inherits->inherits[i];
+			p = search_dso_by_fstat(st, inherit->inherited_ns, file_offset);
+			if (p && is_sharable(inherit, p->shortname)) return p;
+		}
+	}
+	return NULL;
+}
+
+#ifndef LOAD_ORDER_RANDOMIZATION
+/* add namespace function */
+struct dso *load_library(
+	const char *name, struct dso *needed_by, ns_t *namespace, bool check_inherited, struct reserved_address_params *reserved_params)
 {
-	char buf[2*NAME_MAX+2];
+	char buf[PATH_MAX+1];
 	const char *pathname;
 	unsigned char *map;
 	struct dso *p, temp_dso = {0};
@@ -1039,86 +1941,91 @@ static struct dso *load_library(const char *name, struct dso *needed_by)
 			tail->next = &ldso;
 			ldso.prev = tail;
 			tail = &ldso;
+			ldso.namespace = namespace;
+			ns_add_dso(namespace, &ldso);
 		}
 		return &ldso;
 	}
 	if (strchr(name, '/')) {
 		pathname = name;
-		fd = open(name, O_RDONLY|O_CLOEXEC);
+
+		if (!is_accessible(namespace, pathname, g_is_asan, check_inherited)) {
+			fd = -1;
+			LD_LOGD("load_library is_accessible return false,fd = -1");
+		} else {
+			fd = open(name, O_RDONLY|O_CLOEXEC);
+			LD_LOGD("load_library is_accessible return true, open file fd:%{public}d .", fd);
+		}
 	} else {
 		/* Search for the name to see if it's already loaded */
-		for (p=head->next; p; p=p->next) {
-			if (p->shortname && !strcmp(p->shortname, name)) {
-				return p;
-			}
+		/* Search in namespace */
+		p = find_library_by_name(name, namespace, check_inherited);
+		if (p) {
+			LD_LOGD("load_library find_library_by_name found p, return it!");
+			return p;
+		}
+		if (strlen(name) > NAME_MAX) {
+			LD_LOGE("load_library name exceeding the maximum length, return 0!");
+			return 0;
 		}
-		if (strlen(name) > NAME_MAX) return 0;
 		fd = -1;
-		if (env_path) fd = path_open(name, env_path, buf, sizeof buf);
-		for (p=needed_by; fd == -1 && p; p=p->needed_by) {
-			if (fixup_rpath(p, buf, sizeof buf) < 0)
+		if (namespace->env_paths) fd = path_open(name, namespace->env_paths, buf, sizeof buf);
+		for (p = needed_by; fd == -1 && p; p = p->needed_by) {
+			if (fixup_rpath(p, buf, sizeof buf) < 0) {
+				LD_LOGD("load_library Inhibit further search,fd = -2.");
 				fd = -2; /* Inhibit further search. */
-			if (p->rpath)
+			}
+			if (p->rpath) {
 				fd = path_open(name, p->rpath, buf, sizeof buf);
+				LD_LOGD("load_library  p->rpath path_open fd:%{public}d.", fd);
+			}
+
 		}
-		if (fd == -1) {
-			if (!sys_path) {
-				char *prefix = 0;
-				size_t prefix_len;
-				if (ldso.name[0]=='/') {
-					char *s, *t, *z;
-					for (s=t=z=ldso.name; *s; s++)
-						if (*s=='/') z=t, t=s;
-					prefix_len = z-ldso.name;
-					if (prefix_len < PATH_MAX)
-						prefix = ldso.name;
-				}
-				if (!prefix) {
-					prefix = "";
-					prefix_len = 0;
-				}
-				char etc_ldso_path[prefix_len + 1
-					+ sizeof "/etc/ld-musl-" LDSO_ARCH ".path"];
-				snprintf(etc_ldso_path, sizeof etc_ldso_path,
-					"%.*s/etc/ld-musl-" LDSO_ARCH ".path",
-					(int)prefix_len, prefix);
-				fd = open(etc_ldso_path, O_RDONLY|O_CLOEXEC);
-				if (fd>=0) {
-					size_t n = 0;
-					if (!fstat(fd, &st)) n = st.st_size;
-					if ((sys_path = malloc(n+1)))
-						sys_path[n] = 0;
-					if (!sys_path || read_loop(fd, sys_path, n)<0) {
-						free(sys_path);
-						sys_path = "";
-					}
-					close(fd);
-				} else if (errno != ENOENT) {
-					sys_path = "";
-				}
+		if (g_is_asan) {
+			fd = handle_asan_path_open(fd, name, namespace, buf, sizeof buf);
+			LD_LOGD("load_library handle_asan_path_open fd:%{public}d.", fd);
+		} else {
+			if (fd == -1 && namespace->lib_paths) {
+				fd = path_open(name, namespace->lib_paths, buf, sizeof buf);
+				LD_LOGD("load_library no asan lib_paths path_open fd:%{public}d.", fd);
 			}
-			if (!sys_path) sys_path = SYS_PATH_DFLT;
-			fd = path_open(name, sys_path, buf, sizeof buf);
 		}
 		pathname = buf;
+		LD_LOGD("load_library lib_paths pathname:%{public}s.", pathname);
+	}
+	if (fd < 0) {
+		if (!check_inherited || !namespace->ns_inherits) return 0;
+		/* Load lib in inherited namespace. Do not check inherited again.*/
+		for (size_t i = 0; i < namespace->ns_inherits->num; i++) {
+			ns_inherit *inherit = namespace->ns_inherits->inherits[i];
+			if (strchr(name, '/')==0 && !is_sharable(inherit, name)) continue;
+			p = load_library(name, needed_by, inherit->inherited_ns, false, reserved_params);
+			if (p) {
+				LD_LOGD("load_library search in inherited, found p ,inherited_ns name:%{public}s",
+						inherit->inherited_ns->ns_name);
+				return p;
+			}
+		}
+		return 0;
 	}
-	if (fd < 0) return 0;
 	if (fstat(fd, &st) < 0) {
 		close(fd);
+		LD_LOGE("load_library fstat < 0,return 0!");
 		return 0;
 	}
-	for (p=head->next; p; p=p->next) {
-		if (p->dev == st.st_dev && p->ino == st.st_ino) {
-			/* If this library was previously loaded with a
-			 * pathname but a search found the same inode,
-			 * setup its shortname so it can be found by name. */
-			if (!p->shortname && pathname != name)
-				p->shortname = strrchr(p->name, '/')+1;
-			close(fd);
-			return p;
-		}
+	/* Search in namespace */
+	p = find_library_by_fstat(&st, namespace, check_inherited, 0);
+	if (p) {
+		/* If this library was previously loaded with a
+		* pathname but a search found the same inode,
+		* setup its shortname so it can be found by name. */
+		if (!p->shortname && pathname != name)
+			p->shortname = strrchr(p->name, '/')+1;
+		close(fd);
+		LD_LOGD("load_library find_library_by_fstat, found p and return it!");
+		return p;
 	}
-	map = noload ? 0 : map_library(fd, &temp_dso);
+	map = noload ? 0 : map_library(fd, &temp_dso, reserved_params);
 	close(fd);
 	if (!map) return 0;
 
@@ -1128,9 +2035,9 @@ static struct dso *load_library(const char *name, struct dso *needed_by)
 	 * false positives from interposition-hack libraries. */
 	decode_dyn(&temp_dso);
 	if (find_sym(&temp_dso, "__libc_start_main", 1).sym &&
-	    find_sym(&temp_dso, "stdin", 1).sym) {
+		find_sym(&temp_dso, "stdin", 1).sym) {
 		unmap_library(&temp_dso);
-		return load_library("libc.so", needed_by);
+		return load_library("libc.so", needed_by, namespace, true, reserved_params);
 	}
 	/* Past this point, if we haven't reached runtime yet, ldso has
 	 * committed either to use the mapped library or to abort execution.
@@ -1189,6 +2096,12 @@ static struct dso *load_library(const char *name, struct dso *needed_by)
 	p->prev = tail;
 	tail = p;
 
+	/* Add dso to namespace */
+	p->namespace = namespace;
+	ns_add_dso(namespace, p);
+	if (runtime)
+		p->by_dlopen = 1;
+
 	if (DL_FDPIC) makefuncdescs(p);
 
 	if (ldd_mode) dprintf(1, "\t%s => %s (%p)\n", name, pathname, p->base);
@@ -1196,7 +2109,7 @@ static struct dso *load_library(const char *name, struct dso *needed_by)
 	return p;
 }
 
-static void load_direct_deps(struct dso *p)
+static void load_direct_deps(struct dso *p, ns_t *namespace, struct reserved_address_params *reserved_params)
 {
 	size_t i, cnt=0;
 
@@ -1220,7 +2133,8 @@ static void load_direct_deps(struct dso *p)
 		p->deps[cnt++] = q;
 	for (i=0; p->dynv[i]; i+=2) {
 		if (p->dynv[i] != DT_NEEDED) continue;
-		struct dso *dep = load_library(p->strings + p->dynv[i+1], p);
+		struct dso *dep = load_library(p->strings + p->dynv[i+1], p, namespace, true, reserved_params);
+		LD_LOGD("loading shared library %{public}s: (needed by %{public}s)", p->strings + p->dynv[i+1], p->name);
 		if (!dep) {
 			error("Error loading shared library %s: %m (needed by %s)",
 				p->strings + p->dynv[i+1], p->name);
@@ -1231,14 +2145,18 @@ static void load_direct_deps(struct dso *p)
 	}
 	p->deps[cnt] = 0;
 	p->ndeps_direct = cnt;
+	for (i = 0; i < p->ndeps_direct; i++) {
+		add_dso_parent(p->deps[i], p);
+	}
 }
 
-static void load_deps(struct dso *p)
+static void load_deps(struct dso *p, struct reserved_address_params *reserved_params)
 {
 	if (p->deps) return;
 	for (; p; p=p->next)
-		load_direct_deps(p);
+		load_direct_deps(p, p->namespace, reserved_params);
 }
+#endif
 
 static void extend_bfs_deps(struct dso *p)
 {
@@ -1291,7 +2209,8 @@ static void extend_bfs_deps(struct dso *p)
 		p->mark = 0;
 }
 
-static void load_preload(char *s)
+#ifndef LOAD_ORDER_RANDOMIZATION
+static void load_preload(char *s, ns_t *ns)
 {
 	int tmp;
 	char *z;
@@ -1300,10 +2219,11 @@ static void load_preload(char *s)
 		for (z=s; *z && !isspace(*z) && *z!=':'; z++);
 		tmp = *z;
 		*z = 0;
-		load_library(s, 0);
+		load_library(s, 0, ns, true, NULL);
 		*z = tmp;
 	}
 }
+#endif
 
 static void add_syms(struct dso *p)
 {
@@ -1345,11 +2265,146 @@ static void do_mips_relocs(struct dso *p, size_t *got)
 	}
 }
 
-static void reloc_all(struct dso *p)
+static uint8_t* sleb128_decoder(uint8_t* current, uint8_t* end, size_t* value)
+{    
+	size_t result = 0;
+	static const size_t size = CHAR_BIT * sizeof(result);
+
+	size_t shift = 0;
+	uint8_t byte;
+
+	do {
+		if (current >= end) {
+			a_crash();
+		}
+
+		byte = *current++;
+		result |= ((size_t)(byte & 127) << shift);
+		shift += 7;
+	} while (byte & 128);
+
+	if (shift < size && (byte & 64)) {
+		result |= -((size_t)(1) << shift);
+	}
+
+	*value = result;
+	
+	return current;
+}
+
+static void do_android_relocs(struct dso *p, size_t dt_name, size_t dt_size)
+{
+	size_t android_rel_addr = 0, android_rel_size = 0;
+	uint8_t *android_rel_curr, *android_rel_end;
+
+	search_vec(p->dynv, &android_rel_addr, dt_name);
+	search_vec(p->dynv, &android_rel_size, dt_size);
+
+	if (!android_rel_addr || (android_rel_size < 4)) {
+		return;
+	}
+
+	android_rel_curr = laddr(p, android_rel_addr);
+	if (memcmp(android_rel_curr, "APS2", ANDROID_REL_SIGN_SIZE)) {
+		return;
+	}
+
+	android_rel_curr += ANDROID_REL_SIGN_SIZE;
+	android_rel_size -= ANDROID_REL_SIGN_SIZE;
+
+	android_rel_end = android_rel_curr + android_rel_size;
+	
+	size_t relocs_num;
+	size_t rel[3] = {0};
+
+	android_rel_curr = sleb128_decoder(android_rel_curr, android_rel_end, &relocs_num);
+	android_rel_curr = sleb128_decoder(android_rel_curr, android_rel_end, &rel[0]);
+
+	for (size_t i = 0; i < relocs_num;) {
+
+		size_t group_size, group_flags;
+
+		android_rel_curr = sleb128_decoder(android_rel_curr, android_rel_end, &group_size);
+		android_rel_curr = sleb128_decoder(android_rel_curr, android_rel_end, &group_flags);
+
+		size_t group_r_offset_delta = 0;
+
+		if (group_flags & RELOCATION_GROUPED_BY_OFFSET_DELTA_FLAG) {
+			android_rel_curr = sleb128_decoder(android_rel_curr, android_rel_end, &group_r_offset_delta);
+		}
+		
+		if (group_flags & RELOCATION_GROUPED_BY_INFO_FLAG) {
+			android_rel_curr = sleb128_decoder(android_rel_curr, android_rel_end, &rel[1]);
+		}
+
+		const size_t addend_flags = group_flags & (RELOCATION_GROUP_HAS_ADDEND_FLAG | RELOCATION_GROUPED_BY_ADDEND_FLAG);
+
+		if (addend_flags == RELOCATION_GROUP_HAS_ADDEND_FLAG) {
+		} else if (addend_flags == (RELOCATION_GROUP_HAS_ADDEND_FLAG | RELOCATION_GROUPED_BY_ADDEND_FLAG)) {
+			size_t addend;
+			android_rel_curr = sleb128_decoder(android_rel_curr, android_rel_end, &addend);
+			rel[2] += addend;
+		} else {
+			rel[2] = 0;
+		}
+
+		for (size_t j = 0; j < group_size; j++) {
+			if (group_flags & RELOCATION_GROUPED_BY_OFFSET_DELTA_FLAG) {
+				rel[0] += group_r_offset_delta;
+			} else {
+				size_t offset_detla;
+				android_rel_curr = sleb128_decoder(android_rel_curr, android_rel_end, &offset_detla);
+
+				rel[0] += offset_detla;
+			}
+
+			if ((group_flags & RELOCATION_GROUPED_BY_INFO_FLAG) == 0) {
+				android_rel_curr = sleb128_decoder(android_rel_curr, android_rel_end, &rel[1]);
+			}
+
+			if (addend_flags == RELOCATION_GROUP_HAS_ADDEND_FLAG) {
+				size_t addend;
+				android_rel_curr = sleb128_decoder(android_rel_curr, android_rel_end, &addend);
+				rel[2] += addend;
+			}
+
+			if (dt_name == DT_ANDROID_REL) {
+				do_relocs(p, rel, sizeof(size_t)*2, 2);
+			} else {
+				do_relocs(p, rel, sizeof(size_t)*3, 3);
+			}
+		}
+
+		i += group_size;
+	}
+}
+
+static void do_relr_relocs(struct dso *dso, size_t *relr, size_t relr_size)
+{
+	unsigned char *base = dso->base;
+	size_t *reloc_addr;
+	for (; relr_size; relr++, relr_size-=sizeof(size_t))
+		if ((relr[0]&1) == 0) {
+			reloc_addr = laddr(dso, relr[0]);
+			*reloc_addr++ += (size_t)base;
+		} else {
+			int i = 0;
+			for (size_t bitmap=relr[0]; (bitmap>>=1); i++)
+				if (bitmap&1)
+					reloc_addr[i] += (size_t)base;
+			reloc_addr += 8*sizeof(size_t)-1;
+		}
+}
+
+static void reloc_all(struct dso *p, const dl_extinfo *extinfo)
 {
+	ssize_t relro_fd_offset = 0;
 	size_t dyn[DYN_CNT];
 	for (; p; p=p->next) {
 		if (p->relocated) continue;
+		if (p != &ldso) {
+			add_can_search_so_list_in_dso(p, head);
+		}
 		decode_vec(p->dynv, dyn, DYN_CNT);
 		if (NEED_MIPS_GOT_RELOCS)
 			do_mips_relocs(p, laddr(p, dyn[DT_PLTGOT]));
@@ -1357,16 +2412,24 @@ static void reloc_all(struct dso *p)
 			2+(dyn[DT_PLTREL]==DT_RELA));
 		do_relocs(p, laddr(p, dyn[DT_REL]), dyn[DT_RELSZ], 2);
 		do_relocs(p, laddr(p, dyn[DT_RELA]), dyn[DT_RELASZ], 3);
+		if (!DL_FDPIC)
+			do_relr_relocs(p, laddr(p, dyn[DT_RELR]), dyn[DT_RELRSZ]);
+
+		do_android_relocs(p, DT_ANDROID_REL, DT_ANDROID_RELSZ);
+		do_android_relocs(p, DT_ANDROID_RELA, DT_ANDROID_RELASZ);
 
 		if (head != &ldso && p->relro_start != p->relro_end &&
-		    mprotect(laddr(p, p->relro_start), p->relro_end-p->relro_start, PROT_READ)
-		    && errno != ENOSYS) {
+			mprotect(laddr(p, p->relro_start), p->relro_end-p->relro_start, PROT_READ)
+			&& errno != ENOSYS) {
 			error("Error relocating %s: RELRO protection failed: %m",
 				p->name);
 			if (runtime) longjmp(*rtld_fail, 1);
 		}
+		/* Handle serializing/mapping the RELRO segment */
+		handle_relro_sharing(p, extinfo, &relro_fd_offset);
 
 		p->relocated = 1;
+		free_reloc_can_search_dso(p);
 	}
 }
 
@@ -1499,13 +2562,6 @@ static struct dso **queue_ctors(struct dso *dso)
 	}
 	queue[qpos] = 0;
 	for (i=0; i<qpos; i++) queue[i]->mark = 0;
-	for (i=0; i<qpos; i++)
-		if (queue[i]->ctor_visitor && queue[i]->ctor_visitor->tid < 0) {
-			error("State of %s is inconsistent due to multithreaded fork\n",
-				queue[i]->name);
-			free(queue);
-			if (runtime) longjmp(*rtld_fail, 1);
-		}
 
 	return queue;
 }
@@ -1539,7 +2595,13 @@ static void do_init_fini(struct dso **queue)
 		if (dyn[0] & (1<<DT_INIT_ARRAY)) {
 			size_t n = dyn[DT_INIT_ARRAYSZ]/sizeof(size_t);
 			size_t *fn = laddr(p, dyn[DT_INIT_ARRAY]);
+			if (p != &ldso) {
+				trace_marker_begin(HITRACE_TAG_MUSL, "calling constructors: ", p->name);
+			}
 			while (n--) ((void (*)(void))*fn++)();
+			if (p != &ldso) {
+				trace_marker_end(HITRACE_TAG_MUSL);
+			}
 		}
 
 		pthread_mutex_lock(&init_fini_lock);
@@ -1661,11 +2723,15 @@ hidden void __dls2(unsigned char *base, size_t *sp)
 	} else {
 		ldso.base = base;
 	}
+	size_t aux[AUX_CNT];
+	decode_vec(auxv, aux, AUX_CNT);
+	libc.page_size = aux[AT_PAGESZ];
 	Ehdr *ehdr = (void *)ldso.base;
 	ldso.name = ldso.shortname = "libc.so";
 	ldso.phnum = ehdr->e_phnum;
 	ldso.phdr = laddr(&ldso, ehdr->e_phoff);
 	ldso.phentsize = ehdr->e_phentsize;
+	ldso.is_global = true;
 	kernel_mapped_dso(&ldso);
 	decode_dyn(&ldso);
 
@@ -1688,7 +2754,7 @@ hidden void __dls2(unsigned char *base, size_t *sp)
 	saved_addends = addends;
 
 	head = &ldso;
-	reloc_all(&ldso);
+	reloc_all(&ldso, NULL);
 
 	ldso.relocated = 0;
 
@@ -1696,8 +2762,8 @@ hidden void __dls2(unsigned char *base, size_t *sp)
 	 * symbolically as a barrier against moving the address
 	 * load across the above relocation processing. */
 	struct symdef dls2b_def = find_sym(&ldso, "__dls2b", 0);
-	if (DL_FDPIC) ((stage3_func)&ldso.funcdescs[dls2b_def.sym-ldso.syms])(sp, auxv);
-	else ((stage3_func)laddr(&ldso, dls2b_def.sym->st_value))(sp, auxv);
+	if (DL_FDPIC) ((stage3_func)&ldso.funcdescs[dls2b_def.sym-ldso.syms])(sp, auxv, aux);
+	else ((stage3_func)laddr(&ldso, dls2b_def.sym->st_value))(sp, auxv, aux);
 }
 
 /* Stage 2b sets up a valid thread pointer, which requires relocations
@@ -1706,7 +2772,7 @@ hidden void __dls2(unsigned char *base, size_t *sp)
  * so that loads of the thread pointer and &errno can be pure/const and
  * thereby hoistable. */
 
-void __dls2b(size_t *sp, size_t *auxv)
+void __dls2b(size_t *sp, size_t *auxv, size_t *aux)
 {
 	/* Setup early thread pointer in builtin_tls for ldso/libc itself to
 	 * use during dynamic linking. If possible it will also serve as the
@@ -1720,8 +2786,8 @@ void __dls2b(size_t *sp, size_t *auxv)
 	}
 
 	struct symdef dls3_def = find_sym(&ldso, "__dls3", 0);
-	if (DL_FDPIC) ((stage3_func)&ldso.funcdescs[dls3_def.sym-ldso.syms])(sp, auxv);
-	else ((stage3_func)laddr(&ldso, dls3_def.sym->st_value))(sp, auxv);
+	if (DL_FDPIC) ((stage3_func)&ldso.funcdescs[dls3_def.sym-ldso.syms])(sp, auxv, aux);
+	else ((stage3_func)laddr(&ldso, dls3_def.sym->st_value))(sp, auxv, aux);
 }
 
 /* Stage 3 of the dynamic linker is called with the dynamic linker/libc
@@ -1729,10 +2795,9 @@ void __dls2b(size_t *sp, size_t *auxv)
  * process dependencies and relocations for the main application and
  * transfer control to its entry point. */
 
-void __dls3(size_t *sp, size_t *auxv)
+void __dls3(size_t *sp, size_t *auxv, size_t *aux)
 {
 	static struct dso app, vdso;
-	size_t aux[AUX_CNT];
 	size_t i;
 	char *env_preload=0;
 	char *replace_argv0=0;
@@ -1745,10 +2810,8 @@ void __dls3(size_t *sp, size_t *auxv)
 	/* Find aux vector just past environ[] and use it to initialize
 	 * global data that may be needed before we can make syscalls. */
 	__environ = envp;
-	decode_vec(auxv, aux, AUX_CNT);
 	search_vec(auxv, &__sysinfo, AT_SYSINFO);
 	__pthread_self()->sysinfo = __sysinfo;
-	libc.page_size = aux[AT_PAGESZ];
 	libc.secure = ((aux[0]&0x7800)!=0x7800 || aux[AT_UID]!=aux[AT_EUID]
 		|| aux[AT_GID]!=aux[AT_EGID] || aux[AT_SECURE]);
 
@@ -1757,7 +2820,9 @@ void __dls3(size_t *sp, size_t *auxv)
 		env_path = getenv("LD_LIBRARY_PATH");
 		env_preload = getenv("LD_PRELOAD");
 	}
-
+#ifdef OHOS_ENABLE_PARAMETER
+	InitParameterClient();
+#endif
 	/* If the main program was already loaded by the kernel,
 	 * AT_PHDR will point to some location other than the dynamic
 	 * linker's program headers. */
@@ -1784,7 +2849,7 @@ void __dls3(size_t *sp, size_t *auxv)
 		if (app.tls.size) app.tls.image = laddr(&app, tls_image);
 		if (interp_off) ldso.name = laddr(&app, interp_off);
 		if ((aux[0] & (1UL<<AT_EXECFN))
-		    && strncmp((char *)aux[AT_EXECFN], "/proc/", 6))
+			&& strncmp((char *)aux[AT_EXECFN], "/proc/", 6))
 			app.name = (char *)aux[AT_EXECFN];
 		else
 			app.name = argv[0];
@@ -1833,7 +2898,7 @@ void __dls3(size_t *sp, size_t *auxv)
 			dprintf(2, "%s: cannot load %s: %s\n", ldname, argv[0], strerror(errno));
 			_exit(1);
 		}
-		Ehdr *ehdr = map_library(fd, &app);
+		Ehdr *ehdr = map_library(fd, &app, NULL);
 		if (!ehdr) {
 			dprintf(2, "%s: %s: Not a valid dynamic program\n", ldname, argv[0]);
 			_exit(1);
@@ -1880,6 +2945,7 @@ void __dls3(size_t *sp, size_t *auxv)
 		}
 		argv[-3] = (void *)app.loadmap;
 	}
+	app.is_global = true;
 
 	/* Initial dso chain consists only of the app. */
 	head = tail = syms_tail = &app;
@@ -1888,15 +2954,55 @@ void __dls3(size_t *sp, size_t *auxv)
 	reclaim_gaps(&app);
 	reclaim_gaps(&ldso);
 
+	find_and_set_bss_name(&app);
+	find_and_set_bss_name(&ldso);
+
 	/* Load preload/needed libraries, add symbols to global namespace. */
 	ldso.deps = (struct dso **)no_deps;
-	if (env_preload) load_preload(env_preload);
- 	load_deps(&app);
-	for (struct dso *p=head; p; p=p->next)
-		add_syms(p);
+	/* Init g_is_asan */
+	g_is_asan = false;
+	LD_LOGD("__dls3 ldso.name:%{public}s.", ldso.name);
+	/* Through ldso Name to judge whether the Asan function is enabled */
+	if (strstr(ldso.name, "-asan")) {
+		g_is_asan = true;
+		LD_LOGD("__dls3 g_is_asan is true.");
+	}
+	/* Init all namespaces by config file. there is a default namespace always*/
+	init_namespace(&app);
 
-	/* Attach to vdso, if provided by the kernel, last so that it does
-	 * not become part of the global namespace.  */
+#ifdef LOAD_ORDER_RANDOMIZATION
+	struct loadtasks *tasks = create_loadtasks();
+	if (!tasks) {
+		_exit(1);
+	}
+	if (env_preload) {
+		load_preload(env_preload, get_default_ns(), tasks);
+	}
+	for (struct dso *q=head; q; q=q->next) {
+		q->is_global = true;
+	}
+	preload_deps(&app, tasks);
+	unmap_preloaded_sections(tasks);
+	shuffle_loadtasks(tasks);
+	run_loadtasks(tasks, NULL);
+	free_loadtasks(tasks);
+	assign_tls(app.next);
+#else
+	if (env_preload) load_preload(env_preload, get_default_ns());
+	for (struct dso *q=head; q; q=q->next) {
+		q->is_global = true;
+	}
+ 	load_deps(&app, NULL);
+#endif
+
+	/* Set is_reloc_head_so_dep to true for all direct and indirect dependent sos of app, including app self. */
+	for (struct dso *p=head; p; p=p->next) {
+		p->is_reloc_head_so_dep = true;
+		add_syms(p);
+	}
+
+	/* Attach to vdso, if provided by the kernel, last so that it does
+	 * not become part of the global namespace.  */
 	if (search_vec(auxv, &vdso_base, AT_SYSINFO_EHDR) && vdso_base) {
 		Ehdr *ehdr = (void *)vdso_base;
 		Phdr *phdr = vdso.phdr = (void *)(vdso_base + ehdr->e_phoff);
@@ -1916,6 +3022,8 @@ void __dls3(size_t *sp, size_t *auxv)
 		vdso.prev = tail;
 		tail->next = &vdso;
 		tail = &vdso;
+		vdso.namespace = get_default_ns();
+		ns_add_dso(vdso.namespace, &vdso);
 	}
 
 	for (i=0; app.dynv[i]; i+=2) {
@@ -1951,15 +3059,21 @@ void __dls3(size_t *sp, size_t *auxv)
 
 	/* The main program must be relocated LAST since it may contain
 	 * copy relocations which depend on libraries' relocations. */
-	reloc_all(app.next);
-	reloc_all(&app);
+	reloc_all(app.next, NULL);
+	reloc_all(&app, NULL);
+	for (struct dso *q=head; q; q=q->next) {
+		q->is_reloc_head_so_dep = false;
+	}
 
 	/* Actual copying to new TLS needs to happen after relocations,
 	 * since the TLS images might have contained relocated addresses. */
 	if (initial_tls != builtin_tls) {
-		if (__init_tp(__copy_tls(initial_tls)) < 0) {
+		pthread_t self = __pthread_self();
+		pthread_t td = __copy_tls(initial_tls);
+		if (__init_tp(td) < 0) {
 			a_crash();
 		}
+		td->tsd = self->tsd;
 	} else {
 		size_t tmp_tls_size = libc.tls_size;
 		pthread_t self = __pthread_self();
@@ -1971,6 +3085,10 @@ void __dls3(size_t *sp, size_t *auxv)
 		libc.tls_size = tmp_tls_size;
 	}
 
+	if (init_cfi_shadow(head, &ldso) == CFI_FAILED) {
+		error("[%s] init_cfi_shadow failed: %m", __FUNCTION__);
+	}
+
 	if (ldso_fail) _exit(127);
 	if (ldd_mode) _exit(0);
 
@@ -1996,6 +3114,9 @@ void __dls3(size_t *sp, size_t *auxv)
 
 	if (replace_argv0) argv[0] = replace_argv0;
 
+#ifdef DFX_SIGNAL_LIBC
+	DFX_InstallSignalHandler();
+#endif
 	errno = 0;
 
 	CRTJMP((void *)aux[AT_ENTRY], argv-1);
@@ -2024,7 +3145,79 @@ static void prepare_lazy(struct dso *p)
 	lazy_head = p;
 }
 
-void *dlopen(const char *file, int mode)
+static void *dlopen_post(struct dso* p, int mode) {
+	if (p == NULL) {
+		return p;
+	}
+
+	p->nr_dlopen++;
+	if (p->bfs_built) {
+		for (int i = 0; p->deps[i]; i++) {
+			p->deps[i]->nr_dlopen++;
+
+			if (mode & RTLD_NODELETE) {
+				p->deps[i]->flags |= DSO_FLAGS_NODELETE;
+			}
+		}
+	}
+
+#ifdef HANDLE_RANDOMIZATION
+	void *handle = assign_valid_handle(p);
+	if (handle == NULL) {
+		LD_LOGE("dlopen_post: generate random handle failed");
+		do_dlclose(p);
+	}
+
+	return handle;
+#endif
+
+	return p;
+}
+
+static char *dlopen_permitted_list[] =
+{
+	"default",
+	"ndk",
+};
+
+#define PERMITIED_TARGET  "nweb_ns"
+static bool in_permitted_list(char *caller, char *target)
+{
+	for (int i = 0; i < sizeof(dlopen_permitted_list)/sizeof(char*); i++) {
+		if (strcmp(dlopen_permitted_list[i], caller) == 0) {
+			return true;
+		}
+	}
+
+	if (strcmp(PERMITIED_TARGET, target) == 0) {
+		return true;
+	}
+
+	return false;
+}
+
+static bool is_permitted(const void *caller_addr, char *target)
+{
+	struct dso *caller;
+	ns_t *ns;
+	caller = (struct dso *)addr2dso((size_t)caller_addr);
+	if ((caller == NULL) || (caller->namespace == NULL)) {
+		LD_LOGE("caller ns get error");
+		return false;
+	}
+
+	ns = caller->namespace;
+	if (in_permitted_list(ns->ns_name, target) == false) {
+		LD_LOGE("caller ns: %{public}s have no permission, target is %{public}s", ns->ns_name, target);
+		return false;
+	}
+
+	return true;
+}
+
+/* add namespace function */
+static void *dlopen_impl(
+	const char *file, int mode, const char *namespace, const void *caller_addr, const dl_extinfo *extinfo)
 {
 	struct dso *volatile p, *orig_tail, *orig_syms_tail, *orig_lazy_head, *next;
 	struct tls_module *orig_tls_tail;
@@ -2033,15 +3226,52 @@ void *dlopen(const char *file, int mode)
 	int cs;
 	jmp_buf jb;
 	struct dso **volatile ctor_queue = 0;
+	ns_t *ns;
+	struct dso *caller;
+	bool reserved_address = false;
+	bool reserved_address_recursive = false;
+	struct reserved_address_params reserved_params = {0};
+#ifdef LOAD_ORDER_RANDOMIZATION
+	struct loadtasks *tasks = NULL;
+	struct loadtask *task = NULL;
+	bool is_task_appended = false;
+#endif
 
-	if (!file) return head;
+	if (!file) {
+		LD_LOGD("dlopen_impl file is null, return head.");
+		return dlopen_post(head, mode);
+	}
+
+	if (extinfo) {
+		reserved_address_recursive = extinfo->flag & DL_EXT_RESERVED_ADDRESS_RECURSIVE;
+		if (extinfo->flag & DL_EXT_RESERVED_ADDRESS) {
+			reserved_address = true;
+			reserved_params.start_addr = extinfo->reserved_addr;
+			reserved_params.reserved_size = extinfo->reserved_size;
+			reserved_params.must_use_reserved = true;
+			reserved_params.reserved_address_recursive = reserved_address_recursive;
+		} else if (extinfo->flag & DL_EXT_RESERVED_ADDRESS_HINT) {
+			reserved_address = true;
+			reserved_params.start_addr = extinfo->reserved_addr;
+			reserved_params.reserved_size = extinfo->reserved_size;
+			reserved_params.must_use_reserved = false;
+			reserved_params.reserved_address_recursive = reserved_address_recursive;
+		}
+	}
 
 	pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &cs);
 	pthread_rwlock_wrlock(&lock);
 	__inhibit_ptc();
+	trace_marker_reset();
+	trace_marker_begin(HITRACE_TAG_MUSL, "dlopen: ", file);
 
 	debug.state = RT_ADD;
 	_dl_debug_state();
+	/* When namespace does not exist, use caller's namespce
+	 * and when caller does not exist, use default namespce. */
+	caller = (struct dso *)addr2dso((size_t)caller_addr);
+	ns = find_ns_by_name(namespace);
+	if (!ns) ns = ((caller && caller->namespace) ? caller->namespace : get_default_ns());
 
 	p = 0;
 	if (shutting_down) {
@@ -2071,8 +3301,18 @@ void *dlopen(const char *file, int mode)
 			free(p->funcdescs);
 			if (p->rpath != p->rpath_orig)
 				free(p->rpath);
+			if (p->deps) {
+				for (int i = 0; i < p->ndeps_direct; i++) {
+					remove_dso_parent(p->deps[i], p);
+				}
+			}
 			free(p->deps);
+			dlclose_ns(p);
 			unmap_library(p);
+			if (p->parents) {
+				free(p->parents);
+			}
+			free_reloc_can_search_dso(p);
 			free(p);
 		}
 		free(ctor_queue);
@@ -2088,18 +3328,77 @@ void *dlopen(const char *file, int mode)
 		tail->next = 0;
 		p = 0;
 		goto end;
-	} else p = load_library(file, head);
+	} else {
+#ifdef LOAD_ORDER_RANDOMIZATION
+		tasks = create_loadtasks();
+		if (!tasks) {
+			LD_LOGE("dlopen_impl create loadtasks failed");
+			goto end;
+		}
+		task = create_loadtask(file, head, ns, true);
+		if (!task) {
+			LD_LOGE("dlopen_impl create loadtask failed");
+			goto end;
+		}
+		trace_marker_begin(HITRACE_TAG_MUSL, "loading: entry so", file);
+		if (!load_library_header(task)) {
+			error(noload ?
+				"Library %s is not already loaded" :
+				"Error loading shared library %s: %m",
+				file);
+			LD_LOGE("dlopen_impl load library header failed for %{public}s", task->name);
+			trace_marker_end(HITRACE_TAG_MUSL); // "loading: entry so" trace end.
+			goto end;
+		}
+		if (reserved_address) {
+			reserved_params.target = task->p;
+		}
+	}
+	if (!task->p) {
+		LD_LOGE("dlopen_impl load library failed for %{public}s", task->name);
+		error(noload ?
+			"Library %s is not already loaded" :
+			"Error loading shared library %s: %m",
+			file);
+		trace_marker_end(HITRACE_TAG_MUSL); // "loading: entry so" trace end.
+		goto end;
+	}
+	if (!task->isloaded) {
+		is_task_appended = append_loadtasks(tasks, task);
+	}
+	preload_deps(task->p, tasks);
+	unmap_preloaded_sections(tasks);
+	if (!reserved_address_recursive) {
+		shuffle_loadtasks(tasks);
+	}
+	run_loadtasks(tasks, reserved_address ? &reserved_params : NULL);
+	p = task->p;
+	if (!task->isloaded) {
+		assign_tls(p);
+	}
+	if (!is_task_appended) {
+		free_task(task);
+		task = NULL;
+	}
+	free_loadtasks(tasks);
+	tasks = NULL;
+#else
+		trace_marker_begin(HITRACE_TAG_MUSL, "loading: entry so", file);
+		p = load_library(file, head, ns, true, reserved_address ? &reserved_params : NULL);
+	}
 
 	if (!p) {
 		error(noload ?
 			"Library %s is not already loaded" :
 			"Error loading shared library %s: %m",
 			file);
+		trace_marker_end(HITRACE_TAG_MUSL); // "loading: entry so" trace end.
 		goto end;
 	}
-
 	/* First load handling */
-	load_deps(p);
+	load_deps(p, reserved_address && reserved_address_recursive ? &reserved_params : NULL);
+#endif
+	trace_marker_end(HITRACE_TAG_MUSL); // "loading: entry so" trace end.
 	extend_bfs_deps(p);
 	pthread_mutex_lock(&init_fini_lock);
 	int constructed = p->constructed;
@@ -2115,11 +3414,22 @@ void *dlopen(const char *file, int mode)
 		/* Make new symbols global, at least temporarily, so we can do
 		 * relocations. If not RTLD_GLOBAL, this is reverted below. */
 		add_syms(p);
-		for (i=0; p->deps[i]; i++)
+		/* Set is_reloc_head_so_dep to true for all direct and indirect dependent sos of p, including p self. */
+		p->is_reloc_head_so_dep = true;
+		for (i=0; p->deps[i]; i++) {
+			p->deps[i]->is_reloc_head_so_dep = true;
 			add_syms(p->deps[i]);
+		}
 	}
+	struct dso *reloc_head_so = p;
+	trace_marker_begin(HITRACE_TAG_MUSL, "linking: entry so", p->name);
 	if (!p->relocated) {
-		reloc_all(p);
+		reloc_all(p, extinfo);
+	}
+	trace_marker_end(HITRACE_TAG_MUSL);
+	reloc_head_so->is_reloc_head_so_dep = false;
+	for (size_t i=0; reloc_head_so->deps[i]; i++) {
+		reloc_head_so->deps[i]->is_reloc_head_so_dep = false;
 	}
 
 	/* If RTLD_GLOBAL was not specified, undo any new additions
@@ -2133,13 +3443,30 @@ void *dlopen(const char *file, int mode)
 	 * relocations resolved to symbol definitions that get removed. */
 	redo_lazy_relocs();
 
+	if (map_dso_to_cfi_shadow(p) == CFI_FAILED) {
+		error("[%s] map_dso_to_cfi_shadow failed: %m", __FUNCTION__);
+		longjmp(*rtld_fail, 1);
+	}
+
+	if (mode & RTLD_NODELETE) {
+		p->flags |= DSO_FLAGS_NODELETE;
+	}
+
 	update_tls_size();
 	if (tls_cnt != orig_tls_cnt)
 		install_new_tls();
 	orig_tail = tail;
+
+	p = dlopen_post(p, mode);
 end:
 	debug.state = RT_CONSISTENT;
 	_dl_debug_state();
+#ifdef LOAD_ORDER_RANDOMIZATION
+	if (!is_task_appended) {
+		free_task(task);
+	}
+	free_loadtasks(tasks);
+#endif
 	__release_ptc();
 	if (p) gencnt++;
 	pthread_rwlock_unlock(&lock);
@@ -2148,9 +3475,209 @@ end:
 		free(ctor_queue);
 	}
 	pthread_setcancelstate(cs, 0);
+	trace_marker_end(HITRACE_TAG_MUSL); // "dlopen: " trace end.
 	return p;
 }
 
+void *dlopen(const char *file, int mode)
+{
+	const void *caller_addr = __builtin_return_address(0);
+	musl_log_reset();
+	ld_log_reset();
+	LD_LOGI("dlopen file:%{public}s, mode:%{public}x ,caller_addr:%{public}p .", file, mode, caller_addr);
+	return dlopen_impl(file, mode, NULL, caller_addr, NULL);
+}
+
+void dlns_init(Dl_namespace *dlns, const char *name)
+{
+	if (!dlns) {
+		return;
+	}
+	if (!name) {
+		dlns->name[0] = 0;
+		return;
+	}
+
+	const void *caller_addr = __builtin_return_address(0);
+	if (is_permitted(caller_addr, name) == false) {
+		return;
+	}
+
+	snprintf(dlns->name, sizeof dlns->name, name);
+	LD_LOGI("dlns_init dlns->name:%{public}s .", dlns->name);
+}
+
+int dlns_get(const char *name, Dl_namespace *dlns)
+{
+	if (!dlns) {
+		LD_LOGE("dlns_get dlns is null.");
+		return EINVAL;
+	}
+	int ret = 0;
+	ns_t *ns = NULL;
+	pthread_rwlock_rdlock(&lock);
+	if (!name) {
+		struct dso *caller;
+		const void *caller_addr = __builtin_return_address(0);
+		caller = (struct dso *)addr2dso((size_t)caller_addr);
+		ns = ((caller && caller->namespace) ? caller->namespace : get_default_ns());
+		(void)snprintf(dlns->name, sizeof dlns->name, ns->ns_name);
+		LD_LOGI("dlns_get name is null, current dlns dlns->name:%{public}s.", dlns->name);
+	} else {
+		ns = find_ns_by_name(name);
+		if (ns) {
+			(void)snprintf(dlns->name, sizeof dlns->name, ns->ns_name);
+			LD_LOGI("dlns_get found ns, current dlns dlns->name:%{public}s.", dlns->name);
+		} else {
+			LD_LOGI("dlns_get not found ns! name:%{public}s.", name);
+			ret = ENOKEY;
+		}
+	}
+	pthread_rwlock_unlock(&lock);
+	return ret;
+}
+
+void *dlopen_ns(Dl_namespace *dlns, const char *file, int mode)
+{
+	const void *caller_addr = __builtin_return_address(0);
+	if (is_permitted(caller_addr, dlns->name) == false) {
+		return NULL;
+	}
+
+	musl_log_reset();
+	ld_log_reset();
+	LD_LOGI("dlopen_ns file:%{public}s, mode:%{public}x , caller_addr:%{public}p , dlns->name:%{public}s.",
+		file,
+		mode,
+		caller_addr,
+		dlns ? dlns->name : "NULL");
+	return dlopen_impl(file, mode, dlns->name, caller_addr, NULL);
+}
+
+void *dlopen_ns_ext(Dl_namespace *dlns, const char *file, int mode, const dl_extinfo *extinfo)
+{
+	const void *caller_addr = __builtin_return_address(0);
+	if (is_permitted(caller_addr, dlns->name) == false) {
+		return NULL;
+	}
+
+	musl_log_reset();
+	ld_log_reset();
+	LD_LOGI("dlopen_ns_ext file:%{public}s, mode:%{public}x , caller_addr:%{public}p , "
+			"dlns->name:%{public}s. , extinfo->flag:%{public}x",
+		file,
+		mode,
+		caller_addr,
+		dlns->name,
+		extinfo ? extinfo->flag : 0);
+	return dlopen_impl(file, mode, dlns->name, caller_addr, extinfo);
+}
+
+int dlns_create2(Dl_namespace *dlns, const char *lib_path, int flags)
+{
+	if (!dlns) {
+		LD_LOGE("dlns_create2 dlns is null.");
+		return EINVAL;
+	}
+	ns_t *ns;
+
+	pthread_rwlock_wrlock(&lock);
+	const void *caller_addr = __builtin_return_address(0);
+	if (is_permitted(caller_addr, dlns->name) == false) {
+		pthread_rwlock_unlock(&lock);
+		return EPERM;
+	}
+
+	ns = find_ns_by_name(dlns->name);
+	if (ns) {
+		LD_LOGE("dlns_create2 ns is exist.");
+		pthread_rwlock_unlock(&lock);
+		return EEXIST;
+	}
+	ns = ns_alloc();
+	if (!ns) {
+		LD_LOGE("dlns_create2 no memery.");
+		pthread_rwlock_unlock(&lock);
+		return ENOMEM;
+	}
+	ns_set_name(ns, dlns->name);
+	ns_set_flag(ns, flags);
+	ns_add_dso(ns, get_default_ns()->ns_dsos->dsos[0]); /* add main app to this namespace*/
+	nslist_add_ns(ns); /* add ns to list*/
+	ns_set_lib_paths(ns, lib_path);
+
+	if ((flags & CREATE_INHERIT_DEFAULT) != 0) {
+		ns_add_inherit(ns, get_default_ns(), NULL);
+	}
+
+	if ((flags & CREATE_INHERIT_CURRENT) != 0) {
+		struct dso *caller;
+		caller_addr = __builtin_return_address(0);
+		caller = (struct dso *)addr2dso((size_t)caller_addr);
+		if (caller && caller->namespace) {
+			ns_add_inherit(ns, caller->namespace, NULL);
+		}
+	}
+
+	LD_LOGI("dlns_create2:"
+			"ns_name: %{public}s ,"
+			"separated:%{public}d ,"
+			"lib_paths:%{public}s ",
+			ns->ns_name, ns->separated, ns->lib_paths);
+	pthread_rwlock_unlock(&lock);
+
+	return 0;
+}
+
+int dlns_create(Dl_namespace *dlns, const char *lib_path)
+{
+	LD_LOGI("dlns_create lib_paths:%{public}s", lib_path);
+	return dlns_create2(dlns, lib_path, CREATE_INHERIT_DEFAULT);
+}
+
+int dlns_inherit(Dl_namespace *dlns, Dl_namespace *inherited, const char *shared_libs)
+{
+	if (!dlns || !inherited) {
+		LD_LOGE("dlns_inherit dlns or inherited is null.");
+		return EINVAL;
+	}
+
+	pthread_rwlock_wrlock(&lock);
+	const void *caller_addr = __builtin_return_address(0);
+	if (is_permitted(caller_addr, dlns->name) == false) {
+		pthread_rwlock_unlock(&lock);
+		return EPERM;
+	}
+
+	ns_t* ns = find_ns_by_name(dlns->name);
+	ns_t* ns_inherited = find_ns_by_name(inherited->name);
+	if (!ns || !ns_inherited) {
+		LD_LOGE("dlns_inherit ns or ns_inherited is not found.");
+		pthread_rwlock_unlock(&lock);
+		return ENOKEY;
+	}
+	ns_add_inherit(ns, ns_inherited, shared_libs);
+	pthread_rwlock_unlock(&lock);
+
+	return 0;
+}
+
+static void dlclose_ns(struct dso *p)
+{
+	if (!p) return;
+	ns_t * ns = p->namespace;
+	if (!ns||!ns->ns_dsos) return;
+	for (size_t i=0; i<ns->ns_dsos->num; i++) {
+		if (p == ns->ns_dsos->dsos[i]) {
+			for (size_t j=i+1; j<ns->ns_dsos->num; j++) {
+				ns->ns_dsos->dsos[j-1] = ns->ns_dsos->dsos[j];
+			}
+			ns->ns_dsos->num--;
+			return;
+		}
+	}
+}
+
 hidden int __dl_invalid_handle(void *h)
 {
 	struct dso *p;
@@ -2159,55 +3686,63 @@ hidden int __dl_invalid_handle(void *h)
 	return 1;
 }
 
-static void *addr2dso(size_t a)
+void *addr2dso(size_t a)
 {
 	struct dso *p;
 	size_t i;
-	if (DL_FDPIC) for (p=head; p; p=p->next) {
-		i = count_syms(p);
-		if (a-(size_t)p->funcdescs < i*sizeof(*p->funcdescs))
-			return p;
-	}
 	for (p=head; p; p=p->next) {
-		if (DL_FDPIC && p->loadmap) {
-			for (i=0; i<p->loadmap->nsegs; i++) {
-				if (a-p->loadmap->segs[i].p_vaddr
-				    < p->loadmap->segs[i].p_memsz)
-					return p;
-			}
-		} else {
-			Phdr *ph = p->phdr;
-			size_t phcnt = p->phnum;
-			size_t entsz = p->phentsize;
-			size_t base = (size_t)p->base;
-			for (; phcnt--; ph=(void *)((char *)ph+entsz)) {
-				if (ph->p_type != PT_LOAD) continue;
-				if (a-base-ph->p_vaddr < ph->p_memsz)
-					return p;
-			}
-			if (a-(size_t)p->map < p->map_len)
-				return 0;
+		if (a < p->map || a - (size_t)p->map >= p->map_len) continue;
+		Phdr *ph = p->phdr;
+		size_t phcnt = p->phnum;
+		size_t entsz = p->phentsize;
+		size_t base = (size_t)p->base;
+		for (; phcnt--; ph=(void *)((char *)ph+entsz)) {
+			if (ph->p_type != PT_LOAD) continue;
+			if (a-base-ph->p_vaddr < ph->p_memsz)
+				return p;
 		}
+		if (a-(size_t)p->map < p->map_len)
+			return 0;
 	}
 	return 0;
 }
 
-static void *do_dlsym(struct dso *p, const char *s, void *ra)
+static void *do_dlsym(struct dso *p, const char *s, const char *v, void *ra)
 {
 	int use_deps = 0;
+	bool ra2dso = false;
+	ns_t *ns = NULL;
+	struct dso *caller = NULL;
 	if (p == head || p == RTLD_DEFAULT) {
 		p = head;
+		ra2dso = true;
 	} else if (p == RTLD_NEXT) {
 		p = addr2dso((size_t)ra);
 		if (!p) p=head;
 		p = p->next;
+		ra2dso = true;
+#ifndef HANDLE_RANDOMIZATION
 	} else if (__dl_invalid_handle(p)) {
 		return 0;
-	} else
+#endif
+	} else {
 		use_deps = 1;
-	struct symdef def = find_sym2(p, s, 0, use_deps);
+		ns = p->namespace;
+	}
+	if (ra2dso) {
+		caller = (struct dso *)addr2dso((size_t)ra);
+		if (caller && caller->namespace) {
+			ns = caller->namespace;
+		}
+	}
+	trace_marker_begin(HITRACE_TAG_MUSL, "dlsym: ", (s == NULL ? "(NULL)" : s));
+	struct verinfo verinfo = { .s = s, .v = v, .use_vna_hash = false };
+	struct symdef def = use_deps ? find_sym_by_deps(p, &verinfo, 0, ns) :
+		find_sym2(p, &verinfo, 0, use_deps, ns);
+	trace_marker_end(HITRACE_TAG_MUSL);
 	if (!def.sym) {
-		error("Symbol not found: %s", s);
+		LD_LOGE("do_dlsym failed: symbol not found. so=%{public}s s=%{public}s v=%{public}s", p->name, s, v);
+		error("Symbol not found: %s, version: %s", s, strlen(v) > 0 ? v : "null");
 		return 0;
 	}
 	if ((def.sym->st_info&0xf) == STT_TLS)
@@ -2217,112 +3752,377 @@ static void *do_dlsym(struct dso *p, const char *s, void *ra)
 	return laddr(def.dso, def.sym->st_value);
 }
 
-int dladdr(const void *addr_arg, Dl_info *info)
+extern int invalidate_exit_funcs(struct dso *p);
+
+static int dlclose_impl(struct dso *p)
 {
-	size_t addr = (size_t)addr_arg;
-	struct dso *p;
-	Sym *sym, *bestsym;
-	uint32_t nsym;
-	char *strings;
-	size_t best = 0;
-	size_t besterr = -1;
+	size_t n;
+	struct dso *d;
 
-	pthread_rwlock_rdlock(&lock);
-	p = addr2dso(addr);
-	pthread_rwlock_unlock(&lock);
+	if (__dl_invalid_handle(p))
+		return -1;
 
-	if (!p) return 0;
+	if (!p->by_dlopen) {
+		LD_LOGD("dlclose skip unload %{public}s because so isn't loaded by dlopen", p->name);
+		return -1;
+	}
 
-	sym = p->syms;
-	strings = p->strings;
-	nsym = count_syms(p);
+	/* dso is marked  as RTLD_NODELETE library, do nothing here. */
+	if ((p->flags & DSO_FLAGS_NODELETE) != 0) {
+		LD_LOGD("dlclose skip unload %{public}s because flags is RTLD_NODELETE", p->name);
+		return 0;
+	}
 
-	if (DL_FDPIC) {
-		size_t idx = (addr-(size_t)p->funcdescs)
-			/ sizeof(*p->funcdescs);
-		if (idx < nsym && (sym[idx].st_info&0xf) == STT_FUNC) {
-			best = (size_t)(p->funcdescs + idx);
-			bestsym = sym + idx;
-			besterr = 0;
-		}
+	if (--(p->nr_dlopen) > 0) {
+		LD_LOGD("dlclose skip unload %{public}s because nr_dlopen=%{public}d > 0", p->name, p->nr_dlopen);
+		return 0;
 	}
 
-	if (!best) for (; nsym; nsym--, sym++) {
-		if (sym->st_value
-		 && (1<<(sym->st_info&0xf) & OK_TYPES)
-		 && (1<<(sym->st_info>>4) & OK_BINDS)) {
-			size_t symaddr = (size_t)laddr(p, sym->st_value);
-			if (symaddr > addr || symaddr <= best)
-				continue;
-			best = symaddr;
-			bestsym = sym;
-			besterr = addr - symaddr;
-			if (addr == symaddr)
-				break;
+	if (p->parents_count > 0) {
+		LD_LOGD("dlclose skip unload %{public}s because parents_count=%{public}d > 0", p->name, p->parents_count);
+		return 0;
+	}
+
+	trace_marker_reset();
+	trace_marker_begin(HITRACE_TAG_MUSL, "dlclose", p->name);
+	/* call destructors if needed */
+	if (p->constructed) {
+		size_t dyn[DYN_CNT];
+		decode_vec(p->dynv, dyn, DYN_CNT);
+		if (dyn[0] & (1<<DT_FINI_ARRAY)) {
+			n = dyn[DT_FINI_ARRAYSZ] / sizeof(size_t);
+			size_t *fn = (size_t *)laddr(p, dyn[DT_FINI_ARRAY]) + n;
+			trace_marker_begin(HITRACE_TAG_MUSL, "calling destructors:", p->name);
+			while (n--)
+				((void (*)(void))*--fn)();
+			trace_marker_end(HITRACE_TAG_MUSL);
 		}
+		p->constructed = 0;
 	}
 
-	if (best && besterr > bestsym->st_size-1) {
-		best = 0;
-		bestsym = 0;
+	/* after destruct, invalidate atexit funcs which belong to this dso */
+#if (defined(FEATURE_ATEXIT_CB_PROTECT))
+	invalidate_exit_funcs(p);
+#endif
+
+	/* remove dso symbols from global list */
+	if (p->syms_next) {
+		for (d = head; d->syms_next != p; d = d->syms_next)
+			; /* NOP */
+		d->syms_next = p->syms_next;
+	} else if (p == syms_tail) {
+		for (d = head; d->syms_next != p; d = d->syms_next)
+			; /* NOP */
+		d->syms_next = NULL;
+		syms_tail = d;
 	}
 
-	info->dli_fname = p->name;
-	info->dli_fbase = p->map;
+	/* remove dso from lazy list if needed */
+	if (p == lazy_head) {
+		lazy_head = p->lazy_next;
+	} else if (p->lazy_next) {
+		for (d = lazy_head; d->lazy_next != p; d = d->lazy_next)
+			; /* NOP */
+		d->lazy_next = p->lazy_next;
+	}
 
-	if (!best) {
-		info->dli_sname = 0;
-		info->dli_saddr = 0;
-		return 1;
+	/* remove dso from fini list */
+	if (p == fini_head) {
+		fini_head = p->fini_next;
+	} else if (p->fini_next) {
+		for (d = fini_head; d->fini_next != p; d = d->fini_next)
+			; /* NOP */
+		d->fini_next = p->fini_next;
 	}
 
-	if (DL_FDPIC && (bestsym->st_info&0xf) == STT_FUNC)
-		best = (size_t)(p->funcdescs + (bestsym - p->syms));
-	info->dli_sname = strings + bestsym->st_name;
-	info->dli_saddr = (void *)best;
+	/* empty tls image */
+	if (p->tls.size != 0) {
+		p->tls.image = NULL;
+	}
 
-	return 1;
-}
+	/* remove dso from global dso list */
+	if (p == tail) {
+		tail = p->prev;
+		tail->next = NULL;
+	} else {
+		p->next->prev = p->prev;
+		p->prev->next = p->next;
+	}
 
-hidden void *__dlsym(void *restrict p, const char *restrict s, void *restrict ra)
-{
-	void *res;
-	pthread_rwlock_rdlock(&lock);
-	res = do_dlsym(p, s, ra);
-	pthread_rwlock_unlock(&lock);
-	return res;
-}
+	/* remove dso from namespace */
+	dlclose_ns(p);
 
-hidden void *__dlsym_redir_time64(void *restrict p, const char *restrict s, void *restrict ra)
-{
-#if _REDIR_TIME64
-	const char *suffix, *suffix2 = "";
-	char redir[36];
+	unmap_dso_from_cfi_shadow(p);
+	
+	if (p->lazy != NULL)
+		free(p->lazy);
+	if (p->deps) {
+		for (int i = 0; i < p->ndeps_direct; i++) {
+			remove_dso_parent(p->deps[i], p);
+		}
+	}
+	if (p->deps != no_deps)
+		free(p->deps);
+	LD_LOGD("dlclose unloading %{public}s @%{public}p", p->name, p);
+	unmap_library(p);
 
-	/* Map the symbol name to a time64 version of itself according to the
-	 * pattern used for naming the redirected time64 symbols. */
-	size_t l = strnlen(s, sizeof redir);
-	if (l<4 || l==sizeof redir) goto no_redir;
-	if (s[l-2]=='_' && s[l-1]=='r') {
-		l -= 2;
-		suffix2 = s+l;
+	if (p->parents) {
+		free(p->parents);
 	}
-	if (l<4) goto no_redir;
-	if (!strcmp(s+l-4, "time")) suffix = "64";
-	else suffix = "_time64";
 
-	/* Use the presence of the remapped symbol name in libc to determine
-	 * whether it's one that requires time64 redirection; replace if so. */
-	snprintf(redir, sizeof redir, "__%.*s%s%s", (int)l, s, suffix, suffix2);
-	if (find_sym(&ldso, redir, 1).sym) s = redir;
-no_redir:
-#endif
-	return __dlsym(p, s, ra);
+	free_reloc_can_search_dso(p);
+	if (p->tls.size == 0) {
+		free(p);
+	}
+	trace_marker_end(HITRACE_TAG_MUSL);
+
+	return 0;
 }
 
-int dl_iterate_phdr(int(*callback)(struct dl_phdr_info *info, size_t size, void *data), void *data)
+static char* dlclose_deps_black_list[] =
 {
-	struct dso *current;
+	"/system/lib/libhidebug.so",
+	"/system/lib64/libhidebug.so",
+	"/vendor/lib64/libhril_hdf.z.so"
+};
+
+static int do_dlclose(struct dso *p)
+{
+	bool ldclose_deps = true;
+
+	for (int i = 0; i < sizeof(dlclose_deps_black_list)/sizeof(char*); i++) {
+		if (!strcmp(dlclose_deps_black_list[i], p->name)) {
+			ldclose_deps = false;
+			break;
+		}
+	}
+
+	size_t deps_num;
+
+	for (deps_num = 0; p->deps[deps_num]; deps_num++);
+
+	struct dso **deps_bak = malloc(deps_num*sizeof(struct dso*));
+	if (deps_bak != NULL) {
+		memcpy(deps_bak, p->deps, deps_num*sizeof(struct dso*));
+	}
+
+	LD_LOGI("do_dlclose name=%{public}s count=%{public}d by_dlopen=%{public}d", p->name, p->nr_dlopen, p->by_dlopen);
+	dlclose_impl(p);
+
+	if (ldclose_deps) {
+		for (size_t i = 0; i < deps_num; i++) {
+			LD_LOGI("do_dlclose name=%{public}s count=%{public}d by_dlopen=%{public}d", deps_bak[i]->name, deps_bak[i]->nr_dlopen, deps_bak[i]->by_dlopen);
+			dlclose_impl(deps_bak[i]);
+		}
+	}
+
+	free(deps_bak);
+
+	return 0;
+}
+
+hidden int __dlclose(void *p)
+{
+	int rc;
+	pthread_rwlock_wrlock(&lock);
+	__inhibit_ptc();
+#ifdef HANDLE_RANDOMIZATION
+	struct dso *dso = find_dso_by_handle(p);
+	if (dso == NULL) {
+		errno = EINVAL;
+		error("Handle is invalid.");
+		LD_LOGE("Handle is not find.");
+		__release_ptc();
+		pthread_rwlock_unlock(&lock);
+		return -1;
+	}
+	rc = do_dlclose(dso);
+	if (!rc) {
+		struct dso *t = head;
+		for (; t && t != dso; t = t->next) {
+			;
+		}
+		if (t == NULL) {
+			remove_handle_node(p);
+		}
+	}
+#else
+	rc = do_dlclose(p);
+#endif
+	__release_ptc();
+	pthread_rwlock_unlock(&lock);
+	return rc;
+}
+
+static inline int sym_is_matched(const Sym* sym, size_t addr_offset_so) {
+	return sym->st_value &&
+		(1<<(sym->st_info&0xf) != STT_TLS) &&
+		(addr_offset_so >= sym->st_value) &&
+		(addr_offset_so < sym->st_value + sym->st_size);
+}
+
+static inline Sym* find_addr_by_elf(size_t addr_offset_so, struct dso *p) {
+	uint32_t nsym = p->hashtab[1];
+	Sym *sym = p->syms;
+	for (; nsym; nsym--, sym++) {
+		if (sym_is_matched(sym, addr_offset_so)) {
+			return sym;
+		}
+	}
+
+	return NULL;
+}
+
+static inline Sym* find_addr_by_gnu(size_t addr_offset_so, struct dso *p) {
+
+	size_t i, nsym, first_hash_sym_index;
+	uint32_t *hashval;
+	Sym *sym_tab = p->syms;
+	uint32_t *buckets= p->ghashtab + 4 + (p->ghashtab[2]*sizeof(size_t)/4);
+	// Points to the first defined symbol, all symbols before it are undefined.
+	first_hash_sym_index = buckets[0];
+	Sym *sym = &sym_tab[first_hash_sym_index];
+
+	// Get the location pointed by the last bucket.
+	for (i = nsym = 0; i < p->ghashtab[0]; i++) {
+		if (buckets[i] > nsym)
+			nsym = buckets[i];
+	}
+
+	for (i = first_hash_sym_index; i < nsym; i++) {
+		if (sym_is_matched(sym, addr_offset_so)) {
+			return sym;
+		}
+		sym++;
+	}
+
+	// Start traversing the hash list from the position pointed to by the last bucket.
+	if (nsym) {
+		hashval = buckets + p->ghashtab[0] + (nsym - p->ghashtab[1]);
+		do {
+			nsym++;
+			if (sym_is_matched(sym, addr_offset_so)) {
+				return sym;
+			}
+			sym++;
+		}
+		while (!(*hashval++ & 1));
+	}
+
+	return NULL;
+}
+
+
+int dladdr(const void *addr_arg, Dl_info *info)
+{
+	size_t addr = (size_t)addr_arg;
+	struct dso *p;
+	Sym *match_sym = NULL;
+	char *strings;
+
+	pthread_rwlock_rdlock(&lock);
+	p = addr2dso(addr);
+	pthread_rwlock_unlock(&lock);
+
+	if (!p) return 0;
+
+	strings = p->strings;
+	size_t addr_offset_so = addr - (size_t)p->base;
+
+	info->dli_fname = p->name;
+	info->dli_fbase = p->map;
+
+	if (p->ghashtab) {
+		match_sym = find_addr_by_gnu(addr_offset_so, p);
+
+	} else {
+		match_sym = find_addr_by_elf(addr_offset_so, p);
+	}
+
+	if (!match_sym) {
+		info->dli_sname = 0;
+		info->dli_saddr = 0;
+		return 1;
+	}
+	info->dli_sname = strings + match_sym->st_name;
+	info->dli_saddr = (void *)laddr(p, match_sym->st_value);
+	return 1;
+}
+
+hidden void *__dlsym(void *restrict p, const char *restrict s, void *restrict ra)
+{
+	void *res;
+	pthread_rwlock_rdlock(&lock);
+#ifdef HANDLE_RANDOMIZATION
+	if ((p != RTLD_DEFAULT) && (p != RTLD_NEXT)) {
+		struct dso *dso = find_dso_by_handle(p);
+		if (dso == NULL) {
+			pthread_rwlock_unlock(&lock);
+			return 0;
+		}
+		res = do_dlsym(dso, s, "", ra);
+	} else {
+		res = do_dlsym(p, s, "", ra);
+	}
+#else
+	res = do_dlsym(p, s, "", ra);
+#endif
+	pthread_rwlock_unlock(&lock);
+	return res;
+}
+
+hidden void *__dlvsym(void *restrict p, const char *restrict s, const char *restrict v, void *restrict ra)
+{
+	void *res;
+	pthread_rwlock_rdlock(&lock);
+#ifdef HANDLE_RANDOMIZATION
+	if ((p != RTLD_DEFAULT) && (p != RTLD_NEXT)) {
+		struct dso *dso = find_dso_by_handle(p);
+		if (dso == NULL) {
+			pthread_rwlock_unlock(&lock);
+			return 0;
+		}
+		res = do_dlsym(dso, s, v, ra);
+	} else {
+		res = do_dlsym(p, s, v, ra);
+	}
+#else
+	res = do_dlsym(p, s, v, ra);
+#endif
+	pthread_rwlock_unlock(&lock);
+	return res;
+}
+
+hidden void *__dlsym_redir_time64(void *restrict p, const char *restrict s, void *restrict ra)
+{
+#if _REDIR_TIME64
+	const char *suffix, *suffix2 = "";
+	char redir[36];
+
+	/* Map the symbol name to a time64 version of itself according to the
+	 * pattern used for naming the redirected time64 symbols. */
+	size_t l = strnlen(s, sizeof redir);
+	if (l<4 || l==sizeof redir) goto no_redir;
+	if (s[l-2]=='_' && s[l-1]=='r') {
+		l -= 2;
+		suffix2 = s+l;
+	}
+	if (l<4) goto no_redir;
+	if (!strcmp(s+l-4, "time")) suffix = "64";
+	else suffix = "_time64";
+
+	/* Use the presence of the remapped symbol name in libc to determine
+	 * whether it's one that requires time64 redirection; replace if so. */
+	snprintf(redir, sizeof redir, "__%.*s%s%s", (int)l, s, suffix, suffix2);
+	if (find_sym(&ldso, redir, 1).sym) s = redir;
+no_redir:
+#endif
+	return __dlsym(p, s, ra);
+}
+
+int dl_iterate_phdr(int(*callback)(struct dl_phdr_info *info, size_t size, void *data), void *data)
+{
+	struct dso *current;
 	struct dl_phdr_info info;
 	int ret = 0;
 	for(current = head; current;) {
@@ -2361,3 +4161,1328 @@ static void error(const char *fmt, ...)
 	__dl_vseterr(fmt, ap);
 	va_end(ap);
 }
+
+int dlns_set_namespace_lib_path(const char * name, const char * lib_path)
+{
+	if (!name || !lib_path) {
+		LD_LOGE("dlns_set_namespace_lib_path name or lib_path is null.");
+		return EINVAL;
+	}
+
+	pthread_rwlock_wrlock(&lock);
+	const void *caller_addr = __builtin_return_address(0);
+	if (is_permitted(caller_addr, name) == false) {
+		pthread_rwlock_unlock(&lock);
+		return EPERM;
+	}
+
+	ns_t* ns = find_ns_by_name(name);
+	if (!ns) {
+		pthread_rwlock_unlock(&lock);
+		LD_LOGE("dlns_set_namespace_lib_path fail, input ns name : [%{public}s] is not found.", name);
+		return ENOKEY;
+	}
+
+	ns_set_lib_paths(ns, lib_path);
+	pthread_rwlock_unlock(&lock);
+	return 0;
+}
+
+int dlns_set_namespace_separated(const char * name, const bool separated)
+{
+	if (!name) {
+		LD_LOGE("dlns_set_namespace_separated name  is null.");
+		return EINVAL;
+	}
+
+	pthread_rwlock_wrlock(&lock);
+	const void *caller_addr = __builtin_return_address(0);
+	if (is_permitted(caller_addr, name) == false) {
+		pthread_rwlock_unlock(&lock);
+		return EPERM;
+	}
+
+	ns_t* ns = find_ns_by_name(name);
+	if (!ns) {
+		pthread_rwlock_unlock(&lock);
+		LD_LOGE("dlns_set_namespace_separated fail, input ns name : [%{public}s] is not found.", name);
+		return ENOKEY;
+	}
+
+	ns_set_separated(ns, separated);
+	pthread_rwlock_unlock(&lock);
+	return 0;
+}
+
+int dlns_set_namespace_permitted_paths(const char * name, const char * permitted_paths)
+{
+	if (!name || !permitted_paths) {
+		LD_LOGE("dlns_set_namespace_permitted_paths name or permitted_paths is null.");
+		return EINVAL;
+	}
+
+	pthread_rwlock_wrlock(&lock);
+	const void *caller_addr = __builtin_return_address(0);
+	if (is_permitted(caller_addr, name) == false) {
+		pthread_rwlock_unlock(&lock);
+		return EPERM;
+	}
+
+	ns_t* ns = find_ns_by_name(name);
+	if (!ns) {
+		pthread_rwlock_unlock(&lock);
+		LD_LOGE("dlns_set_namespace_permitted_paths fail, input ns name : [%{public}s] is not found.", name);
+		return ENOKEY;
+	}
+
+	ns_set_permitted_paths(ns, permitted_paths);
+	pthread_rwlock_unlock(&lock);
+	return 0;
+}
+
+int dlns_set_namespace_allowed_libs(const char * name, const char * allowed_libs)
+{
+	if (!name || !allowed_libs) {
+		LD_LOGE("dlns_set_namespace_allowed_libs name or allowed_libs is null.");
+		return EINVAL;
+	}
+
+	pthread_rwlock_wrlock(&lock);
+	const void *caller_addr = __builtin_return_address(0);
+	if (is_permitted(caller_addr, name) == false) {
+		pthread_rwlock_unlock(&lock);
+		return EPERM;
+	}
+
+	ns_t* ns = find_ns_by_name(name);
+	if (!ns) {
+		pthread_rwlock_unlock(&lock);
+		LD_LOGE("dlns_set_namespace_allowed_libs fail, input ns name : [%{public}s] is not found.", name);
+		return ENOKEY;
+	}
+
+	ns_set_allowed_libs(ns, allowed_libs);
+	pthread_rwlock_unlock(&lock);
+	return 0;
+}
+
+int handle_asan_path_open(int fd, const char *name, ns_t *namespace, char *buf, size_t buf_size)
+{
+	LD_LOGD("handle_asan_path_open fd:%{public}d, name:%{public}s , namespace:%{public}s .",
+		fd,
+		name,
+		namespace ? namespace->ns_name : "NULL");
+	int fd_tmp = fd;
+	if (fd == -1 && (namespace->asan_lib_paths || namespace->lib_paths)) {
+		if (namespace->lib_paths && namespace->asan_lib_paths) {
+			size_t newlen = strlen(namespace->asan_lib_paths) + strlen(namespace->lib_paths) + 2;
+			char *new_lib_paths = malloc(newlen);
+			memset(new_lib_paths, 0, newlen);
+			strcpy(new_lib_paths, namespace->asan_lib_paths);
+			strcat(new_lib_paths, ":");
+			strcat(new_lib_paths, namespace->lib_paths);
+			fd_tmp = path_open(name, new_lib_paths, buf, buf_size);
+			LD_LOGD("handle_asan_path_open path_open new_lib_paths:%{public}s ,fd: %{public}d.", new_lib_paths, fd_tmp);
+			free(new_lib_paths);
+		} else if (namespace->asan_lib_paths) {
+			fd_tmp = path_open(name, namespace->asan_lib_paths, buf, buf_size);
+			LD_LOGD("handle_asan_path_open path_open asan_lib_paths:%{public}s ,fd: %{public}d.",
+				namespace->asan_lib_paths,
+				fd_tmp);
+		} else {
+			fd_tmp = path_open(name, namespace->lib_paths, buf, buf_size);
+			LD_LOGD(
+				"handle_asan_path_open path_open lib_paths:%{public}s ,fd: %{public}d.", namespace->lib_paths, fd_tmp);
+		}
+	}
+	return fd_tmp;
+}
+
+void* dlopen_ext(const char *file, int mode, const dl_extinfo *extinfo)
+{
+	const void *caller_addr = __builtin_return_address(0);
+	musl_log_reset();
+	ld_log_reset();
+	if (extinfo != NULL) {
+		if ((extinfo->flag & ~(DL_EXT_VALID_FLAG_BITS)) != 0) {
+			LD_LOGE("Error dlopen_ext %{public}s: invalid flag %{public}x", file, extinfo->flag);
+			return NULL;
+		}
+	}
+	LD_LOGI("dlopen_ext file:%{public}s, mode:%{public}x , caller_addr:%{public}p , extinfo->flag:%{public}x",
+		file,
+		mode,
+		caller_addr,
+		extinfo ? extinfo->flag : 0);
+	return dlopen_impl(file, mode, NULL, caller_addr, extinfo);
+}
+
+#ifdef LOAD_ORDER_RANDOMIZATION
+static void open_library_by_path(const char *name, const char *s, struct loadtask *task, struct zip_info *z_info)
+{
+	char *buf = task->buf;
+	size_t buf_size = sizeof task->buf;
+	size_t l;
+	for (;;) {
+		s += strspn(s, ":\n");
+		l = strcspn(s, ":\n");
+		if (l-1 >= INT_MAX) return;
+		if (snprintf(buf, buf_size, "%.*s/%s", (int)l, s, name) < buf_size) {
+			char *separator = strstr(buf, ZIP_FILE_PATH_SEPARATOR);
+			if (separator != NULL) {
+				int res = open_uncompressed_library_in_zipfile(buf, z_info, separator);
+				if (res == 0) {
+					task->fd = z_info->fd;
+					task->file_offset = z_info->file_offset;
+					break;
+				} else {
+					memset(z_info->path_buf, 0, sizeof(z_info->path_buf));
+				}
+			} else {
+				if ((task->fd = open(buf, O_RDONLY|O_CLOEXEC))>=0) break;
+			}
+		}
+		s += l;
+	}
+	return;
+}
+
+static void handle_asan_path_open_by_task(int fd, const char *name, ns_t *namespace, struct loadtask *task,
+										  struct zip_info *z_info)
+{
+	LD_LOGD("handle_asan_path_open_by_task fd:%{public}d, name:%{public}s , namespace:%{public}s .",
+			fd,
+			name,
+			namespace ? namespace->ns_name : "NULL");
+	if (fd == -1 && (namespace->asan_lib_paths || namespace->lib_paths)) {
+		if (namespace->lib_paths && namespace->asan_lib_paths) {
+			size_t newlen = strlen(namespace->asan_lib_paths) + strlen(namespace->lib_paths) + 2;
+			char *new_lib_paths = malloc(newlen);
+			memset(new_lib_paths, 0, newlen);
+			strcpy(new_lib_paths, namespace->asan_lib_paths);
+			strcat(new_lib_paths, ":");
+			strcat(new_lib_paths, namespace->lib_paths);
+			open_library_by_path(name, new_lib_paths, task, z_info);
+			LD_LOGD("handle_asan_path_open_by_task open_library_by_path new_lib_paths:%{public}s ,fd: %{public}d.",
+					new_lib_paths,
+					task->fd);
+			free(new_lib_paths);
+		} else if (namespace->asan_lib_paths) {
+			open_library_by_path(name, namespace->asan_lib_paths, task, z_info);
+			LD_LOGD("handle_asan_path_open_by_task open_library_by_path asan_lib_paths:%{public}s ,fd: %{public}d.",
+					namespace->asan_lib_paths,
+					task->fd);
+		} else {
+			open_library_by_path(name, namespace->lib_paths, task, z_info);
+			LD_LOGD("handle_asan_path_open_by_task open_library_by_path lib_paths:%{public}s ,fd: %{public}d.",
+					namespace->lib_paths,
+					task->fd);
+		}
+	}
+	return;
+}
+
+/* Used to get an uncompress library offset in zip file, then we can use the offset to mmap the library directly. */
+int open_uncompressed_library_in_zipfile(const char *path, struct zip_info *z_info, char *separator)
+{
+	struct local_file_header zip_file_header;
+	struct central_dir_entry c_dir_entry;
+	struct zip_end_locator end_locator;
+
+	/* Use "'!/' to split the path into zipfile path and library path in zipfile.
+	 * For example:
+	 * - path: x/xx/xxx.zip!/x/xx/xxx.so
+	 * - zipfile path: x/xx/xxx.zip
+	 * - library path in zipfile: x/xx/xxx.so  */
+	if (strlcpy(z_info->path_buf, path, PATH_BUF_SIZE) >= PATH_BUF_SIZE) {
+		LD_LOGE("Open uncompressed library: input path %{public}s is too long.", path);
+		return -1;
+	}
+	z_info->path_buf[separator - path] = '\0';
+	z_info->file_path_index = separator - path + 2;
+	char *zip_file_path = z_info->path_buf;
+	char *lib_path = &z_info->path_buf[z_info->file_path_index];
+	if (zip_file_path == NULL || lib_path == NULL) {
+		LD_LOGE("Open uncompressed library: get zip and lib path failed.");
+		return -1;
+	}
+	LD_LOGD("Open uncompressed library: input path: %{public}s, zip file path: %{public}s, library path: %{public}s.",
+			path, zip_file_path, lib_path);
+
+	// Get zip file length
+	FILE *zip_file = fopen(zip_file_path, "re");
+	if (zip_file == NULL) {
+		LD_LOGE("Open uncompressed library: fopen %{public}s failed.", zip_file_path);
+		return -1;
+	}
+	if (fseek(zip_file, 0, SEEK_END) != 0) {
+		LD_LOGE("Open uncompressed library: fseek SEEK_END failed.");
+		fclose(zip_file);
+		return -1;
+	}
+	int64_t zip_file_len = ftell(zip_file);
+	if (zip_file_len == -1) {
+		LD_LOGE("Open uncompressed library: get zip file length failed.");
+		fclose(zip_file);
+		return -1;
+	}
+
+	// Read end of central directory record.
+	size_t end_locator_len = sizeof(end_locator);
+	size_t end_locator_pos = zip_file_len - end_locator_len;
+	if (fseek(zip_file, end_locator_pos, SEEK_SET) != 0) {
+		LD_LOGE("Open uncompressed library: fseek end locator position failed.");
+		fclose(zip_file);
+		return -1;
+	}
+	if (fread(&end_locator, sizeof(end_locator), 1, zip_file) != 1 || end_locator.signature != EOCD_SIGNATURE) {
+		LD_LOGE("Open uncompressed library: fread end locator failed.");
+		fclose(zip_file);
+		return -1;
+	}
+
+	char file_name[PATH_BUF_SIZE];
+	uint64_t current_dir_pos = end_locator.offset;
+	for (uint16_t i = 0; i < end_locator.total_entries; i++) {
+		// Read central dir entry.
+		if (fseek(zip_file, current_dir_pos, SEEK_SET) != 0) {
+			LD_LOGE("Open uncompressed library: fseek current centra dir entry position failed.");
+			fclose(zip_file);
+			return -1;
+		}
+		if (fread(&c_dir_entry, sizeof(c_dir_entry), 1, zip_file) != 1 || c_dir_entry.signature != CENTRAL_SIGNATURE) {
+			LD_LOGE("Open uncompressed library: fread centra dir entry failed.");
+			fclose(zip_file);
+			return -1;
+		}
+
+		if (fread(file_name, c_dir_entry.name_size, 1, zip_file) != 1) {
+			LD_LOGE("Open uncompressed library: fread file name failed.");
+			fclose(zip_file);
+			return -1;
+		}
+		if (strcmp(file_name, lib_path) == 0) {
+			// Read local file header.
+			if (fseek(zip_file, c_dir_entry.local_header_offset, SEEK_SET) != 0) {
+				LD_LOGE("Open uncompressed library: fseek local file header failed.");
+				fclose(zip_file);
+				return -1;
+			}
+			if (fread(&zip_file_header, sizeof(zip_file_header), 1, zip_file) != 1) {
+				LD_LOGE("Open uncompressed library: fread local file header failed.");
+				fclose(zip_file);
+				return -1;
+			}
+			if (zip_file_header.signature != LOCAL_FILE_HEADER_SIGNATURE) {
+				LD_LOGE("Open uncompressed library: read local file header signature error.");
+				fclose(zip_file);
+				return -1;
+			}
+
+			z_info->file_offset = c_dir_entry.local_header_offset + sizeof(zip_file_header) +
+									zip_file_header.name_size + zip_file_header.extra_size;
+			if (zip_file_header.compression_method != COMPRESS_STORED || z_info->file_offset % PAGE_SIZE != 0) {
+				LD_LOGE("Open uncompressed library: open %{public}s in %{public}s failed because of misalignment or saved with compression."
+						"compress method %{public}d, file offset %{public}lu",
+						lib_path, zip_file_path, zip_file_header.compression_method, z_info->file_offset);
+				fclose(zip_file);
+				return -2;
+			}
+			z_info->found = true;
+			break;
+		}
+
+		memset(file_name, 0, sizeof(file_name));
+		current_dir_pos += sizeof(c_dir_entry);
+		current_dir_pos += c_dir_entry.name_size + c_dir_entry.extra_size + c_dir_entry.comment_size;
+	}
+	if(!z_info->found) {
+		LD_LOGE("Open uncompressed library: %{public}s was not found in %{public}s.", lib_path, zip_file_path);
+		fclose(zip_file);
+		return -3;
+	}
+	z_info->fd = fileno(zip_file);
+
+	return 0;
+}
+
+static bool map_library_header(struct loadtask *task)
+{
+	off_t off_start;
+	Phdr *ph;
+	size_t i;
+
+	ssize_t l = pread(task->fd, task->ehdr_buf, sizeof task->ehdr_buf, task->file_offset);
+	task->eh = task->ehdr_buf;
+	if (l < 0) {
+		LD_LOGE("Error mapping header %{public}s: failed to read fd", task->name);
+		return false;
+	}
+	if (l < sizeof(Ehdr) || (task->eh->e_type != ET_DYN && task->eh->e_type != ET_EXEC)) {
+		LD_LOGE("Error mapping header %{public}s: invaliled Ehdr", task->name);
+		goto noexec;
+	}
+	task->phsize = task->eh->e_phentsize * task->eh->e_phnum;
+	if (task->phsize > sizeof task->ehdr_buf - sizeof(Ehdr)) {
+		task->allocated_buf = malloc(task->phsize);
+		if (!task->allocated_buf) {
+			LD_LOGE("Error mapping header %{public}s: failed to alloc memory", task->name);
+			return false;
+		}
+		l = pread(task->fd, task->allocated_buf, task->phsize, task->eh->e_phoff + task->file_offset);
+		if (l < 0) {
+			LD_LOGE("Error mapping header %{public}s: failed to pread", task->name);
+			goto error;
+		}
+		if (l != task->phsize) {
+			LD_LOGE("Error mapping header %{public}s: unmatched phsize", task->name);
+			goto noexec;
+		}
+		ph = task->ph0 = task->allocated_buf;
+	} else if (task->eh->e_phoff + task->phsize > l) {
+		l = pread(task->fd, task->ehdr_buf + 1, task->phsize, task->eh->e_phoff + task->file_offset);
+		if (l < 0) {
+			LD_LOGE("Error mapping header %{public}s: failed to pread", task->name);
+			goto error;
+		}
+		if (l != task->phsize) {
+			LD_LOGE("Error mapping header %{public}s: unmatched phsize", task->name);
+			goto noexec;
+		}
+		ph = task->ph0 = (void *)(task->ehdr_buf + 1);
+	} else {
+		ph = task->ph0 = (void *)((char *)task->ehdr_buf + task->eh->e_phoff);
+	}
+	for (i = task->eh->e_phnum; i; i--, ph = (void *)((char *)ph + task->eh->e_phentsize)) {
+		if (ph->p_type == PT_DYNAMIC) {
+			task->dyn = ph->p_vaddr;
+		} else if (ph->p_type == PT_TLS) {
+			task->tls_image = ph->p_vaddr;
+			task->tls.align = ph->p_align;
+			task->tls.len = ph->p_filesz;
+			task->tls.size = ph->p_memsz;
+		}
+
+		if (ph->p_type != PT_DYNAMIC) {
+			continue;
+		}
+		// map the dynamic segment and the string table of the library
+		off_start = ph->p_offset;
+		off_start &= -PAGE_SIZE;
+		task->dyn_map_len = ph->p_memsz + (ph->p_offset - off_start);
+		/* The default value of file_offset is 0.
+		 * The value of file_offset may be greater than 0 when opening library from zip file.
+		 * The value of file_offset ensures PAGE_SIZE aligned. */
+		task->dyn_map = mmap(0, task->dyn_map_len, PROT_READ, MAP_PRIVATE, task->fd, off_start + task->file_offset);
+		if (task->dyn_map == MAP_FAILED) {
+			LD_LOGE("Error mapping header %{public}s: failed to map dynamic section", task->name);
+			goto error;
+		}
+		task->dyn_addr = (size_t *)((unsigned char *)task->dyn_map + (ph->p_offset - off_start));
+		size_t dyn_tmp;
+		off_t str_table;
+		size_t str_size;
+		if (search_vec(task->dyn_addr, &dyn_tmp, DT_STRTAB)) {
+			str_table = dyn_tmp;
+		} else {
+			LD_LOGE("Error mapping header %{public}s: DT_STRTAB not found", task->name);
+			goto error;
+		}
+		if (search_vec(task->dyn_addr, &dyn_tmp, DT_STRSZ)) {
+			str_size = dyn_tmp;
+		} else {
+			LD_LOGE("Error mapping header %{public}s: DT_STRSZ not found", task->name);
+			goto error;
+		}
+		off_start = str_table;
+		off_start &= -PAGE_SIZE;
+		task->str_map_len = str_size + (str_table - off_start);
+		task->str_map = mmap(0, task->str_map_len, PROT_READ, MAP_PRIVATE, task->fd, off_start + task->file_offset);
+		if (task->str_map == MAP_FAILED) {
+			LD_LOGE("Error mapping header %{public}s: failed to map string section", task->name);
+			goto error;
+		}
+		task->str_addr = (char *)task->str_map + str_table - off_start;
+	}
+	if (!task->dyn) {
+		LD_LOGE("Error mapping header %{public}s: dynamic section not found", task->name);
+		goto noexec;
+	}
+	return true;
+noexec:
+	errno = ENOEXEC;
+error:
+	free(task->allocated_buf);
+	task->allocated_buf = NULL;
+	return false;
+}
+
+static bool task_map_library(struct loadtask *task, struct reserved_address_params *reserved_params)
+{
+	size_t addr_min = SIZE_MAX, addr_max = 0, map_len;
+	size_t this_min, this_max;
+	size_t nsegs = 0;
+	off_t off_start;
+	Phdr *ph = task->ph0;
+	unsigned prot;
+	unsigned char *map = MAP_FAILED, *base;
+	size_t i;
+	int map_flags = MAP_PRIVATE;
+	size_t start_addr;
+	size_t start_alignment = PAGE_SIZE;
+	bool hugepage_enabled = false;
+
+	for (i = task->eh->e_phnum; i; i--, ph = (void *)((char *)ph + task->eh->e_phentsize)) {
+		if (ph->p_type == PT_GNU_RELRO) {
+			task->p->relro_start = ph->p_vaddr & -PAGE_SIZE;
+			task->p->relro_end = (ph->p_vaddr + ph->p_memsz) & -PAGE_SIZE;
+		} else if (ph->p_type == PT_GNU_STACK) {
+			if (!runtime && ph->p_memsz > __default_stacksize) {
+				__default_stacksize =
+					ph->p_memsz < DEFAULT_STACK_MAX ?
+					ph->p_memsz : DEFAULT_STACK_MAX;
+			}
+		}
+		if (ph->p_type != PT_LOAD) {
+			continue;
+		}
+		nsegs++;
+		if (ph->p_vaddr < addr_min) {
+			addr_min = ph->p_vaddr;
+			off_start = ph->p_offset;
+			prot = (((ph->p_flags & PF_R) ? PROT_READ : 0) |
+				((ph->p_flags & PF_W) ? PROT_WRITE : 0) |
+				((ph->p_flags & PF_X) ? PROT_EXEC : 0));
+		}
+		if (ph->p_vaddr + ph->p_memsz > addr_max) {
+			addr_max = ph->p_vaddr + ph->p_memsz;
+		}
+	}
+	if (!task->dyn) {
+		LD_LOGE("Error mapping library %{public}s: dynamic section not found", task->name);
+		goto noexec;
+	}
+	if (DL_FDPIC && !(task->eh->e_flags & FDPIC_CONSTDISP_FLAG)) {
+		task->p->loadmap = calloc(1, sizeof(struct fdpic_loadmap) + nsegs * sizeof(struct fdpic_loadseg));
+		if (!task->p->loadmap) {
+			goto error;
+		}
+		task->p->loadmap->nsegs = nsegs;
+		for (ph = task->ph0, i = 0; i < nsegs; ph = (void *)((char *)ph + task->eh->e_phentsize)) {
+			if (ph->p_type != PT_LOAD) {
+				continue;
+			}
+			prot = (((ph->p_flags & PF_R) ? PROT_READ : 0) |
+				((ph->p_flags & PF_W) ? PROT_WRITE : 0) |
+				((ph->p_flags & PF_X) ? PROT_EXEC : 0));
+			map = mmap(0, ph->p_memsz + (ph->p_vaddr & PAGE_SIZE - 1),
+				prot, MAP_PRIVATE,
+				task->fd, ph->p_offset & -PAGE_SIZE + task->file_offset);
+			if (map == MAP_FAILED) {
+				unmap_library(task->p);
+				goto error;
+			}
+			task->p->loadmap->segs[i].addr = (size_t)map +
+				(ph->p_vaddr & PAGE_SIZE - 1);
+			task->p->loadmap->segs[i].p_vaddr = ph->p_vaddr;
+			task->p->loadmap->segs[i].p_memsz = ph->p_memsz;
+			i++;
+			if (prot & PROT_WRITE) {
+				size_t brk = (ph->p_vaddr & PAGE_SIZE - 1) + ph->p_filesz;
+				size_t pgbrk = (brk + PAGE_SIZE - 1) & -PAGE_SIZE;
+				size_t pgend = (brk + ph->p_memsz - ph->p_filesz + PAGE_SIZE - 1) & -PAGE_SIZE;
+				if (pgend > pgbrk && mmap_fixed(map + pgbrk,
+					pgend - pgbrk, prot,
+					MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS,
+					-1, off_start) == MAP_FAILED)
+					goto error;
+				memset(map + brk, 0, pgbrk - brk);
+			}
+		}
+		map = (void *)task->p->loadmap->segs[0].addr;
+		map_len = 0;
+		goto done_mapping;
+	}
+	addr_max += PAGE_SIZE - 1;
+	addr_max &= -PAGE_SIZE;
+	addr_min &= -PAGE_SIZE;
+	off_start &= -PAGE_SIZE;
+	map_len = addr_max - addr_min + off_start;
+	start_addr = addr_min;
+
+	hugepage_enabled = get_transparent_hugepages_supported();
+	if (hugepage_enabled) {
+		size_t maxinum_alignment = phdr_table_get_maxinum_alignment(task->ph0, task->eh->e_phnum);
+
+		start_alignment = maxinum_alignment == KPMD_SIZE ? KPMD_SIZE : PAGE_SIZE;
+	}
+
+	if (reserved_params) {
+		if (map_len > reserved_params->reserved_size) {
+			if (reserved_params->must_use_reserved) {
+				LD_LOGE("Error mapping library %{public}s: map len is larger than reserved address", task->name);
+				goto error;
+			}
+		} else {
+			start_addr = ((size_t)reserved_params->start_addr - 1 + PAGE_SIZE) & -PAGE_SIZE;
+			map_flags |= MAP_FIXED;
+		}
+	}
+
+	/* we will find a mapping_align aligned address as the start of dso
+	 * so we need a tmp_map_len as map_len + mapping_align to make sure
+	 * we have enough space to shift the dso to the correct location. */
+	size_t mapping_align = start_alignment > LIBRARY_ALIGNMENT ? start_alignment : LIBRARY_ALIGNMENT;
+	size_t tmp_map_len = ALIGN(map_len, mapping_align) + mapping_align - PAGE_SIZE;
+
+	/* if reserved_params exists, we should use start_addr as prefered result to do the mmap operation */
+	if (reserved_params) {
+		map = DL_NOMMU_SUPPORT
+			? mmap((void *)start_addr, map_len, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
+			: mmap((void *)start_addr, map_len, prot, map_flags, task->fd, off_start + task->file_offset);
+		if (map == MAP_FAILED) {
+			goto error;
+		}
+		if (reserved_params && map_len < reserved_params->reserved_size) {
+			reserved_params->reserved_size -= (map_len + (start_addr - (size_t)reserved_params->start_addr));
+			reserved_params->start_addr = (void *)((uint8_t *)map + map_len);
+		}
+	/* if reserved_params does not exist, we should use real_map as prefered result to do the mmap operation */
+	} else {
+		/* use tmp_map_len to mmap enough space for the dso with anonymous mapping */
+		unsigned char *temp_map = mmap((void *)NULL, tmp_map_len, PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+		if (temp_map == MAP_FAILED) {
+			goto error;
+		}
+
+		/* find the mapping_align aligned address */
+		unsigned char *real_map = (unsigned char*)ALIGN((uintptr_t)temp_map, mapping_align);
+
+		/* mummap the space we mmap before so that we can mmap correct space again */
+		munmap(temp_map, tmp_map_len);
+
+		map = DL_NOMMU_SUPPORT
+			? mmap(real_map, map_len, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
+			/* use map_len to mmap correct space for the dso with file mapping */
+			: mmap(real_map, map_len, prot, map_flags, task->fd, off_start + task->file_offset);
+		if (map == MAP_FAILED) {
+			goto error;
+		}
+	}
+	task->p->map = map;
+	task->p->map_len = map_len;
+	/* If the loaded file is not relocatable and the requested address is
+	 * not available, then the load operation must fail. */
+	if (task->eh->e_type != ET_DYN && addr_min && map != (void *)addr_min) {
+		LD_LOGE("Error mapping library %{public}s: device or resource busy", task->name);
+		errno = EBUSY;
+		goto error;
+	}
+	base = map - addr_min;
+	task->p->phdr = 0;
+	task->p->phnum = 0;
+	for (ph = task->ph0, i = task->eh->e_phnum; i; i--, ph = (void *)((char *)ph + task->eh->e_phentsize)) {
+		if (ph->p_type == PT_OHOS_RANDOMDATA) {
+			fill_random_data((void *)(ph->p_vaddr + base), ph->p_memsz);
+			continue;
+		}
+		if (ph->p_type != PT_LOAD) {
+			continue;
+		}
+		/* Check if the programs headers are in this load segment, and
+		 * if so, record the address for use by dl_iterate_phdr. */
+		if (!task->p->phdr && task->eh->e_phoff >= ph->p_offset
+			&& task->eh->e_phoff + task->phsize <= ph->p_offset + ph->p_filesz) {
+			task->p->phdr = (void *)(base + ph->p_vaddr + (task->eh->e_phoff - ph->p_offset));
+			task->p->phnum = task->eh->e_phnum;
+			task->p->phentsize = task->eh->e_phentsize;
+		}
+		this_min = ph->p_vaddr & -PAGE_SIZE;
+		this_max = ph->p_vaddr + ph->p_memsz + PAGE_SIZE - 1 & -PAGE_SIZE;
+		off_start = ph->p_offset & -PAGE_SIZE;
+		prot = (((ph->p_flags & PF_R) ? PROT_READ : 0) |
+			((ph->p_flags & PF_W) ? PROT_WRITE : 0) |
+			((ph->p_flags & PF_X) ? PROT_EXEC : 0));
+		/* Reuse the existing mapping for the lowest-address LOAD */
+		if ((ph->p_vaddr & -PAGE_SIZE) != addr_min || DL_NOMMU_SUPPORT) {
+			if (mmap_fixed(
+					base + this_min,
+					this_max - this_min,
+					prot, MAP_PRIVATE | MAP_FIXED,
+					task->fd,
+					off_start + task->file_offset) == MAP_FAILED) {
+				LD_LOGE("Error mapping library %{public}s: mmap fix failed, errno: %{public}d", task->name, errno);
+				goto error;
+			}
+		}
+		if ((ph->p_flags & PF_X) && (ph->p_align == KPMD_SIZE) && hugepage_enabled)
+			madvise(base + this_min, this_max - this_min, MADV_HUGEPAGE);
+		if (ph->p_memsz > ph->p_filesz && (ph->p_flags & PF_W)) {
+			size_t brk = (size_t)base + ph->p_vaddr + ph->p_filesz;
+			size_t pgbrk = brk + PAGE_SIZE - 1 & -PAGE_SIZE;
+			size_t zeromap_size = (size_t)base + this_max - pgbrk;
+			memset((void *)brk, 0, pgbrk - brk & PAGE_SIZE - 1);
+			if (pgbrk - (size_t)base < this_max && mmap_fixed(
+				(void *)pgbrk,
+				zeromap_size,
+				prot,
+				MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS,
+				-1,
+				0) == MAP_FAILED) {
+				LD_LOGE("Error mapping library: mmap fix failed");
+				goto error;
+			}
+			set_bss_vma_name(task->p->name, (void *)pgbrk, zeromap_size);
+		}
+	}
+	for (i = 0; ((size_t *)(base + task->dyn))[i]; i += NEXT_DYNAMIC_INDEX) {
+		if (((size_t *)(base + task->dyn))[i] == DT_TEXTREL) {
+			if (mprotect(map, map_len, PROT_READ | PROT_WRITE | PROT_EXEC) && errno != ENOSYS) {
+				LD_LOGE("Error mapping library %{public}s: mprotect failed", task->name);
+				goto error;
+			}
+			break;
+		}
+	}
+done_mapping:
+	task->p->base = base;
+	task->p->dynv = laddr(task->p, task->dyn);
+	if (task->p->tls.size) {
+		task->p->tls.image = laddr(task->p, task->tls_image);
+	}
+	free(task->allocated_buf);
+	task->allocated_buf = NULL;
+	return true;
+noexec:
+	errno = ENOEXEC;
+error:
+	if (map != MAP_FAILED) {
+		unmap_library(task->p);
+	}
+	free(task->allocated_buf);
+	task->allocated_buf = NULL;
+	return false;
+}
+
+static bool load_library_header(struct loadtask *task)
+{
+	const char *name = task->name;
+	struct dso *needed_by = task->needed_by;
+	ns_t *namespace = task->namespace;
+	bool check_inherited = task->check_inherited;
+	struct zip_info z_info;
+
+	bool map = false;
+	struct stat st;
+	size_t alloc_size;
+	int n_th = 0;
+	int is_self = 0;
+
+	if (!*name) {
+		errno = EINVAL;
+		return false;
+	}
+
+	/* Catch and block attempts to reload the implementation itself */
+	if (name[NAME_INDEX_ZERO] == 'l' && name[NAME_INDEX_ONE] == 'i' && name[NAME_INDEX_TWO] == 'b') {
+		static const char reserved[] =
+			"c.pthread.rt.m.dl.util.xnet.";
+		const char *rp, *next;
+		for (rp = reserved; *rp; rp = next) {
+			next = strchr(rp, '.') + 1;
+			if (strncmp(name + NAME_INDEX_THREE, rp, next - rp) == 0) {
+				break;
+			}
+		}
+		if (*rp) {
+			if (ldd_mode) {
+				/* Track which names have been resolved
+				 * and only report each one once. */
+				static unsigned reported;
+				unsigned mask = 1U << (rp - reserved);
+				if (!(reported & mask)) {
+					reported |= mask;
+					dprintf(1, "\t%s => %s (%p)\n",
+						name, ldso.name,
+						ldso.base);
+				}
+			}
+			is_self = 1;
+		}
+	}
+	if (!strcmp(name, ldso.name)) {
+		is_self = 1;
+	}
+	if (is_self) {
+		if (!ldso.prev) {
+			tail->next = &ldso;
+			ldso.prev = tail;
+			tail = &ldso;
+			ldso.namespace = namespace;
+			ns_add_dso(namespace, &ldso);
+		}
+		task->isloaded = true;
+		task->p = &ldso;
+		return true;
+	}
+	if (strchr(name, '/')) {
+		char *separator = strstr(name, ZIP_FILE_PATH_SEPARATOR);
+		if (separator != NULL) {
+			int res = open_uncompressed_library_in_zipfile(name, &z_info, separator);
+			if (!res) {
+				task->pathname = name;
+				if (!is_accessible(namespace, task->pathname, g_is_asan, check_inherited)) {
+					LD_LOGE("Open uncompressed library: check ns accessible failed, pathname %{public}s namespace %{public}s.",
+							task->pathname, namespace ? namespace->ns_name : "NULL");
+					task->fd = -1;
+				} else {
+					task->fd = z_info.fd;
+					task->file_offset = z_info.file_offset;
+				}
+			} else {
+				LD_LOGE("Open uncompressed library in zip file failed, name:%{public}s res:%{public}d", name, res);
+				return false;
+			}
+		} else {
+			task->pathname = name;
+			if (!is_accessible(namespace, task->pathname, g_is_asan, check_inherited)) {
+				task->fd = -1;
+			} else {
+				task->fd = open(name, O_RDONLY | O_CLOEXEC);
+			}
+		}
+	} else {
+		/* Search for the name to see if it's already loaded */
+		/* Search in namespace */
+		task->p = find_library_by_name(name, namespace, check_inherited);
+		if (task->p) {
+			task->isloaded = true;
+			LD_LOGD("find_library_by_name(name=%{public}s ns=%{public}s) already loaded by %{public}s in %{public}s namespace  ",
+					name, namespace->ns_name, task->p->name, task->p->namespace->ns_name);
+			return true;
+		}
+		if (strlen(name) > NAME_MAX) {
+			LD_LOGE("load_library name length is larger than NAME_MAX:%{public}s.", name);
+			return false;
+		}
+		task->fd = -1;
+		if (namespace->env_paths) {
+			open_library_by_path(name, namespace->env_paths, task, &z_info);
+		}
+		for (task->p = needed_by; task->fd == -1 && task->p; task->p = task->p->needed_by) {
+			if (fixup_rpath(task->p, task->buf, sizeof task->buf) < 0) {
+				task->fd = INVALID_FD_INHIBIT_FURTHER_SEARCH; /* Inhibit further search. */
+			}
+			if (task->p->rpath) {
+				open_library_by_path(name, task->p->rpath, task, &z_info);
+			}
+		}
+		if (g_is_asan) {
+			handle_asan_path_open_by_task(task->fd, name, namespace, task, &z_info);
+			LD_LOGD("load_library handle_asan_path_open_by_task fd:%{public}d.", task->fd);
+		} else {
+			if (task->fd == -1 && namespace->lib_paths) {
+				open_library_by_path(name, namespace->lib_paths, task, &z_info);
+				LD_LOGD("load_library no asan lib_paths path_open fd:%{public}d.", task->fd);
+			}
+		}
+		task->pathname = task->buf;
+	}
+	if (task->fd < 0) {
+		if (!check_inherited || !namespace->ns_inherits) {
+			return false;
+		}
+		/* Load lib in inherited namespace. Do not check inherited again.*/
+		for (size_t i = 0; i < namespace->ns_inherits->num; i++) {
+			ns_inherit *inherit = namespace->ns_inherits->inherits[i];
+			if (strchr(name, '/') == 0 && !is_sharable(inherit, name)) {
+				continue;
+			}
+			task->namespace = inherit->inherited_ns;
+			task->check_inherited = false;
+			if (load_library_header(task)) {
+				return true;
+			}
+		}
+		return false;
+	}
+
+	if (fstat(task->fd, &st) < 0) {
+		LD_LOGE("Error loading header %{public}s: failed to get file state", task->name);
+		close(task->fd);
+		task->fd = -1;
+		return false;
+	}
+	/* Search in namespace */
+	task->p = find_library_by_fstat(&st, namespace, check_inherited, task->file_offset);
+	if (task->p) {
+		/* If this library was previously loaded with a
+		* pathname but a search found the same inode,
+		* setup its shortname so it can be found by name. */
+		if (!task->p->shortname && task->pathname != name) {
+			task->p->shortname = strrchr(task->p->name, '/') + 1;
+		}
+		close(task->fd);
+		task->fd = -1;
+		task->isloaded = true;
+		LD_LOGD("find_library_by_fstat(name=%{public}s ns=%{public}s) already loaded by %{public}s in %{public}s namespace  ",
+				name, namespace->ns_name, task->p->name, task->p->namespace->ns_name);
+		return true;
+	}
+
+	map = noload ? 0 : map_library_header(task);
+	if (!map) {
+		LD_LOGE("Error loading header %{public}s: failed to map header", task->name);
+		close(task->fd);
+		task->fd = -1;
+		return false;
+	}
+
+	/* Allocate storage for the new DSO. When there is TLS, this
+	 * storage must include a reservation for all pre-existing
+	 * threads to obtain copies of both the new TLS, and an
+	 * extended DTV capable of storing an additional slot for
+	 * the newly-loaded DSO. */
+	alloc_size = sizeof(struct dso) + strlen(task->pathname) + 1;
+	if (runtime && task->tls.size) {
+		size_t per_th = task->tls.size + task->tls.align + sizeof(void *) * (tls_cnt + TLS_CNT_INCREASE);
+		n_th = libc.threads_minus_1 + 1;
+		if (n_th > SSIZE_MAX / per_th) {
+			alloc_size = SIZE_MAX;
+		} else {
+			alloc_size += n_th * per_th;
+		}
+	}
+	task->p = calloc(1, alloc_size);
+	if (!task->p) {
+		LD_LOGE("Error loading header %{public}s: failed to allocate dso", task->name);
+		close(task->fd);
+		task->fd = -1;
+		return false;
+	}
+	task->p->dev = st.st_dev;
+	task->p->ino = st.st_ino;
+	task->p->file_offset = task->file_offset;
+	task->p->needed_by = needed_by;
+	task->p->name = task->p->buf;
+	strcpy(task->p->name, task->pathname);
+	task->p->tls = task->tls;
+	task->p->dynv = task->dyn_addr;
+	task->p->strings = task->str_addr;
+
+	/* Add a shortname only if name arg was not an explicit pathname. */
+	if (task->pathname != name) {
+		task->p->shortname = strrchr(task->p->name, '/') + 1;
+	}
+
+	if (task->p->tls.size) {
+		task->p->tls_id = ++tls_cnt;
+		task->p->new_dtv = (void *)(-sizeof(size_t) &
+			(uintptr_t)(task->p->name + strlen(task->p->name) + sizeof(size_t)));
+		task->p->new_tls = (void *)(task->p->new_dtv + n_th * (tls_cnt + 1));
+	}
+
+	tail->next = task->p;
+	task->p->prev = tail;
+	tail = task->p;
+
+	/* Add dso to namespace */
+	task->p->namespace = namespace;
+	ns_add_dso(namespace, task->p);
+	return true;
+}
+
+static void task_load_library(struct loadtask *task, struct reserved_address_params *reserved_params)
+{
+	LD_LOGD("load_library loading ns=%{public}s name=%{public}s by_dlopen=%{public}d", task->namespace->ns_name, task->p->name, runtime);
+	bool map = noload ? 0 : task_map_library(task, reserved_params);
+	close(task->fd);
+	task->fd = -1;
+	if (!map) {
+		LD_LOGE("Error loading library %{public}s: failed to map library", task->name);
+		error("Error loading library %s: failed to map library", task->name);
+		if (runtime) {
+			longjmp(*rtld_fail, 1);
+		}
+		return;
+	};
+
+	/* Avoid the danger of getting two versions of libc mapped into the
+	 * same process when an absolute pathname was used. The symbols
+	 * checked are chosen to catch both musl and glibc, and to avoid
+	 * false positives from interposition-hack libraries. */
+	decode_dyn(task->p);
+	if (find_sym(task->p, "__libc_start_main", 1).sym &&
+		find_sym(task->p, "stdin", 1).sym) {
+		do_dlclose(task->p);
+		task->p = NULL;
+		free((void*)task->name);
+		task->name = ld_strdup("libc.so");
+		task->check_inherited = true;
+		if (!load_library_header(task)) {
+			LD_LOGE("Error loading library %{public}s: failed to load libc.so", task->name);
+			error("Error loading library %s: failed to load libc.so", task->name);
+			if (runtime) {
+				longjmp(*rtld_fail, 1);
+			}
+		}
+		return;
+	}
+	/* Past this point, if we haven't reached runtime yet, ldso has
+	 * committed either to use the mapped library or to abort execution.
+	 * Unmapping is not possible, so we can safely reclaim gaps. */
+	if (!runtime) {
+		reclaim_gaps(task->p);
+	}
+	task->p->runtime_loaded = runtime;
+	if (runtime)
+		task->p->by_dlopen = 1;
+
+	if (DL_FDPIC) {
+		makefuncdescs(task->p);
+	}
+
+	if (ldd_mode) {
+		dprintf(1, "\t%s => %s (%p)\n", task->name, task->pathname, task->p->base);
+	}
+}
+
+static void preload_direct_deps(struct dso *p, ns_t *namespace, struct loadtasks *tasks)
+{
+	size_t i, cnt = 0;
+	if (p->deps) {
+		return;
+	}
+	/* For head, all preloads are direct pseudo-dependencies.
+	 * Count and include them now to avoid realloc later. */
+	if (p == head) {
+		for (struct dso *q = p->next; q; q = q->next) {
+			cnt++;
+		}
+	}
+	for (i = 0; p->dynv[i]; i += NEXT_DYNAMIC_INDEX) {
+		if (p->dynv[i] == DT_NEEDED) {
+			cnt++;
+		}
+	}
+	/* Use builtin buffer for apps with no external deps, to
+	 * preserve property of no runtime failure paths. */
+	p->deps = (p == head && cnt < MIN_DEPS_COUNT) ? builtin_deps :
+		calloc(cnt + 1, sizeof *p->deps);
+	if (!p->deps) {
+		LD_LOGE("Error loading dependencies for %{public}s", p->name);
+		error("Error loading dependencies for %s", p->name);
+		if (runtime) {
+			longjmp(*rtld_fail, 1);
+		}
+	}
+	cnt = 0;
+	if (p == head) {
+		for (struct dso *q = p->next; q; q = q->next) {
+			p->deps[cnt++] = q;
+		}
+	}
+	for (i = 0; p->dynv[i]; i += NEXT_DYNAMIC_INDEX) {
+		if (p->dynv[i] != DT_NEEDED) {
+			continue;
+		}
+		const char* dtneed_name = p->strings + p->dynv[i + 1];
+		LD_LOGD("load_library %{public}s adding DT_NEEDED task %{public}s namespace(%{public}s)", p->name, dtneed_name, namespace->ns_name);
+		struct loadtask *task = create_loadtask(dtneed_name, p, namespace, true);
+		if (!task) {
+			LD_LOGE("Error loading dependencies %{public}s : create load task failed", p->name);
+			error("Error loading dependencies for %s : create load task failed", p->name);
+			if (runtime) {
+				longjmp(*rtld_fail, 1);
+			}
+			continue;
+		}
+		LD_LOGD("loading shared library %{public}s: (needed by %{public}s)", p->strings + p->dynv[i+1], p->name);
+		if (!load_library_header(task)) {
+			free_task(task);
+			task = NULL;
+			LD_LOGE("Error loading shared library %{public}s: (needed by %{public}s)",
+				p->strings + p->dynv[i + 1],
+				p->name);
+			error("Error loading shared library %s: %m (needed by %s)",
+				p->strings + p->dynv[i + 1], p->name);
+			if (runtime) {
+				longjmp(*rtld_fail, 1);
+			}
+			continue;
+		}
+		p->deps[cnt++] = task->p;
+		if (task->isloaded) {
+			free_task(task);
+			task = NULL;
+		} else {
+			append_loadtasks(tasks, task);
+		}
+	}
+	p->deps[cnt] = 0;
+	p->ndeps_direct = cnt;
+	for (i = 0; i < p->ndeps_direct; i++) {
+		add_dso_parent(p->deps[i], p);
+	}
+}
+
+static void unmap_preloaded_sections(struct loadtasks *tasks)
+{
+	struct loadtask *task = NULL;
+	for (size_t i = 0; i < tasks->length; i++) {
+		task = get_loadtask(tasks, i);
+		if (!task) {
+			continue;
+		}
+		if (task->dyn_map_len) {
+			munmap(task->dyn_map, task->dyn_map_len);
+			task->dyn_map = NULL;
+			task->dyn_map_len = 0;
+			if (task->p) {
+				task->p->dynv = NULL;
+			}
+		}
+		if (task->str_map_len) {
+			munmap(task->str_map, task->str_map_len);
+			task->str_map = NULL;
+			task->str_map_len = 0;
+			if (task->p) {
+				task->p->strings = NULL;
+			}
+		}
+	}
+}
+
+static void preload_deps(struct dso *p, struct loadtasks *tasks)
+{
+	if (p->deps) {
+		return;
+	}
+	for (; p; p = p->next) {
+		preload_direct_deps(p, p->namespace, tasks);
+	}
+}
+
+static void run_loadtasks(struct loadtasks *tasks, struct reserved_address_params *reserved_params)
+{
+	struct loadtask *task = NULL;
+	bool reserved_address = false;
+	for (size_t i = 0; i < tasks->length; i++) {
+		task = get_loadtask(tasks, i);
+		if (task) {
+			if (reserved_params) {
+				reserved_address = reserved_params->reserved_address_recursive || (reserved_params->target == task->p);
+			}
+			task_load_library(task, reserved_address ? reserved_params : NULL);
+		}
+	}
+}
+
+UT_STATIC void assign_tls(struct dso *p)
+{
+	while (p) {
+		if (p->tls.image) {
+			tls_align = MAXP2(tls_align, p->tls.align);
+#ifdef TLS_ABOVE_TP
+			p->tls.offset = tls_offset + ((p->tls.align - 1) &
+				(-tls_offset + (uintptr_t)p->tls.image));
+			tls_offset = p->tls.offset + p->tls.size;
+#else
+			tls_offset += p->tls.size + p->tls.align - 1;
+			tls_offset -= (tls_offset + (uintptr_t)p->tls.image)
+				& (p->tls.align - 1);
+			p->tls.offset = tls_offset;
+#endif
+			if (tls_tail) {
+				tls_tail->next = &p->tls;
+			} else {
+				libc.tls_head = &p->tls;
+			}
+			tls_tail = &p->tls;
+		}
+
+		p = p->next;
+	}
+}
+
+UT_STATIC void load_preload(char *s, ns_t *ns, struct loadtasks *tasks)
+{
+	int tmp;
+	char *z;
+
+	struct loadtask *task = NULL;
+	for (z = s; *z; s = z) {
+		for (; *s && (isspace(*s) || *s == ':'); s++) {
+			;
+		}
+		for (z = s; *z && !isspace(*z) && *z != ':'; z++) {
+			;
+		}
+		tmp = *z;
+		*z = 0;
+		task = create_loadtask(s, NULL, ns, true);
+		if (!task) {
+			continue;
+		}
+		if (load_library_header(task)) {
+			if (!task->isloaded) {
+				append_loadtasks(tasks, task);
+				task = NULL;
+			}
+		}
+		if (task) {
+			free_task(task);
+		}
+		*z = tmp;
+	}
+}
+#endif
+
+static int serialize_gnu_relro(int fd, struct dso *dso, ssize_t *file_offset)
+{
+	ssize_t count = dso->relro_end - dso->relro_start;
+	ssize_t offset = 0;
+	while (count > 0) {
+		ssize_t write_size = TEMP_FAILURE_RETRY(write(fd, laddr(dso, dso->relro_start + offset), count));
+		if (-1 == write_size) {
+			LD_LOGE("Error serializing relro %{public}s: failed to write GNU_RELRO", dso->name);
+			return -1;
+		}
+		offset += write_size;
+		count -= write_size;
+	}
+
+	ssize_t size = dso->relro_end - dso->relro_start;
+	void *map = mmap(
+		laddr(dso, dso->relro_start),
+		size,
+		PROT_READ,
+		MAP_PRIVATE | MAP_FIXED,
+		fd,
+		*file_offset);
+	if (map == MAP_FAILED) {
+		LD_LOGE("Error serializing relro %{public}s: failed to map GNU_RELRO", dso->name);
+		return -1;
+	}
+	*file_offset += size;
+	return 0;
+}
+
+static int map_gnu_relro(int fd, struct dso *dso, ssize_t *file_offset)
+{
+	ssize_t ext_fd_file_size = 0;
+	struct stat ext_fd_file_stat;
+	if (TEMP_FAILURE_RETRY(fstat(fd, &ext_fd_file_stat)) != 0) {
+		LD_LOGE("Error mapping relro %{public}s: failed to get file state", dso->name);
+		return -1;
+	}
+	ext_fd_file_size = ext_fd_file_stat.st_size;
+
+	void *ext_temp_map = MAP_FAILED;
+	ext_temp_map = mmap(NULL, ext_fd_file_size, PROT_READ, MAP_PRIVATE, fd, 0);
+	if (ext_temp_map == MAP_FAILED) {
+		LD_LOGE("Error mapping relro %{public}s: failed to map fd", dso->name);
+		return -1;
+	}
+
+	char *file_base = (char *)(ext_temp_map) + *file_offset;
+	char *mem_base = (char *)(laddr(dso, dso->relro_start));
+	ssize_t start_offset = 0;
+	ssize_t size = dso->relro_end - dso->relro_start;
+
+	if (size > ext_fd_file_size - *file_offset) {
+		LD_LOGE("Error mapping relro %{public}s: invalid file size", dso->name);
+		return -1;
+	}
+	while (start_offset < size) {
+		// Find start location.
+		while (start_offset < size) {
+			if (memcmp(mem_base + start_offset, file_base + start_offset, PAGE_SIZE) == 0) {
+				break;
+			}
+			start_offset += PAGE_SIZE;
+		}
+
+		// Find end location.
+		ssize_t end_offset = start_offset;
+		while (end_offset < size) {
+			if (memcmp(mem_base + end_offset, file_base + end_offset, PAGE_SIZE) != 0) {
+				break;
+			}
+			end_offset += PAGE_SIZE;
+		}
+
+		// Map pages.
+		ssize_t map_length = end_offset - start_offset;
+		ssize_t map_offset = *file_offset + start_offset;
+		if (map_length > 0) {
+			void *map = mmap(
+				mem_base + start_offset, map_length, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, map_offset);
+			if (map == MAP_FAILED) {
+				LD_LOGE("Error mapping relro %{public}s: failed to map GNU_RELRO", dso->name);
+				munmap(ext_temp_map, ext_fd_file_size);
+				return -1;
+			}
+		}
+
+		start_offset = end_offset;
+	}
+	*file_offset += size;
+	munmap(ext_temp_map, ext_fd_file_size);
+	return 0;
+}
+
+static void handle_relro_sharing(struct dso *p, const dl_extinfo *extinfo, ssize_t *relro_fd_offset)
+{
+	if (extinfo == NULL) {
+		return;
+	}
+	if (extinfo->flag & DL_EXT_WRITE_RELRO) {
+		LD_LOGD("Serializing GNU_RELRO %{public}s", p->name);
+		if (serialize_gnu_relro(extinfo->relro_fd, p, relro_fd_offset) < 0) {
+			LD_LOGE("Error serializing GNU_RELRO %{public}s", p->name);
+			error("Error serializing GNU_RELRO");
+			if (runtime) longjmp(*rtld_fail, 1);
+		}
+	} else if (extinfo->flag & DL_EXT_USE_RELRO) {
+		LD_LOGD("Mapping GNU_RELRO %{public}s", p->name);
+		if (map_gnu_relro(extinfo->relro_fd, p, relro_fd_offset) < 0) {
+			LD_LOGE("Error mapping GNU_RELRO %{public}s", p->name);
+			error("Error mapping GNU_RELRO");
+			if (runtime) longjmp(*rtld_fail, 1);
+		}
+	}
+}
+
+static void set_bss_vma_name(char *path_name, void *addr, size_t zeromap_size)
+{
+	char so_bss_name[ANON_NAME_MAX_LEN];
+	if (path_name == NULL) {
+		snprintf(so_bss_name, ANON_NAME_MAX_LEN, ".bss");
+	} else {
+		char *t = strrchr(path_name, '/');
+		if (t) {
+			snprintf(so_bss_name, ANON_NAME_MAX_LEN, "%s.bss", ++t);
+		} else {
+			snprintf(so_bss_name, ANON_NAME_MAX_LEN, "%s.bss", path_name);
+		}
+	}
+
+	prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, addr, zeromap_size, so_bss_name);
+}
+
+static void find_and_set_bss_name(struct dso *p)
+{
+	size_t  cnt;
+	Phdr *ph = p->phdr;
+	for (cnt = p->phnum; cnt--; ph = (void *)((char *)ph + p->phentsize)) {
+		if (ph->p_type != PT_LOAD) continue;
+		size_t seg_start = p->base + ph->p_vaddr;
+		size_t seg_file_end = seg_start + ph->p_filesz + PAGE_SIZE - 1 & -PAGE_SIZE;
+		size_t seg_max_addr = seg_start + ph->p_memsz + PAGE_SIZE - 1 & -PAGE_SIZE;
+		size_t zeromap_size = seg_max_addr - seg_file_end;
+		if (zeromap_size > 0 && (ph->p_flags & PF_W)) {
+			set_bss_vma_name(p->name, (void *)seg_file_end, zeromap_size);
+		}
+	}
+}
diff --git a/ldso/dynlink_rand.c b/ldso/dynlink_rand.c
new file mode 100644
index 00000000..c3282cf6
--- /dev/null
+++ b/ldso/dynlink_rand.c
@@ -0,0 +1,244 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "dynlink_rand.h"
+
+#include <stdlib.h>
+#include <sys/mman.h>
+#include <sys/random.h>
+#include <unistd.h>
+
+#define HANDLE_INCREASE 2
+#define TASK_BASE_CAPACITY 8
+
+// linked list node for handle randomization
+struct handle_node {
+    struct handle_node *next;
+    void *handle;
+    struct dso *dso;
+};
+
+// linked list for handle randomization
+static struct handle_node *handle_map_list = NULL;
+
+static uintptr_t saved_handle = 0;
+
+void *add_handle_node(void *handle, struct dso *dso)
+{
+    struct handle_node *node = __libc_malloc(sizeof(*node));
+    if (!node) {
+        return NULL;
+    }
+    node->handle = handle;
+    node->dso = dso;
+    node->next = handle_map_list;
+    handle_map_list = node;
+    return node;
+}
+
+struct dso *find_dso_by_handle(void *handle)
+{
+    struct handle_node *node = handle_map_list;
+    while (node) {
+        if (node->handle == handle) {
+            return node->dso;
+        }
+        node = node->next;
+    }
+    return NULL;
+}
+
+static void *find_handle_by_dso(struct dso *dso)
+{
+    struct handle_node *node = handle_map_list;
+    while (node) {
+        if (node->dso == dso) {
+            return node->handle;
+        }
+        node = node->next;
+    }
+    return 0;
+}
+
+void remove_handle_node(void *handle)
+{
+    struct handle_node *node = handle_map_list;
+    struct handle_node *pre_node = NULL;
+    while (node) {
+        if (node->handle == handle) {
+            if (pre_node) {
+                pre_node->next = node->next;
+            } else {
+                handle_map_list = node->next;
+            }
+            __libc_free(node);
+            return;
+        } else {
+            pre_node = node;
+            node = node->next;
+        }
+    }
+}
+
+static void *gen_handle(void)
+{
+    uintptr_t handle = saved_handle;
+    do {
+        if (getrandom(&handle, sizeof handle, GRND_RANDOM | GRND_NONBLOCK) == -1) {
+            handle += HANDLE_INCREASE;
+            saved_handle = handle;
+        }
+    } while (find_dso_by_handle((void *)handle) || handle == 0);
+    return (void *)handle;
+}
+
+void *assign_valid_handle(struct dso *p)
+{
+    void *handle = find_handle_by_dso(p);
+    if (handle == 0) {
+        handle = gen_handle();
+        if (!add_handle_node(handle, p)) {
+            handle = 0;
+        }
+    }
+    return handle;
+}
+
+struct loadtasks *create_loadtasks(void)
+{
+    struct loadtasks *tasks = __libc_malloc(sizeof(struct loadtasks));
+    if (tasks) {
+        tasks->array = NULL;
+        tasks->capacity = 0;
+        tasks->length = 0;
+        return tasks;
+    }
+    return NULL;
+}
+
+bool append_loadtasks(struct loadtasks *tasks, struct loadtask *item)
+{
+    if (tasks->length + 1 > tasks->capacity) {
+        size_t new_cap = 0;
+        new_cap = tasks->capacity + TASK_BASE_CAPACITY;
+        void *realloced = NULL;
+        if (tasks->array) {
+            realloced = __libc_realloc(tasks->array, new_cap * sizeof(struct loadtask *));
+        } else {
+            realloced = __libc_malloc(TASK_BASE_CAPACITY * sizeof(struct loadtask *));
+        }
+        if (realloced) {
+            tasks->array = realloced;
+            tasks->capacity = new_cap;
+        } else {
+            return false;
+        }
+    }
+    tasks->array[tasks->length] = item;
+    tasks->length += 1;
+    return true;
+}
+
+void free_task(struct loadtask *task)
+{
+    if (task == NULL) {
+        return;
+    }
+    if (task->name) {
+        __libc_free(task->name);
+        task->name = NULL;
+    }
+    if (task->allocated_buf) {
+        __libc_free(task->allocated_buf);
+        task->allocated_buf = NULL;
+    }
+    if (task->dyn_map_len) {
+        munmap(task->dyn_map, task->dyn_map_len);
+        task->dyn_map = NULL;
+        task->dyn_map_len = 0;
+    }
+    if (task->str_map_len) {
+        munmap(task->str_map, task->str_map_len);
+        task->str_map = NULL;
+        task->str_map_len = 0;
+    }
+    if (task->fd != -1 && task->fd) {
+        close(task->fd);
+        task->fd = -1;
+    }
+    __libc_free(task);
+}
+
+struct loadtask *get_loadtask(struct loadtasks *tasks, size_t index)
+{
+    if (tasks && tasks->array && (index < tasks->length)) {
+        return tasks->array[index];
+    } else {
+        return NULL;
+    }
+}
+
+void free_loadtasks(struct loadtasks *tasks)
+{
+    if (tasks) {
+        if (tasks->length) {
+            for (int i = 0; i < tasks->length; i++) {
+                free_task(get_loadtask(tasks, i));
+            }
+            tasks->length = 0;
+        }
+        if (tasks->array) {
+            __libc_free(tasks->array);
+            tasks->array = NULL;
+        }
+        tasks->capacity = 0;
+        __libc_free(tasks);
+    }
+}
+
+void shuffle_loadtasks(struct loadtasks *tasks)
+{
+    size_t index = 0;
+    struct loadtask *task = NULL;
+    for (size_t i = 0; i < tasks->length; i++) {
+        if (getrandom(&index, sizeof index, GRND_RANDOM | GRND_NONBLOCK) == -1) {
+            return;
+        } else {
+            index %= tasks->length;
+            task = tasks->array[i];
+            tasks->array[i] = tasks->array[index];
+            tasks->array[index] = task;
+        }
+    }
+}
+
+struct loadtask *create_loadtask(const char *name, struct dso *needed_by, ns_t *ns, bool check_inherited)
+{
+    size_t name_len = strlen(name);
+    char *name_buf = (char *)__libc_malloc(name_len + 1);
+    if (!name_buf) {
+        return NULL;
+    }
+    struct loadtask *task = __libc_calloc(1, sizeof(struct loadtask));
+    if (!task) {
+        return NULL;
+    }
+    strcpy(name_buf, name);
+    task->name = name_buf;
+    task->needed_by = needed_by;
+    task->namespace = ns;
+    task->check_inherited = check_inherited;
+    return task;
+}
diff --git a/ldso/dynlink_rand.h b/ldso/dynlink_rand.h
new file mode 100644
index 00000000..2408db4e
--- /dev/null
+++ b/ldso/dynlink_rand.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef DYNLINK_RAND_H
+#define DYNLINK_RAND_H
+
+#include <limits.h>
+#include <stdbool.h>
+#include <stddef.h>
+
+#include "libc.h"
+#include "dynlink.h"
+#include "namespace.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct dso;
+
+#define READ_ELF_LENGTH 896
+
+// load library context
+struct loadtask {
+    // parameters
+    const char *name;
+    struct dso *needed_by;
+    ns_t *namespace;
+    bool check_inherited;
+    bool isloaded;
+
+    // variables for load library
+    char buf[PATH_MAX + 1];
+    const char *pathname;
+    struct dso *p;
+    int fd;
+    uint64_t file_offset; /* Used to read an uncompress library from a zip file, file_offset is relative offset of start of zip file. */
+
+    // variables for map library
+    Ehdr ehdr_buf[(READ_ELF_LENGTH + sizeof(Ehdr)) / sizeof(Ehdr)];
+    void *allocated_buf;
+    size_t phsize;
+    Ehdr *eh;
+    Phdr *ph0;
+    size_t dyn;
+    size_t tls_image;
+
+    void *dyn_map;
+    size_t dyn_map_len;
+    size_t *dyn_addr;
+    void *str_map;
+    size_t str_map_len;
+    char *str_addr;
+    struct tls_module tls;
+};
+
+// dynamic array for loadtask
+struct loadtasks {
+    struct loadtask **array;
+    size_t capacity;
+    size_t length;
+};
+
+hidden void *add_handle_node(void *handle, struct dso *dso);
+hidden struct dso *find_dso_by_handle(void *handle);
+hidden void remove_handle_node(void *handle);
+hidden void *assign_valid_handle(struct dso *p);
+
+hidden struct loadtasks *create_loadtasks(void);
+hidden bool append_loadtasks(struct loadtasks *tasks, struct loadtask *item);
+hidden void free_task(struct loadtask *task);
+hidden struct loadtask *get_loadtask(struct loadtasks *tasks, size_t index);
+hidden void free_loadtasks(struct loadtasks *tasks);
+hidden void shuffle_loadtasks(struct loadtasks *tasks);
+hidden struct loadtask *create_loadtask(const char *name, struct dso *needed_by, ns_t *ns, bool check_inherited);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/ldso/ld_log.c b/ldso/ld_log.c
new file mode 100644
index 00000000..26d9d934
--- /dev/null
+++ b/ldso/ld_log.c
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "ld_log.h"
+
+static bool ld_log_enable = false;
+static bool ld_dlclose_debug = false;
+
+#ifdef OHOS_ENABLE_PARAMETER
+#include <fcntl.h>
+#include <stdint.h>
+#include <string.h>
+#include <sys/prctl.h>
+#include <unistd.h>
+
+#include "sys_param.h"
+
+#define SYSPARAM_LENGTH 32
+#define PROCESS_NAME_LEN 1024
+
+static char *get_app_name(char *buf, size_t length)
+{
+    char *app = NULL;
+    int fd = open("/proc/self/cmdline", O_RDONLY);
+    if (fd != -1) {
+        ssize_t ret = read(fd, buf, length - 1);
+        if (ret != -1) {
+            buf[ret] = 0;
+            app = strrchr(buf, '/');
+            if (app) {
+                app++;
+            } else {
+                app = buf;
+            }
+            char *app_end = strchr(app, ':');
+            if (app_end) {
+                *app_end = 0;
+            }
+        }
+        close(fd);
+    }
+    return app;
+}
+
+static bool get_ld_log_value()
+{
+    char buf[PROCESS_NAME_LEN];
+    char *path = get_app_name(buf, PROCESS_NAME_LEN);
+    if (!path) {
+        return false;
+    }
+
+    char app_param_name[PROCESS_NAME_LEN] = "musl.log.ld.app.";
+    strcat(app_param_name, path);
+    static CachedHandle app_param_handle = NULL;
+    static CachedHandle all_param_handle = NULL;
+    if (app_param_handle == NULL) {
+        app_param_handle = CachedParameterCreate(app_param_name, "false");
+    }
+    if (all_param_handle == NULL) {
+        all_param_handle = CachedParameterCreate("musl.log.ld.all", "false");
+    }
+    return (get_bool_sysparam(app_param_handle) || get_bool_sysparam(all_param_handle));
+}
+
+static bool get_ld_debug_dlclose_value()
+{
+    static CachedHandle param_handle = NULL;
+    if (param_handle == NULL) {
+        param_handle = CachedParameterCreate("musl.ld.debug.dlclose", "false");
+    }
+    return get_bool_sysparam(param_handle);
+}
+#endif
+
+void ld_log_reset()
+{
+#if (defined(OHOS_ENABLE_PARAMETER))
+    ld_dlclose_debug = get_ld_debug_dlclose_value();
+    if (!is_musl_log_enable()) {
+        ld_log_enable = false;
+        return;
+    }
+    ld_log_enable = get_ld_log_value();
+#else
+    ld_log_enable = is_musl_log_enable();
+#endif
+}
+
+bool get_ld_log_enable()
+{
+    return ld_log_enable;
+}
+
+bool is_dlclose_debug_enable()
+{
+    return ld_dlclose_debug;
+}
diff --git a/ldso/ld_log.h b/ldso/ld_log.h
new file mode 100644
index 00000000..47f70587
--- /dev/null
+++ b/ldso/ld_log.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef LD_LOG_H
+#define LD_LOG_H
+
+#include <musl_log.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define LD_LOG_ERROR 1
+#define LD_LOG_WARNING 2
+#define LD_LOG_INFO 4
+#define LD_LOG_DEBUG 8
+
+#define LD_LOG_LEVEL (LD_LOG_ERROR | LD_LOG_WARNING | LD_LOG_INFO)
+
+#define LD_LOG_TAG "MUSL-LDSO"
+
+hidden bool get_ld_log_enable();
+hidden void ld_log_reset();
+
+hidden bool is_dlclose_debug_enable();
+
+#if ((LD_LOG_LEVEL & LD_LOG_ERROR) && (defined(OHOS_ENABLE_PARAMETER) || defined(ENABLE_MUSL_LOG)))
+#define LD_LOGE(...) (void)HiLogAdapterPrint(MUSL_LOG_TYPE, LOG_ERROR, MUSL_LOG_DOMAIN, LD_LOG_TAG, __VA_ARGS__);
+#else
+#define LD_LOGE(...)
+#endif
+
+#if ((LD_LOG_LEVEL & LD_LOG_WARNING) && (defined(OHOS_ENABLE_PARAMETER) || defined(ENABLE_MUSL_LOG)))
+#define LD_LOGW(...) if (get_ld_log_enable()) {   \
+    (void)HiLogAdapterPrint(MUSL_LOG_TYPE, LOG_WARN, MUSL_LOG_DOMAIN, LD_LOG_TAG, __VA_ARGS__); \
+}
+#else
+#define LD_LOGW(...)
+#endif
+
+#if ((LD_LOG_LEVEL & LD_LOG_INFO) && (defined(OHOS_ENABLE_PARAMETER) || defined(ENABLE_MUSL_LOG)))
+#define LD_LOGI(...) if (get_ld_log_enable()) {   \
+    (void)HiLogAdapterPrint(MUSL_LOG_TYPE, LOG_INFO, MUSL_LOG_DOMAIN, LD_LOG_TAG, __VA_ARGS__);    \
+}
+#else
+#define LD_LOGI(...)
+#endif
+
+#if (LD_LOG_LEVEL & LD_LOG_DEBUG) && (defined(OHOS_ENABLE_PARAMETER) || defined(ENABLE_MUSL_LOG))
+#define LD_LOGD(...) if (get_ld_log_enable()) {   \
+    (void)HiLogAdapterPrint(MUSL_LOG_TYPE, LOG_DEBUG, MUSL_LOG_DOMAIN, LD_LOG_TAG, __VA_ARGS__);    \
+}
+#else
+#define LD_LOGD(...)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // LD_LOG_H
diff --git a/ldso/namespace.c b/ldso/namespace.c
new file mode 100644
index 00000000..a6802845
--- /dev/null
+++ b/ldso/namespace.c
@@ -0,0 +1,613 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "namespace.h"
+
+#include "ld_log.h"
+#include "strops.h"
+
+static ns_t g_ns_default;
+static nslist g_ns_list;
+
+#ifndef NSLIST_DEFAULT_SIZE
+#define NSLIST_DEFAULT_SIZE 16
+#endif
+#ifndef DSOLIST_DEFAULT_SIZE
+#define DSOLIST_DEFAULT_SIZE 16
+#endif
+#ifndef INHERIT_DEFAULT_SIZE
+#define INHERIT_DEFAULT_SIZE 16
+#endif
+
+#ifdef UNIT_TEST_STATIC
+    #define UT_STATIC
+#else
+    #define UT_STATIC static
+#endif
+
+#define ALLOW_ALL_SHARED_LIBS "allow_all_shared_libs"
+
+static ns_inherit_list *nsinherits_alloc()
+{
+    ns_inherit_list *nsinl;
+    nsinl = (ns_inherit_list *)__libc_calloc(1, sizeof *nsinl);
+
+    if (nsinl) {
+        nsinl->size = INHERIT_DEFAULT_SIZE;
+        nsinl->inherits = (ns_inherit **)__libc_calloc(INHERIT_DEFAULT_SIZE, sizeof *nsinl->inherits);
+        if (!nsinl->inherits) {
+            LD_LOGE("nsinherits_alloc failed,return NULL!");
+            __libc_free(nsinl);
+            nsinl = NULL;
+        }
+    }
+    return nsinl;
+}
+
+static void nsinherits_free(ns_inherit_list *nsinl)
+{
+    if (!nsinl) {
+        return;
+    }
+    for (size_t i = 0; i < nsinl->num; i++) {
+        strlist_free(nsinl->inherits[i]->shared_libs);
+        __libc_free(nsinl->inherits[i]);
+    }
+    __libc_free(nsinl->inherits);
+    __libc_free(nsinl);
+}
+
+UT_STATIC void nsinherits_realloc(ns_inherit_list *nsinl)
+{
+    if (!nsinl) {
+        return;
+    }
+    size_t size = 2 * nsinl->size;
+    if (size) {
+        ns_inherit **inherits;
+        inherits = (ns_inherit **)__libc_realloc(nsinl->inherits, size * (sizeof *nsinl->inherits));
+        if (!inherits) {
+            LD_LOGE("nsinherits_realloc failed!");
+            return;
+        }
+        nsinl->size = size;
+        nsinl->inherits = inherits;
+    }
+    return;
+}
+
+static dsolist *dsolist_alloc()
+{
+    dsolist *dsol;
+    dsol = (dsolist *)__libc_calloc(1, sizeof *dsol);
+
+    if (dsol) {
+        dsol->size = DSOLIST_DEFAULT_SIZE;
+        dsol->dsos = (struct dso **)__libc_calloc(DSOLIST_DEFAULT_SIZE, sizeof *dsol->dsos);
+        if (!dsol->dsos) {
+            LD_LOGE("dsolist_alloc failed,return NULL!");
+            __libc_free(dsol);
+            dsol = NULL;
+        }
+    }
+    return dsol;
+}
+
+static void dsolist_realloc(dsolist *dsol)
+{
+    if (!dsol) {
+        return;
+    }
+    size_t size = 2 * dsol->size;
+    if (size) {
+        struct dso **ds;
+        ds = (struct dso **)__libc_realloc(dsol->dsos, size * (sizeof *dsol->dsos));
+        if (!ds) {
+            LD_LOGE("dsolist_realloc failed!");
+            return;
+        }
+        dsol->size = size;
+        dsol->dsos = ds;
+    }
+    return;
+}
+
+ns_t *ns_alloc()
+{
+    ns_t *nst = (ns_t *)__libc_calloc(1, sizeof *nst);
+    nst->ns_dsos = dsolist_alloc();
+    if (!nst->ns_dsos) {
+        LD_LOGE("ns_alloc failed,return NULL!");
+        __libc_free(nst);
+        nst = NULL;
+    }
+    return nst;
+}
+
+void ns_free(ns_t *ns)
+{
+    if (!ns) {
+        return;
+    }
+    if (ns->ns_dsos) {
+        __libc_free(ns->ns_dsos);
+        ns->ns_dsos = NULL;
+    }
+    if (ns->ns_name) {
+        __libc_free(ns->ns_name);
+        ns->ns_name = NULL;
+    }
+    if (ns->env_paths) {
+        __libc_free(ns->env_paths);
+        ns->env_paths = NULL;
+    }
+    if (ns->lib_paths) {
+        __libc_free(ns->lib_paths);
+        ns->lib_paths = NULL;
+    }
+    if (ns->asan_lib_paths) {
+        __libc_free(ns->asan_lib_paths);
+        ns->asan_lib_paths = NULL;
+    }
+    strlist_free(ns->permitted_paths);
+    strlist_free(ns->asan_permitted_paths);
+    strlist_free(ns->allowed_libs);
+    nsinherits_free(ns->ns_inherits);
+    __libc_free(ns);
+}
+
+void ns_add_dso(ns_t *ns, struct dso *dso)
+{
+    if (!ns || !dso) {
+        return;
+    }
+    if (!ns->ns_dsos) {
+        ns->ns_dsos = dsolist_alloc();
+    }
+    if (!ns->ns_dsos) {
+        return;
+    }
+    if (ns->ns_dsos->num == ns->ns_dsos->size) {
+        /* if list is full, realloc size to double*/
+        dsolist_realloc(ns->ns_dsos);
+    }
+    if (ns->ns_dsos->num < ns->ns_dsos->size) {
+        /* realloc succ */
+        ns->ns_dsos->dsos[ns->ns_dsos->num] = dso;
+        ns->ns_dsos->num++;
+    }
+    return;
+}
+
+nslist *nslist_init()
+{
+    g_ns_list.size = NSLIST_DEFAULT_SIZE;
+    g_ns_list.num = 0;
+    g_ns_list.nss = (ns_t **)__libc_calloc(NSLIST_DEFAULT_SIZE, sizeof *g_ns_list.nss);
+    if (!g_ns_list.nss) {
+        LD_LOGE("nslist_init failed!");
+        return NULL;
+    }
+    return &g_ns_list;
+}
+
+static void nslist_realloc()
+{
+    size_t size = 2 * g_ns_list.size;
+    if (size) {
+        ns_t **nss;
+        nss = (ns_t **)__libc_realloc(g_ns_list.nss, size * (sizeof *g_ns_list.nss));
+        if (!nss) {
+            LD_LOGE("nslist_realloc failed!");
+            return;
+        }
+        g_ns_list.size = size;
+        g_ns_list.nss = nss;
+    }
+    return;
+}
+
+void nslist_add_ns(ns_t *ns)
+{
+    if (!ns) {
+        return;
+    }
+
+    if (g_ns_list.num == g_ns_list.size) {
+        /* if list is full, realloc size to double*/
+        nslist_realloc();
+    }
+    if (g_ns_list.num < g_ns_list.size) {
+        /* realloc succ */
+        g_ns_list.nss[g_ns_list.num] = ns;
+        g_ns_list.num++;
+    }
+    return;
+}
+
+ns_t *get_default_ns()
+{
+    return &g_ns_default;
+}
+
+/* set namespace attributes*/
+void ns_set_name(ns_t *ns, const char *name)
+{
+    if (!ns || !name) {
+        return;
+    }
+    if (ns->ns_name) __libc_free(ns->ns_name);
+    ns->ns_name = ld_strdup(name);
+    strtrim(ns->ns_name);
+    LD_LOGD("ns_set_name ns_name:%{public}s.", ns->ns_name);
+}
+
+void ns_set_env_paths(ns_t *ns, const char *env_paths)
+{
+    if (!ns) {
+        return;
+    }
+    if (ns->env_paths) __libc_free(ns->env_paths);
+    if (env_paths) {
+        ns->env_paths = ld_strdup(env_paths);
+        strtrim(ns->env_paths);
+    } else {
+        ns->env_paths = NULL;
+    }
+    LD_LOGD("ns_set_env_paths ns[%{public}s] env_paths:%{public}s.", ns->ns_name, ns->env_paths);
+}
+
+void ns_set_lib_paths(ns_t *ns, const char *lib_paths)
+{
+    if (!ns) {
+        return;
+    }
+    if (ns->lib_paths) __libc_free(ns->lib_paths);
+    if (lib_paths) {
+        ns->lib_paths = ld_strdup(lib_paths);
+        strtrim(ns->lib_paths);
+    } else {
+        ns->lib_paths = NULL;
+    }
+    LD_LOGD("ns_set_lib_paths ns[%{public}s] lib_paths:%{public}s.", ns->ns_name, ns->lib_paths);
+}
+
+void ns_set_asan_lib_paths(ns_t *ns, const char *asan_lib_paths)
+{
+    if (!ns) {
+        return;
+    }
+    if (ns->asan_lib_paths) {
+        __libc_free(ns->asan_lib_paths);
+    }
+    if (asan_lib_paths) {
+        ns->asan_lib_paths = ld_strdup(asan_lib_paths);
+        strtrim(ns->asan_lib_paths);
+    } else {
+        ns->asan_lib_paths = NULL;
+    }
+    LD_LOGD("ns_set_asan_lib_paths ns[%{public}s] asan_lib_paths:%{public}s.", ns->ns_name, ns->asan_lib_paths);
+}
+
+void ns_set_permitted_paths(ns_t *ns, const char *permitted_paths)
+{
+    if (!ns) {
+        return;
+    }
+    if (ns->permitted_paths) strlist_free(ns->permitted_paths);
+    ns->permitted_paths = strsplit(permitted_paths, ":");
+    LD_LOGD("ns_set_permitted_paths ns[%{public}s] permitted_paths:%{public}s.", ns->ns_name, permitted_paths);
+}
+
+void ns_set_asan_permitted_paths(ns_t *ns, const char *asan_permitted_paths)
+{
+    if (!ns) {
+        return;
+    }
+    if (ns->asan_permitted_paths) {
+        strlist_free(ns->asan_permitted_paths);
+    }
+    ns->asan_permitted_paths = strsplit(asan_permitted_paths, ":");
+    LD_LOGD("ns_set_asan_permitted_paths ns[%{public}s] asan_permitted_paths:%{public}s.",
+        ns->ns_name,
+        asan_permitted_paths);
+}
+
+void ns_set_separated(ns_t *ns, bool separated)
+{
+    if (!ns) {
+        return;
+    }
+    ns->separated = separated;
+    LD_LOGD("ns_set_separated ns[%{public}s] separated:%{public}d.", ns->ns_name, ns->separated);
+}
+
+void ns_set_allowed_libs(ns_t *ns, const char *allowed_libs)
+{
+    if (!ns) {
+        return;
+    }
+
+    if (ns->allowed_libs) strlist_free(ns->allowed_libs);
+    ns->allowed_libs = NULL;
+    if (allowed_libs) {
+        /* if setted and not empty, split to list. */
+        char *a_libs = ld_strdup(allowed_libs);
+        if (strtrim(a_libs) > 0) ns->allowed_libs = strsplit(a_libs, ":");
+        __libc_free(a_libs);
+    }
+    LD_LOGD("ns_set_allowed_libs ns[%{public}s] allowed_libs:%{public}s.", ns->ns_name, allowed_libs);
+}
+
+ns_t *find_ns_by_name(const char *ns_name)
+{
+    if (!ns_name) {
+        return NULL;
+    }
+    if (strcmp(NS_DEFAULT_NAME, ns_name) == 0) {
+        LD_LOGD("find_ns_by_name return default namespace!");
+        return get_default_ns();
+    }
+    for (size_t i = 0; i < g_ns_list.num; i++) {
+        if (strcmp(g_ns_list.nss[i]->ns_name, ns_name) == 0) {
+            return g_ns_list.nss[i];
+        }
+    }
+    LD_LOGD("find_ns_by_name ns_name[%{public}s] failed,return NULL!", ns_name);
+    return NULL;
+}
+
+static ns_inherit *find_ns_inherit(ns_t *ns, ns_t *inherited)
+{
+    if (!ns || !inherited) {
+        return NULL;
+    }
+    if (ns->ns_inherits) {
+        for (size_t i = 0; i < ns->ns_inherits->num; i++) {
+            if (ns->ns_inherits->inherits[i]->inherited_ns == inherited) return ns->ns_inherits->inherits[i];
+        }
+    }
+    LD_LOGD(
+        "find_ns_inherit ns[%{public}s] ns_inherited[%{public}s] failed,return NULL!", ns->ns_name, inherited->ns_name);
+    return NULL;
+}
+
+void ns_add_inherit(ns_t *ns, ns_t *ns_inherited, const char *shared_libs)
+{
+    bool need_add = false;
+    if (!ns || !ns_inherited) {
+        return;
+    }
+
+    ns_inherit *inherit = find_ns_inherit(ns, ns_inherited);
+    if (!inherit) {
+        inherit = __libc_calloc(1, sizeof *inherit);
+        if (!inherit) {
+            LD_LOGE("ns_add_inherit ns[%{public}s] ns_inherited[%{public}s] calloc failed!",
+                ns->ns_name,
+                ns_inherited->ns_name);
+            return;
+        }
+        inherit->inherited_ns = ns_inherited;
+        need_add = true;
+        LD_LOGD("ns_add_inherit ns[%{public}s] ns_inherited[%{public}s] need_add is true.",
+            ns->ns_name,
+            ns_inherited->ns_name);
+    }
+
+    if (inherit->shared_libs) {
+        strlist_free(inherit->shared_libs);
+        inherit->shared_libs = NULL;
+    }
+
+    /* if setted and not empty, split to list. */
+    if (shared_libs) {
+        char *s_libs = ld_strdup(shared_libs);
+        if (strtrim(s_libs) > 0) inherit->shared_libs = strsplit(shared_libs, ":");
+        __libc_free(s_libs);
+    }
+
+    if (!need_add) {
+        LD_LOGD(
+            "ns_add_inherit ns[%{public}s] ns_inherited[%{public}s] not need_add!", ns->ns_name, ns_inherited->ns_name);
+        return;
+    }
+
+    if (!ns->ns_inherits) {
+        ns->ns_inherits = nsinherits_alloc();
+    }
+
+    if (!ns->ns_inherits) {
+        if (inherit->shared_libs) strlist_free(inherit->shared_libs);
+        LD_LOGD("ns_add_inherit ns[%{public}s] ns_inherited[%{public}s] nsinherits_alloc failed!",
+            ns->ns_name,
+            ns_inherited->ns_name);
+        __libc_free(inherit);
+        return;
+    }
+
+    if (ns->ns_inherits->num == ns->ns_inherits->size) {
+        /* if list is full, realloc size to double*/
+        LD_LOGD("ns_add_inherit ns[%{public}s] ns_inherited[%{public}s] list is full, realloc size to double!",
+            ns->ns_name,
+            ns_inherited->ns_name);
+        nsinherits_realloc(ns->ns_inherits);
+    }
+
+    if (ns->ns_inherits->num < ns->ns_inherits->size) {
+        /* realloc succ */
+        LD_LOGD("ns_add_inherit ns[%{public}s] ns_inherited[%{public}s] realloc success!",
+            ns->ns_name,
+            ns_inherited->ns_name);
+        ns->ns_inherits->inherits[ns->ns_inherits->num] = inherit;
+        ns->ns_inherits->num++;
+    } else {
+        /* realloc failed */
+        LD_LOGD("ns_add_inherit ns[%{public}s] ns_inherited[%{public}s] realloc failed!",
+            ns->ns_name,
+            ns_inherited->ns_name);
+        if (inherit->shared_libs) strlist_free(inherit->shared_libs);
+        __libc_free(inherit);
+    }
+    return;
+}
+
+/* check library's pathname if accessible in this namespace */
+bool is_accessible(ns_t *ns, const char *lib_pathname, bool is_asan, bool check_inherited)
+{
+    if (check_inherited && !ns->separated) {
+        LD_LOGD("is_accessible ns [%{public}s] is not separated, return true.", ns->ns_name);
+        return true;
+    }
+    if (ns->allowed_libs) {
+        char *shortname = strrchr(lib_pathname, '/');
+        if (shortname) {
+            shortname += 1;
+            size_t i = 0;
+            for (; i < ns->allowed_libs->num; i++) {
+                if (strcmp(shortname, ns->allowed_libs->strs[i]) == 0) {
+                    break;
+                }
+            }
+            if (i >= ns->allowed_libs->num) {
+                LD_LOGD("is_accessible ns [%{public}s] lib_pathname [%{public}s] is not in allowed_libs, return false.",
+                    ns->ns_name,
+                    lib_pathname);
+                return false;
+            }
+        }
+    }
+    strlist *paths;
+    if (ns->env_paths && (paths = strsplit(ns->env_paths, ":"))) {
+        for (size_t i = 0; i < paths->num; i++) {
+            size_t len = strlen(paths->strs[i]);
+            if (strncmp(lib_pathname, paths->strs[i], len) == 0 &&
+                lib_pathname[len] == '/' &&
+                !strchr(lib_pathname + len + 1, '/')) {
+                LD_LOGD("is_accessible ns [%{public}s] lib_pathname [%{public}s] in env_paths, return true.",
+                    ns->ns_name,
+                    lib_pathname);
+                strlist_free(paths);
+                return true;
+            }
+        }
+        strlist_free(paths);
+    }
+
+    if (is_asan) {
+        if (check_asan_path(ns, lib_pathname)) {
+            LD_LOGD("is_accessible ns [%{public}s] lib_pathname [%{public}s] check_asan_path success, return true.",
+                ns->ns_name,
+                lib_pathname);
+            return true;
+        }
+    }
+
+    if (ns->lib_paths && (paths = strsplit(ns->lib_paths, ":"))) {
+        for (size_t i = 0; i < paths->num; i++) {
+            size_t len = strlen(paths->strs[i]);
+            if (strncmp(lib_pathname, paths->strs[i], len) == 0 &&
+                lib_pathname[len] == '/' &&
+                !strchr(lib_pathname + len + 1, '/')) {
+                strlist_free(paths);
+                LD_LOGD("is_accessible ns [%{public}s] lib_pathname [%{public}s] in lib_paths, return true.",
+                    ns->ns_name,
+                    lib_pathname);
+                return true;
+            }
+        }
+        strlist_free(paths);
+    }
+
+    if (ns->permitted_paths) {
+        for (size_t i = 0; i < ns->permitted_paths->num; i++) {
+            size_t len = strlen(ns->permitted_paths->strs[i]);
+            if (strncmp(lib_pathname, ns->permitted_paths->strs[i], len) == 0 &&
+                lib_pathname[len] == '/') {
+                LD_LOGD("is_accessible ns [%{public}s] lib_pathname [%{public}s] in permitted_paths, return true.",
+                    ns->ns_name,
+                    lib_pathname);
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+bool check_asan_path(ns_t *ns, const char *lib_pathname)
+{
+    strlist *paths;
+    if (ns->asan_lib_paths && (paths = strsplit(ns->asan_lib_paths, ":"))) {
+        for (size_t i = 0; i < paths->num; i++) {
+            size_t len = strlen(paths->strs[i]);
+            if (strncmp(lib_pathname, paths->strs[i], len) == 0 &&
+                lib_pathname[len] == '/' &&
+                !strchr(lib_pathname + len + 1, '/')) {
+                strlist_free(paths);
+                LD_LOGD("check_asan_path ns [%{public}s] lib_pathname [%{public}s] in asan_lib_paths, return true.",
+                    ns->ns_name,
+                    lib_pathname);
+                return true;
+            }
+        }
+        strlist_free(paths);
+    }
+    if (ns->asan_permitted_paths) {
+        for (size_t i = 0; i < ns->asan_permitted_paths->num; i++) {
+            size_t len = strlen(ns->asan_permitted_paths->strs[i]);
+            if (strncmp(lib_pathname, ns->asan_permitted_paths->strs[i], len) == 0 &&
+                lib_pathname[len] == '/') {
+                LD_LOGD(
+                    "check_asan_path ns [%{public}s] lib_pathname [%{public}s] in asan_permitted_paths, return true.",
+                    ns->ns_name,
+                    lib_pathname);
+                return true;
+            }
+        }
+    }
+    LD_LOGD(
+        "check_asan_path ns [%{public}s] lib_pathname [%{public}s] failed, return false.", ns->ns_name, lib_pathname);
+    return false;
+}
+
+bool is_sharable(ns_inherit *inherit, const char *lib_name)
+{
+    if (inherit && lib_name && inherit->shared_libs) {
+        for (size_t i = 0; i < inherit->shared_libs->num; i++) {
+            if (strcmp(inherit->shared_libs->strs[i], lib_name) == 0 ||
+                strcmp(inherit->shared_libs->strs[i], ALLOW_ALL_SHARED_LIBS) == 0) {
+                LD_LOGD("is_sharable inherit [%{public}s] lib_name [%{public}s] found, return true.",
+                    inherit->inherited_ns->ns_name,
+                    lib_name);
+                return true;
+            }
+        }
+        LD_LOGD("is_sharable inherit [%{public}s] lib_name [%{public}s] not found, return false.",
+            inherit->inherited_ns->ns_name,
+            lib_name);
+        return false;
+    }
+    LD_LOGD("is_sharable shared_libs not config, return true.");
+    return true;
+}
+
+void ns_set_flag(ns_t *ns, int flag)
+{
+    if (!ns) {
+        return;
+    }
+    ns->flag = flag;
+    LD_LOGD("ns_set_flag ns[%{public}s] flag:%{public}d.", ns->ns_name, ns->flag);
+}
\ No newline at end of file
diff --git a/ldso/namespace.h b/ldso/namespace.h
new file mode 100644
index 00000000..61b84d4c
--- /dev/null
+++ b/ldso/namespace.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _NAMESPACE_H
+#define _NAMESPACE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdbool.h>
+#include <stdint.h>
+#include "strops.h"
+
+#define NS_DEFAULT_NAME "default"
+struct dso;
+/* define dso list */
+typedef struct _dso_list_ {
+    uint16_t num;
+    uint16_t size;
+    struct dso **dsos;    
+} dsolist;
+/* define namespace struct */
+struct _ns_inherit_list_;
+typedef struct _namespace_t_ {
+    char *ns_name;            /* namespace name */
+    char *env_paths;          /* value of LD_LIBRARY_PATH. splited by ':'. */
+    char *lib_paths;          /* library search paths splited by ':'. */
+
+    char *asan_lib_paths;          /* when asan is enable, library search paths splited by ':'. */
+    strlist *permitted_paths;    /* when separated, permitted search paths splited by ':', including sub dirs. */
+    strlist *asan_permitted_paths;    /* when asan is enable and separated,the same as above.  */
+
+    bool separated;           /* if separated */
+    strlist *allowed_libs;       /* when separated, allowed library names splited by ':'. */
+    dsolist *ns_dsos;         /* dso list in this namespace */
+    struct _ns_inherit_list_ *ns_inherits;   /* inherit list in this namespace */
+    int flag;
+} ns_t;
+/* define namespace list */
+typedef struct _namespaces_list_ {
+    uint16_t num;
+    uint16_t size;
+    ns_t **nss;
+} nslist;
+/* define namespace inherit */
+typedef struct _namespace_inherit_ {
+    ns_t *inherited_ns;       /* inherited namespace */
+    strlist *shared_libs;        /* when inherited, shared library names splited by ':'. */
+} ns_inherit;
+/* define namespace inherit list */
+typedef struct _ns_inherit_list_ {
+    uint16_t num;
+    uint16_t size;
+    ns_inherit **inherits;
+} ns_inherit_list;
+
+/* init g_ns_list */
+nslist *nslist_init();
+
+/* namespace funcs */
+ns_t *ns_alloc();
+void ns_free(ns_t *ns);
+void ns_set_name(ns_t *ns, const char *name);
+void ns_set_env_paths(ns_t *ns, const char *env_paths);
+void ns_set_lib_paths(ns_t *ns, const char *lib_paths);
+void ns_set_asan_lib_paths(ns_t *ns, const char *asan_lib_paths);
+void ns_set_permitted_paths(ns_t *ns, const char *permitted_paths);
+void ns_set_asan_permitted_paths(ns_t *ns, const char *asan_permitted_paths);
+void ns_set_separated(ns_t *ns, bool separated);
+void ns_set_allowed_libs(ns_t *ns, const char *allowed_libs);
+void ns_add_dso(ns_t *ns, struct dso *dso);
+void nslist_add_ns(ns_t *ns);
+void ns_add_inherit(ns_t *ns,ns_t *inherited, const char *shared_libs);
+void ns_set_flag(ns_t *ns, int flag);
+
+/* get default namespace */
+ns_t *get_default_ns();
+
+/* check if library pathname is accessible in the namespace */
+bool is_accessible(ns_t *ns, const char *lib_pathname, bool is_asan, bool check_inherited);
+
+/* check if asan_lib_paths or asan_permitted_paths pathname is accessible in the namespace */
+bool check_asan_path(ns_t *ns, const char *lib_pathname);
+
+/* check if library is sharable in the inherited namespace */
+bool is_sharable(ns_inherit *inherit, const char *lib_name);
+
+/* find namespace by name */
+ns_t *find_ns_by_name(const char *ns_name);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/ldso/ns_config.c b/ldso/ns_config.c
new file mode 100644
index 00000000..84b7b3ec
--- /dev/null
+++ b/ldso/ns_config.c
@@ -0,0 +1,680 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "ns_config.h"
+
+#include <ctype.h>
+#include <stdarg.h>
+
+#include "ld_log.h"
+/*---------------------------- Defines -------------------------------------*/
+#define MAX_LINE_SIZE         (1024)
+#define INI_INVALID_KEY     ((char*)-1)
+
+#ifdef UNIT_TEST_STATIC
+    #define UT_STATIC
+#else
+    #define UT_STATIC static
+#endif
+typedef enum _line_status_ {
+    LINE_UNPROCESSED,
+    LINE_ERROR,
+    LINE_EMPTY,
+    LINE_COMMENT,
+    LINE_SECTION,
+    LINE_VALUE
+} line_status;
+
+#define MAX_KEY_LEN 256
+static char g_key[MAX_KEY_LEN+1] = {0};
+
+static char *config_key_join(const char *join, bool start)
+{
+    if (start) g_key[0] = 0;
+    size_t cnt = MAX_KEY_LEN - strlen(g_key);
+    return strncat(g_key, join, cnt);
+}
+
+static int default_error_callback(const char *format, ...)
+{
+    int ret = 0;
+    va_list argptr;
+    va_start(argptr, format);
+    /* do not print
+    ret = vfprintf(stderr, format, argptr);
+    */
+    va_end(argptr);
+    return ret;
+}
+
+static int (*config_error_callback)(const char *, ...) = default_error_callback;
+
+static void config_set_error_callback(int (*errback)(const char *, ...))
+{
+    if (errback) {
+        config_error_callback = errback;
+    } else {
+        config_error_callback = default_error_callback;
+    }
+}
+
+static line_status config_line(char *line, char *section, char *key, char *value)
+{
+    size_t len;
+    char *split;
+
+    if ((len = strcspn(line, "#;")) == 0) {
+        /* comment line */
+        return LINE_COMMENT;
+    } 
+    line[len] = 0;
+    if ((len = strtrim(line)) == 0) {
+        /* empty line */ 
+         return LINE_EMPTY;
+    } 
+    if (line[0] == '[' && line[len-1] == ']') {
+        /* section name */
+        memcpy(section, line+1, len-2);
+        section[len-2] = 0;
+        strtrim(section);
+        return LINE_SECTION;
+    } 
+    if (split = strchr(line, '=')) {
+        /* key and value */
+        size_t klen, vlen;
+        klen = split - line;
+        vlen = len - klen -1;
+        if (klen > 0) memcpy(key, line, klen);
+        if (vlen > 0) memcpy(value, split+1, vlen);
+        key[klen] = 0;
+        value[vlen] = 0;
+        strtrim(key);
+        strtrim(value);
+        return LINE_VALUE;
+    }
+    return LINE_ERROR;
+}
+
+#define SECTION_DEFAULT_SIZE   16
+#define KV_DEFAULT_SIZE   64
+
+static kvlist * kvlist_alloc(size_t size)
+{
+    kvlist *kvs;
+
+    if (size < KV_DEFAULT_SIZE) size = KV_DEFAULT_SIZE;
+
+    kvs = (kvlist *)__libc_calloc(1, sizeof *kvs);
+    if (kvs) {
+        kvs->key = (char **)__libc_calloc(size, sizeof *kvs->key);
+        kvs->val = (char **)__libc_calloc(size, sizeof *kvs->val);
+        if (kvs->key && kvs->val) {
+            kvs->size = size;
+        } else {
+            __libc_free(kvs->key);
+            __libc_free(kvs->val);
+            __libc_free(kvs);
+            kvs = NULL;
+        }
+    }
+    return kvs;
+}
+
+UT_STATIC void kvlist_realloc(kvlist *kvs)
+{
+    if (!kvs) return;
+    size_t size = 2*kvs->size;
+    if (size) {
+        char **keys, **vals;
+        keys = (char **)__libc_realloc(kvs->key, size * (sizeof *kvs->key));
+        if (!keys) return;
+        kvs->key = keys;
+        vals = (char **)__libc_realloc(kvs->val, size * (sizeof *kvs->val));
+        if (!vals) return;
+        kvs->val = vals;
+        kvs->size = size;
+    }
+
+    return;
+}
+
+static void kvlist_free(kvlist *kvs)
+{
+    size_t i;
+    if (!kvs) return;
+    for (i=0; i<kvs->num; i++) {
+        __libc_free(kvs->key[i]);
+        __libc_free(kvs->val[i]);
+    }
+    __libc_free(kvs->key);
+    __libc_free(kvs->val);
+    __libc_free(kvs);
+}
+
+static section_list *sections_alloc(size_t size)
+{
+    section_list *sections;
+    if (size < SECTION_DEFAULT_SIZE) size = SECTION_DEFAULT_SIZE;
+
+    sections = (section_list *)__libc_calloc(1, sizeof *sections);
+
+    if (sections) {
+        sections->names = (char**)__libc_calloc(size, sizeof *sections->names);
+        sections->kvs = (kvlist**)__libc_calloc(size, sizeof *sections->kvs);
+        if (sections->names && sections->kvs) {
+            sections->size = size;
+        } else {
+            __libc_free(sections->names);
+            __libc_free(sections->kvs);
+            __libc_free(sections);
+            sections = NULL;
+        }
+    }
+    return sections;
+}
+
+UT_STATIC void sections_realloc(section_list *sections)
+{
+    if (!sections) return;
+    size_t size = 2*sections->size;
+    if (size) {
+        char **names;
+        kvlist **kvs;
+        names = (char **)__libc_realloc(sections->names, size * (sizeof *sections->names));
+        if (!names) return;
+        sections->names = names;
+        kvs = (kvlist **)__libc_realloc(sections->kvs, size * (sizeof *sections->kvs));
+        if (!kvs) return;
+        sections->kvs = kvs;
+        sections->size = size;
+    }
+    return;
+}
+
+static void sections_free(section_list *sections)
+{
+    if (!sections) return;
+    for (size_t i=0; i < sections->num; i++) {
+        __libc_free(sections->names[i]);
+        kvlist_free(sections->kvs[i]);
+    }
+    __libc_free(sections->names);
+    __libc_free(sections->kvs);
+    __libc_free(sections);
+}
+
+static void kvlist_set(kvlist *kvs, const char *key, const char *val)
+{
+    size_t i;
+    if (!kvs||!key||!val) return;
+
+    for (i=0; i < kvs->num; i++) {
+        if (!strcmp(kvs->key[i], key)) {
+            break;
+        }
+    }
+
+    if (i < kvs->num) {
+        char * v = ld_strdup(val);
+        if (v) {
+            __libc_free(kvs->val[i]);
+            kvs->val[i] = v;
+        }
+        return;
+    }
+    if (kvs->num == kvs->size) {
+        kvlist_realloc(kvs);
+    }
+    if (kvs->num < kvs->size) {
+        kvs->key[kvs->num] = ld_strdup(key);
+        kvs->val[kvs->num] = ld_strdup(val);
+        if (kvs->key[kvs->num] && kvs->val[kvs->num]) {
+            kvs->num++;
+        } else {
+            __libc_free(kvs->key[kvs->num]);
+            __libc_free(kvs->val[kvs->num]);
+        }
+    }
+    return;
+}
+
+static void sections_set(section_list *sections, const char *name, const char *key, const char *val)
+{
+    kvlist* kvs = NULL;
+    if (!sections||!name||!key||!val) return;
+
+    for(size_t i=0; i < sections->num; i++) {
+        if (!strcmp(sections->names[i], name)) {
+            kvs = sections->kvs[i];
+            break;
+        }
+    }
+    if (kvs) {
+        kvlist_set(kvs,key,val);
+        return;
+    }
+
+    if (sections->num == sections->size) {
+       sections_realloc(sections);
+    }
+    
+    if (sections->num < sections->size) {
+        kvs = kvlist_alloc(0);
+        sections->names[sections->num] = ld_strdup(name);
+        sections->kvs[sections->num] = kvs;
+        if (sections->names[sections->num] && kvs) {
+            sections->num++;
+            kvlist_set(kvs,key,val);
+        } else {
+            __libc_free(sections->names[sections->num]);
+            kvlist_free(kvs);
+        }
+    }
+}
+
+static section_list *config_load(const char *filepath)
+{
+    FILE *file;
+    char line[MAX_LINE_SIZE+1];
+    char section[MAX_LINE_SIZE+1];
+    char key[MAX_LINE_SIZE+1];
+    char val[MAX_LINE_SIZE+1];
+
+    size_t  len;
+    int  lineno = 0;
+
+    section_list *sections;
+
+    if ((file = fopen(filepath, "r")) == NULL) {
+        config_error_callback("config: cannot open %s\n", filepath);
+        return NULL;
+    }
+
+    sections = sections_alloc(0);
+    if (!sections) {
+        fclose(file);
+        return NULL;
+    }
+
+    memset(line, 0, sizeof line);
+    memset(section, 0, sizeof section);
+    memset(key, 0, sizeof key);
+    memset(val, 0, sizeof val);
+
+    while (fgets(line, sizeof line, file)) {
+        lineno++;
+        len = strlen(line);
+        if (len == 0) continue;
+
+        if (line[len-1]!='\n' && !feof(file)) {
+            config_error_callback(
+              "config: input line too long in %s (%d)\n", filepath, lineno);
+            sections_free(sections);
+            fclose(file);
+            return NULL;
+        }
+       
+        if (line[len-1] == '\n') {
+            line[len-1] = 0;
+            len--;
+        }
+       
+        switch (config_line(line, section, key, val)) {
+            case LINE_EMPTY:
+            case LINE_COMMENT:
+            case LINE_SECTION:
+                break;
+            case LINE_VALUE:
+                sections_set(sections, section, key, val);
+                break;
+            case LINE_ERROR:
+                config_error_callback(
+                    "config: syntax error in %s (%d):\n-> %s\n",
+                    filepath,
+                    lineno,
+                    line);
+                break;
+            default:
+                break;
+        }
+    }
+    fclose(file);
+    return sections;
+}
+
+static ns_configor g_configor;
+
+/* const define */
+#define CONFIG_DEFAULT_FILE "/etc/ld-musl-namespace-arm.ini"        /* default config file pathname */
+#define SECTION_DIR_MAP "section.dir.map"   /* map of section and directory of app */
+#define ATTR_NS_PREFIX "namespace"         /* prefix of namespace attribute */
+#define ATTR_NS_ASAN "asan"                /* asan */
+#define ATTR_NS_LIB_PATHS "lib.paths"         /* library search paths */
+#define ATTR_NS_PERMITTED_PATHS "permitted.paths"         /* when separated, permitted dir paths of libs, including sub dirs */
+#define ATTR_NS_INHERITS "inherits"          /* inherited namespace */
+#define ATTR_NS_SEPARATED "separated"         /* if separated */
+#define ATTR_ADDED_NSLIST "added.nslist"      /* all namespace names except default */
+#define ATTR_NS_DEFAULT "default"           /* default namespace name */
+#define ATTR_NS_ACQUIESCENCE "acquiescence"           /* acquiescence section name */
+#define ATTR_NS_ALLOWED_LIBS "allowed.libs"      /* when separated, allowed library names */
+#define ATTR_NS_INHERIT_SHARED_LIBS "shared.libs"      /* when inherited, shared library names */
+#define SECTION_DIR_MAP_SYSTEM "system"      /* system path */
+#define SECTION_DIR_MAP_ASAN_SYSTEM "asan_system"      /* asan system path */
+
+/* get key-value list of section */
+static kvlist *config_get_kvs(const char *sname)
+{
+    size_t  i;
+    for (i=0; i<g_configor.sections->num; i++) {
+        if (!strcmp(g_configor.sections->names[i], sname)) {
+            return g_configor.sections->kvs[i];
+        }
+    }
+    return NULL;
+}
+
+/* get value by acquiescence */
+static char *config_get_value_by_acquiescence(kvlist *acquiescence_kvs, const char *key)
+{
+    if (!acquiescence_kvs) {
+        return NULL;
+    }
+    size_t i;
+    for (i=0; i<acquiescence_kvs->num; i++) {
+        if (!strcmp(acquiescence_kvs->key[i], key)) {
+            return acquiescence_kvs->val[i];
+        }
+    }
+    return NULL;
+}
+
+/* get value by acquiescence lib path */
+static char *config_get_acquiescence_lib_path(kvlist *acquiescence_kvs)
+{
+    if (!acquiescence_kvs) {
+        return NULL;
+    }
+    config_key_join(ATTR_NS_PREFIX, true);
+    config_key_join(".", false);
+    config_key_join(ATTR_NS_DEFAULT, false);
+    config_key_join(".", false);
+    char *key = config_key_join(ATTR_NS_LIB_PATHS, false);
+    return config_get_value_by_acquiescence(acquiescence_kvs, key);
+}
+
+/* get value by acquiescence asan lib path */
+static char *config_get_acquiescence_asan_lib_path(kvlist *acquiescence_kvs)
+{
+    if (!acquiescence_kvs) {
+        return NULL;
+    }
+    config_key_join(ATTR_NS_PREFIX, true);
+    config_key_join(".", false);
+    config_key_join(ATTR_NS_DEFAULT, false);
+    config_key_join(".", false);
+    config_key_join(ATTR_NS_ASAN, false);
+    config_key_join(".", false);
+    char *key = config_key_join(ATTR_NS_LIB_PATHS, false);
+    return config_get_value_by_acquiescence(acquiescence_kvs, key);
+}
+
+/* get value by key */
+static char *config_get_value(const char *key) 
+{
+    if (!g_configor.kvs) {
+        return NULL;
+    }
+    size_t i;
+    for (i=0; i<g_configor.kvs->num; i++) {
+        if (!strcmp(g_configor.kvs->key[i], key)) return g_configor.kvs->val[i];
+    }
+    return NULL;
+}
+
+/* get library search paths */
+static char *config_get_lib_paths(const char *ns_name)
+{
+    if (ns_name == NULL) {
+        return NULL;
+    }
+    config_key_join(ATTR_NS_PREFIX, true);
+    config_key_join(".", false);
+    config_key_join(ns_name, false);
+    config_key_join(".", false);
+    char *key = config_key_join(ATTR_NS_LIB_PATHS, false);
+    return config_get_value(key);
+}
+
+/* get asan library search paths */
+static char *config_get_asan_lib_paths(const char *ns_name)
+{
+    if (ns_name == NULL) {
+        return NULL;
+    }
+    config_key_join(ATTR_NS_PREFIX, true);
+    config_key_join(".", false);
+    config_key_join(ns_name, false);
+    config_key_join(".", false);
+    config_key_join(ATTR_NS_ASAN, false);
+    config_key_join(".", false);
+    char *key = config_key_join(ATTR_NS_LIB_PATHS, false);
+    return config_get_value(key);
+}
+
+/* parse config, success 0, failure <0 */
+static int config_parse(const char *file_path, const char *exe_path)
+{
+    kvlist* dirkvs;
+    kvlist* acquiescence_kvs;
+    if (!exe_path) return -1;
+    g_configor.exe_path = ld_strdup(exe_path);
+    const char * fpath = CONFIG_DEFAULT_FILE;
+    if (file_path) fpath = file_path;
+    g_configor.file_path = ld_strdup(fpath);
+    g_configor.sections = config_load(fpath);
+
+    if (!g_configor.sections) {
+        LD_LOGD("config_parse load ini config fail!");
+        return -2;
+    }
+    dirkvs = config_get_kvs(SECTION_DIR_MAP);
+    acquiescence_kvs = config_get_kvs(ATTR_NS_ACQUIESCENCE);
+    if (!dirkvs||!acquiescence_kvs) {
+        LD_LOGD("config_parse get dirkvs or acquiescence_kvs fail!");
+        return -3; /* no section directory map or acquiescence section found */
+    }
+    g_configor.config_sys_path = config_get_acquiescence_lib_path(acquiescence_kvs);
+    g_configor.config_asan_sys_path = config_get_acquiescence_asan_lib_path(acquiescence_kvs);
+    size_t i;
+    char * sname = NULL;
+    for (i=0; i<dirkvs->num; i++) {
+       strlist * paths = strsplit(dirkvs->val[i], ":");
+       if (paths) {
+           size_t j;
+           for (j=0; j<paths->num; j++) {
+               if (!strcmp(paths->strs[j], exe_path)) break;
+           }
+           if (j<paths->num) sname = dirkvs->key[i];
+        }
+        strlist_free(paths);
+        if (sname) break;
+    }
+    if (!sname) {
+        /* No matched section found, use the default section. */
+        sname = ATTR_NS_ACQUIESCENCE;
+        LD_LOGD("config_parse no section found!");
+    }
+    if (!(g_configor.kvs = config_get_kvs(sname))) {
+        LD_LOGD("config_parse no section key-value list found!");
+        return -5;/* no section key-value list found */
+    }
+
+    char *default_lib_paths = config_get_lib_paths(ATTR_NS_DEFAULT);
+    if (default_lib_paths) {
+        g_configor.config_sys_path = default_lib_paths;
+    } else {
+        LD_LOGW("config_parse get default lib paths fail! Config namespace default lib paths,please!");
+    }
+    char *default_asan_lib_paths = config_get_asan_lib_paths(ATTR_NS_DEFAULT);
+    if (default_asan_lib_paths) {
+        g_configor.config_asan_sys_path = default_asan_lib_paths;
+    } else {
+        LD_LOGW("config_parse get default asan lib paths fail! Config namespace default asan lib paths,please!");
+    }
+    return 0;
+}
+
+/* get namespace names except default */
+static strlist *config_get_namespaces()
+{
+    char *key = config_key_join(ATTR_ADDED_NSLIST, true);
+    char *val = config_get_value(key);
+    return strsplit(val, ",");
+}
+
+/* get permitted paths */
+static char *config_get_permitted_paths(const char *ns_name)
+{
+    if (ns_name == NULL) {
+        return NULL;
+    }
+    config_key_join(ATTR_NS_PREFIX, true);
+    config_key_join(".", false);
+    config_key_join(ns_name, false);
+    config_key_join(".", false);
+    char *key = config_key_join(ATTR_NS_PERMITTED_PATHS, false);
+    return config_get_value(key);
+}
+
+/* get asan permitted paths */
+static char *config_get_asan_permitted_paths(const char *ns_name)
+{
+    if (ns_name == NULL) {
+        return NULL;
+    }
+    config_key_join(ATTR_NS_PREFIX, true);
+    config_key_join(".", false);
+    config_key_join(ns_name, false);
+    config_key_join(".", false);
+    config_key_join(ATTR_NS_ASAN, false);
+    config_key_join(".", false);
+    char *key = config_key_join(ATTR_NS_PERMITTED_PATHS, false);
+    return config_get_value(key);
+}
+/* get inherited namespace names */
+static strlist *config_get_inherits(const char *ns_name)
+{
+    if (ns_name == NULL) {
+        return NULL;
+    }
+    config_key_join(ATTR_NS_PREFIX, true);
+    config_key_join(".", false);
+    config_key_join(ns_name, false);
+    config_key_join(".", false);
+    char *key = config_key_join(ATTR_NS_INHERITS, false);
+    char *val = config_get_value(key);
+    return strsplit(val, ",");
+}
+/* get separated */
+static bool config_get_separated(const char *ns_name)
+{
+    if (ns_name == NULL) {
+        return false;
+    }
+    config_key_join(ATTR_NS_PREFIX, true);
+    config_key_join(".", false);
+    config_key_join(ns_name, false);
+    config_key_join(".", false);
+    char *key = config_key_join(ATTR_NS_SEPARATED, false);
+    char *val = config_get_value(key);
+    strlwc(val);
+    if (val && !strcmp("true", val)) return true;
+    return false;  /* default false */
+}
+
+/* get allowed libs */
+static char *config_get_allowed_libs(const char *ns_name)
+{
+    if (ns_name == NULL) {
+        return NULL;
+    }
+    config_key_join(ATTR_NS_PREFIX, true);
+    config_key_join(".", false);
+    config_key_join(ns_name, false);
+    config_key_join(".", false);
+    char *key = config_key_join(ATTR_NS_ALLOWED_LIBS, false);
+    return config_get_value(key);
+}
+/* get shared libs by inherited namespace */
+static char *config_get_inherit_shared_libs(const char *ns_name, const char *inherited_ns_name)
+{
+    if (ns_name == NULL || inherited_ns_name == NULL) {
+        return NULL;
+    }
+    config_key_join(ATTR_NS_PREFIX, true);
+    config_key_join(".", false);
+    config_key_join(ns_name, false);
+    config_key_join(".inherit.", false);
+    config_key_join(inherited_ns_name, false);
+    config_key_join(".", false);
+    char *key = config_key_join(ATTR_NS_INHERIT_SHARED_LIBS, false);
+    return config_get_value(key);
+}
+
+/* The call time is after parse */
+static char *config_get_sys_paths(void)
+{
+    return g_configor.config_sys_path;
+}
+static char *config_get_asan_sys_paths(void)
+{
+    return g_configor.config_asan_sys_path;
+}
+ns_configor *configor_init()
+{
+    memset(&g_configor, 0, sizeof g_configor);
+    g_configor.set_error_callback = config_set_error_callback;
+    g_configor.parse = config_parse;
+    g_configor.get_namespaces = config_get_namespaces;
+    g_configor.get_lib_paths = config_get_lib_paths;
+    g_configor.get_asan_lib_paths = config_get_asan_lib_paths;
+    g_configor.get_permitted_paths = config_get_permitted_paths;
+    g_configor.get_asan_permitted_paths = config_get_asan_permitted_paths;
+    g_configor.get_separated = config_get_separated;
+    g_configor.get_inherits = config_get_inherits;
+    g_configor.get_allowed_libs = config_get_allowed_libs;
+    g_configor.get_inherit_shared_libs = config_get_inherit_shared_libs;
+    g_configor.get_sys_paths = config_get_sys_paths;
+    g_configor.get_asan_sys_paths = config_get_asan_sys_paths;
+    g_configor.config_sys_path = NULL; // init it in config_parse.
+    g_configor.config_asan_sys_path = NULL; // init it in config_parse.
+    return &g_configor;
+}
+
+void configor_free()
+{
+    if (g_configor.sections) {
+        sections_free(g_configor.sections);
+        g_configor.sections = NULL;
+    }
+    if (g_configor.file_path) {
+        __libc_free(g_configor.file_path);
+        g_configor.file_path = NULL;
+    }
+    if (g_configor.exe_path) {
+        __libc_free(g_configor.exe_path);
+        g_configor.exe_path = NULL;
+    }
+}
\ No newline at end of file
diff --git a/ldso/ns_config.h b/ldso/ns_config.h
new file mode 100644
index 00000000..a45f9c91
--- /dev/null
+++ b/ldso/ns_config.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _NS_CONFIG_H
+#define _NS_CONFIG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include "strops.h"
+/*
+ * The following #include is necessary on many Unixes but not Linux.
+ * It is not needed for Windows platforms.
+ * Uncomment it if needed.
+ */
+/* #include <unistd.h> */
+
+typedef struct _kv_list_ {
+    size_t num;     /** Number of entries in list */
+    size_t size;  /** Storage size */
+    char **key;   /** List of string keys */
+    char **val;   /** List of string values */
+} kvlist;
+
+typedef struct _section_list_ {
+  size_t num;
+  size_t size;
+  char **names;
+  kvlist **kvs;
+} section_list;
+
+typedef struct _ns_configor_ {
+  char *file_path;
+  char *exe_path;
+  char *config_sys_path;
+  char *config_asan_sys_path;
+  section_list *sections;
+  kvlist *kvs;
+
+  void (*set_error_callback)(int (*errback)(const char *, ...));
+  int (*parse)(const char *file_path, const char *exe_path);
+  strlist *(*get_namespaces)(void);
+  char *(*get_lib_paths)(const char *ns_name);
+  char *(*get_asan_lib_paths)(const char *ns_name);
+  char *(*get_permitted_paths)(const char *ns_name);
+  char *(*get_asan_permitted_paths)(const char *ns_name);
+  bool (*get_separated)(const char *ns_name);
+  strlist *(*get_inherits)(const char *ns_name);
+  char *(*get_allowed_libs)(const char *ns_name);
+  char *(*get_inherit_shared_libs)(const char *ns_name, const char *inherited_ns_name);
+  char *(*get_sys_paths)(void);
+  char *(*get_asan_sys_paths)(void);
+} ns_configor;
+
+ns_configor *configor_init();
+void configor_free();
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ldso/strops.c b/ldso/strops.c
new file mode 100644
index 00000000..0a0d384f
--- /dev/null
+++ b/ldso/strops.c
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <ctype.h>
+#include "strops.h"
+
+/* string to lower */
+void strlwc(char *str)
+{
+    if (str == NULL) return;
+    while (*str != '\0') {
+        *str = (char)tolower(*str);
+        str++ ;
+    }
+    return;
+}
+/* trim head and tail spaces of string */
+size_t strtrim(char *str)
+{
+    char *last = NULL;
+    char *dest = str;
+
+    if (str == NULL) return 0;
+
+    last = str + strlen(str);
+    while (isspace((int)*str) && *str) str++;
+    while (last > str) {
+        if (!isspace((int)*(last-1))) break;
+        last--;
+    }
+    *last = (char)0;
+
+    memmove(dest, str, last-str+1);
+    return last-str;
+}
+/* split string to list by given string */
+strlist *strsplit(const char *str, const char *split_s)
+{
+    char *cur, *next;
+    if(!str) return NULL;
+
+    strlist *sl = strlist_alloc(0);
+    char *ss = ld_strdup(str);
+    if (!sl || !ss) {
+        strlist_free(sl);
+        __libc_free(ss);
+        return NULL;
+    }
+
+    cur = ss;
+    while (next = strstr(cur, split_s)) {
+        *next = 0;
+        strtrim(cur);
+        strlist_set(sl, cur);
+        cur = next + strlen(split_s);
+    }
+    strtrim(cur);
+    strlist_set(sl, cur);
+    __libc_free(ss);
+    return sl;
+}
+
+#define STR_DEFAULT_SIZE   16
+
+strlist *strlist_alloc(size_t size)
+{
+    strlist *strs;
+    if (size < STR_DEFAULT_SIZE) size = STR_DEFAULT_SIZE ;
+
+    strs = (strlist *)__libc_calloc(1, sizeof *strs) ;
+
+    if (strs) {
+        strs->strs  = (char **)__libc_calloc(size, sizeof *strs->strs);
+        if (strs->strs) {
+            strs->size = size;
+        } else {
+            __libc_free(strs);
+            strs = NULL;
+        }
+    }
+    return strs ;
+}
+
+static void strlist_realloc(strlist *strs)
+{
+    if(!strs) return;
+    size_t size = 2*strs->size;
+    if (size) {
+        char **ss = (char **)__libc_realloc(strs->strs, size * (sizeof *strs->strs));
+        if (ss) {
+            strs->size = size;
+            strs->strs = ss;
+        }
+    }
+    return;
+}
+
+void strlist_free(strlist *strs)
+{
+    if (!strs) return;
+    for (size_t i=0; i < strs->num; i++) {
+        __libc_free(strs->strs[i]);
+    }
+    __libc_free(strs->strs);
+    __libc_free(strs);
+}
+
+void strlist_set(strlist *strs,const char *str)
+{
+    if (!strs || !str) return;
+    if (strs->num == strs->size) {
+       strlist_realloc(strs);
+    }
+    if (strs->num < strs->size) {
+        strs->strs[strs->num] = ld_strdup(str);
+        if (strs->strs[strs->num]) strs->num++;
+    }
+}
+
+char *ld_strdup(const char *s)
+{
+    size_t l = strlen(s);
+    char *d = __libc_malloc(l+1);
+    if (!d) return NULL;
+    return memcpy(d, s, l+1);
+}
\ No newline at end of file
diff --git a/ldso/strops.h b/ldso/strops.h
new file mode 100644
index 00000000..706f5126
--- /dev/null
+++ b/ldso/strops.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _STR_OPS_H
+#define _STR_OPS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <features.h>
+#include <stdlib.h>
+#include <string.h>
+
+typedef struct _str_list_ {
+  size_t num;     /** Number of entries in list */
+  size_t size;  /** Storage size */
+  char **strs;  /** string list */
+} strlist;
+
+hidden strlist *strlist_alloc(size_t size);
+hidden void strlist_free(strlist *strs);
+
+hidden void strlwc(char *str);
+hidden size_t strtrim(char *str);
+hidden strlist *strsplit(const char *str, const char *split_s);
+hidden void strlist_set(strlist *strs, const char *str);
+
+hidden char *ld_strdup(const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/ldso/zip_archive.h b/ldso/zip_archive.h
new file mode 100644
index 00000000..5ac3c3bd
--- /dev/null
+++ b/ldso/zip_archive.h
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _ZIP_ARCHIVE_H
+#define _ZIP_ARCHIVE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+
+#define PATH_BUF_SIZE 512
+/* used for read zip file */
+static const uint32_t LOCAL_FILE_HEADER_SIGNATURE = 0x04034b50;
+static const uint32_t CENTRAL_SIGNATURE = 0x02014b50;
+static const uint32_t EOCD_SIGNATURE = 0x06054b50;
+static const uint16_t COMPRESS_STORED = 0;
+static const char* ZIP_FILE_PATH_SEPARATOR = "!/";
+
+struct zip_info {
+    int fd;
+    bool found;
+    uint64_t file_offset;
+    uint16_t file_path_index;
+    char path_buf[PATH_BUF_SIZE];
+};
+
+/* Zip Format:
+ * -------------------------------------------------------
+ * | Local file header 1             |                   |
+ * -----------------------------------                   |
+ * | File data 1                     |                   |
+ * -----------------------------------                   |
+ * | Data descriptor 1               |                   |
+ * -----------------------------------    File Entry     |
+ * | ...                             |                   |
+ * -----------------------------------                   |
+ * | Local file header n             |                   |
+ * -----------------------------------                   |
+ * | File data n                     |                   |
+ * -----------------------------------                   |
+ * | Data descriptor n               |                   |
+ * -------------------------------------------------------
+ * | Central dir entry 1             |                   |
+ * -----------------------------------                   |
+ * | ...                             | Central Directory |
+ * -----------------------------------                   |
+ * | Central dir entry n             |                   |
+ * -------------------------------------------------------
+ * | End of central directory record |       EOCD        |
+ * ------------------------------------------------------- */
+
+// Local file header
+struct __attribute__((packed)) local_file_header {
+    uint32_t signature;
+    uint16_t version_needed;
+    uint16_t flags;
+    uint16_t compression_method;
+    uint16_t modified_time;
+    uint16_t modified_date;
+    uint32_t crc;
+    uint32_t compressed_size;
+    uint32_t uncompressed_size;
+    uint16_t name_size;
+    uint16_t extra_size;
+};
+
+// Central dir entry
+struct __attribute__((packed)) central_dir_entry {
+    uint32_t signature;
+    uint16_t version_made;
+    uint16_t version_needed;
+    uint16_t flags;
+    uint16_t compression_method;
+    uint16_t modified_time;
+    uint16_t modified_date;
+    uint32_t crc;
+    uint32_t compressed_size;
+    uint32_t uncompressed_size;
+    uint16_t name_size;
+    uint16_t extra_size;
+    uint16_t comment_size;
+    uint16_t disk_num_start;
+    uint16_t internal_attr;
+    uint32_t external_attr;
+    uint32_t local_header_offset;
+};
+
+// End of central directory record
+struct __attribute__((packed)) zip_end_locator {
+    uint32_t signature;
+    uint16_t num_disk;
+    uint16_t start_disk_of_central_dir;
+    uint16_t total_entries_in_disk;
+    uint16_t total_entries; /* Total number of central directory entrys. */
+    uint32_t size_of_central_dir;
+    uint32_t offset;  /* Offset of start of central directory entry. */
+    uint16_t comment_len;
+};
+
+int open_uncompressed_library_in_zipfile(const char *path, struct zip_info *z_info, char *separator);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/aio/aio.c b/src/aio/aio.c
index a1a3e791..6e632f35 100644
--- a/src/aio/aio.c
+++ b/src/aio/aio.c
@@ -197,7 +197,9 @@ static void cleanup(void *ctx)
 		__syscall(SYS_rt_sigqueueinfo, si.si_pid, si.si_signo, &si);
 	}
 	if (sev.sigev_notify == SIGEV_THREAD) {
+#ifdef FEATURE_PTHREAD_CANCEL
 		a_store(&__pthread_self()->cancel, 0);
+#endif
 		sev.sigev_notify_function(sev.sigev_value);
 	}
 }
@@ -267,7 +269,7 @@ static void *io_thread_func(void *ctx)
 	}
 	at.ret = ret;
 	at.err = ret<0 ? errno : 0;
-	
+
 	pthread_cleanup_pop(1);
 
 	return 0;
@@ -377,7 +379,11 @@ int aio_cancel(int fd, struct aiocb *cb)
 		if (cb && cb != p->cb) continue;
 		/* Transition target from running to running-with-waiters */
 		if (a_cas(&p->running, 1, -1)) {
+#ifdef FEATURE_PTHREAD_CANCEL
 			pthread_cancel(p->td);
+#else
+			__syscall(SYS_tkill, p->td->tid, SIGCANCEL);
+#endif
 			__wait(&p->running, 0, -1, 1);
 			if (p->err == ECANCELED) ret = AIO_CANCELED;
 		}
diff --git a/src/conf/legacy.c b/src/conf/legacy.c
index f1d9e325..ddc86342 100644
--- a/src/conf/legacy.c
+++ b/src/conf/legacy.c
@@ -1,14 +1,70 @@
 #include <sys/sysinfo.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
 #include <unistd.h>
+#include "syscall.h"
+
+#define _GNU_SOURCE
+#include <dirent.h>
+
+int get_cpu_default() {
+	int i, cnt;
+	unsigned char set[128] = {1};
+	__syscall(SYS_sched_getaffinity, 0, sizeof(set), set);
+	for ((i=cnt=0); (i < sizeof(set)); i++)
+		for (; set[i]; (set[i]&=set[i]-1), cnt++);
+	return cnt;
+}
 
 int get_nprocs_conf()
 {
-	return sysconf(_SC_NPROCESSORS_CONF);
+	struct dirent *de;
+	int cnt = 0;
+	DIR *d = opendir("/sys/devices/system/cpu");
+	if (!d)
+		return get_cpu_default();
+	while ((de = readdir(d))) {
+		if ((de->d_type == DT_DIR) &&
+			(strlen(de->d_name) > 3) &&
+			(de->d_name[0] == 'c') &&
+			(de->d_name[1] == 'p') &&
+			(de->d_name[2] == 'u') &&
+			(isdigit(de->d_name[3])))
+			cnt++;
+	}
+	closedir(d);
+	return cnt;
 }
 
 int get_nprocs()
 {
-	return sysconf(_SC_NPROCESSORS_ONLN);
+	int cnt;
+	FILE* fp = fopen("/sys/devices/system/cpu/online", "re");
+	if (fp != NULL) {
+		char buf[128];
+		memset(buf, 0, sizeof(buf));
+		if (!fgets(buf, sizeof(buf), fp)) {
+			return 1;
+		}
+		cnt = 0;
+		char *tmp, *p;
+		tmp = strtok_r(buf, ",", &p);
+		while (tmp != NULL) {
+			char *tok = strstr(tmp, "-");
+			if (tok) {
+				tok++;
+				cnt += atoi(tok) - atoi(tmp) + 1;
+			} else {
+				cnt += 1;
+			}
+			tmp = strtok_r(NULL, ",", &p);
+		}
+		fclose(fp);
+		return cnt;
+	}
+	return get_cpu_default();
 }
 
 long get_phys_pages()
diff --git a/src/conf/sysconf.c b/src/conf/sysconf.c
index 3baaed32..0578599e 100644
--- a/src/conf/sysconf.c
+++ b/src/conf/sysconf.c
@@ -194,13 +194,9 @@ long sysconf(int name)
 	case JT_DELAYTIMER_MAX & 255:
 		return DELAYTIMER_MAX;
 	case JT_NPROCESSORS_CONF & 255:
-	case JT_NPROCESSORS_ONLN & 255: ;
-		unsigned char set[128] = {1};
-		int i, cnt;
-		__syscall(SYS_sched_getaffinity, 0, sizeof set, set);
-		for (i=cnt=0; i<sizeof set; i++)
-			for (; set[i]; set[i]&=set[i]-1, cnt++);
-		return cnt;
+		return get_nprocs_conf();
+	case JT_NPROCESSORS_ONLN & 255:
+		return get_nprocs();
 	case JT_PHYS_PAGES & 255:
 	case JT_AVPHYS_PAGES & 255: ;
 		unsigned long long mem;
diff --git a/src/env/__init_tls.c b/src/env/__init_tls.c
index a93141ed..176e805b 100644
--- a/src/env/__init_tls.c
+++ b/src/env/__init_tls.c
@@ -19,7 +19,7 @@ int __init_tp(void *p)
 	if (r < 0) return -1;
 	if (!r) libc.can_do_threads = 1;
 	td->detach_state = DT_JOINABLE;
-	td->tid = __syscall(SYS_set_tid_address, &__thread_list_lock);
+	td->tid = td->pid = __syscall(SYS_set_tid_address, &__thread_list_lock);
 	td->locale = &libc.global_locale;
 	td->robust_list.head = &td->robust_list.head;
 	td->sysinfo = __sysinfo;
@@ -28,7 +28,7 @@ int __init_tp(void *p)
 }
 
 static struct builtin_tls {
-	char c;
+	char c[8];
 	struct pthread pt;
 	void *space[16];
 } builtin_tls[1];
@@ -52,7 +52,9 @@ void *__copy_tls(unsigned char *mem)
 
 	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
 		dtv[i] = (uintptr_t)(mem + p->offset) + DTP_OFFSET;
-		memcpy(mem + p->offset, p->image, p->len);
+		if (p->image) {
+			memcpy(mem + p->offset, p->image, p->len);
+		}
 	}
 #else
 	dtv = (uintptr_t *)mem;
@@ -63,7 +65,9 @@ void *__copy_tls(unsigned char *mem)
 
 	for (i=1, p=libc.tls_head; p; i++, p=p->next) {
 		dtv[i] = (uintptr_t)(mem - p->offset) + DTP_OFFSET;
-		memcpy(mem - p->offset, p->image, p->len);
+		if (p->image) {
+			memcpy(mem - p->offset, p->image, p->len);
+		}
 	}
 #endif
 	dtv[0] = libc.tls_cnt;
diff --git a/src/env/__libc_start_main.c b/src/env/__libc_start_main.c
index c5b277bd..83bebc67 100644
--- a/src/env/__libc_start_main.c
+++ b/src/env/__libc_start_main.c
@@ -6,6 +6,7 @@
 #include "syscall.h"
 #include "atomic.h"
 #include "libc.h"
+#include "pthread_impl.h"
 
 static void dummy(void) {}
 weak_alias(dummy, _init);
@@ -90,6 +91,10 @@ static int libc_start_main_stage2(int (*main)(int,char **,char **), int argc, ch
 {
 	char **envp = argv+argc+1;
 	__libc_start_init();
+#ifdef RESERVE_SIGNAL_STACK
+	pthread_reserve_signal_stack();
+#endif
+	errno = 0;
 
 	/* Pass control to the application */
 	exit(main(argc, argv, envp));
diff --git a/src/env/getenv.c b/src/env/getenv.c
index a90d39cf..d5fa6710 100644
--- a/src/env/getenv.c
+++ b/src/env/getenv.c
@@ -4,10 +4,21 @@
 
 char *getenv(const char *name)
 {
-	size_t l = __strchrnul(name, '=') - name;
-	if (l && !name[l] && __environ)
-		for (char **e = __environ; *e; e++)
-			if (!strncmp(name, *e, l) && l[*e] == '=')
-				return *e + l+1;
+	if (name == NULL || __environ == NULL)
+		return 0;
+	size_t i, l = 0;
+	const char *np;
+	char **p, *ep;
+	for (; *(name + l) && *(name + l) != '='; ++l);
+	for (p = __environ; (ep = *p) != NULL; ++p) {
+		for (np = name, i = l; i && *ep; i--) {
+			if (*ep++ != *np++) {
+				break;
+			}
+		}
+		if (i == 0 && *ep++ == '=') {
+			return (ep);
+		}
+	}
 	return 0;
 }
diff --git a/src/exit/atexit.c b/src/exit/atexit.c
index 854e9fdd..c35c0817 100644
--- a/src/exit/atexit.c
+++ b/src/exit/atexit.c
@@ -3,6 +3,8 @@
 #include "libc.h"
 #include "lock.h"
 #include "fork_impl.h"
+#include "dynlink.h"
+#include "musl_log.h"
 
 #define malloc __libc_malloc
 #define calloc __libc_calloc
@@ -17,6 +19,8 @@ static struct fl
 	struct fl *next;
 	void (*f[COUNT])(void *);
 	void *a[COUNT];
+	void *dso[COUNT];
+	struct dso *internal_dso[COUNT]; // the internal dso weekptr, used for dlclose
 } builtin, *head;
 
 static int slot;
@@ -28,25 +32,61 @@ void __funcs_on_exit()
 	void (*func)(void *), *arg;
 	LOCK(lock);
 	for (; head; head=head->next, slot=COUNT) while(slot-->0) {
-		func = head->f[slot];
-		arg = head->a[slot];
-		UNLOCK(lock);
-		func(arg);
-		LOCK(lock);
+		if (head->f[slot] != NULL) {
+			func = head->f[slot];
+			arg = head->a[slot];
+			UNLOCK(lock);
+			func(arg);
+			LOCK(lock);
+		}
 	}
+	UNLOCK(lock);
 }
 
 void __cxa_finalize(void *dso)
 {
+	void (*func)(void *), *arg;
+	struct fl *head_tmp = head;
+	int slot_tmp = slot;
+
+	LOCK(lock);
+	for (; head_tmp; head_tmp=head_tmp->next, slot_tmp=COUNT) while(slot_tmp-->0) {
+		if (dso == head_tmp->dso[slot_tmp]) {
+			func = head_tmp->f[slot_tmp];
+			arg = head_tmp->a[slot_tmp];
+			UNLOCK(lock);
+			func(arg);
+			LOCK(lock);
+
+			head_tmp->dso[slot_tmp] = NULL;
+			head_tmp->f[slot_tmp] = NULL;
+		}
+	}
+	UNLOCK(lock);
 }
 
+static void call(void *p);
+
 int __cxa_atexit(void (*func)(void *), void *arg, void *dso)
 {
+	struct dso *p = NULL;
 	LOCK(lock);
 
 	/* Defer initialization of head so it can be in BSS */
 	if (!head) head = &builtin;
 
+	// if called from atexit, check callback ptr mem range.
+#if (defined(FEATURE_ATEXIT_CB_PROTECT))
+	if ((func == (void *)call) && (dso == NULL)) {
+		p = addr2dso((size_t)arg);
+		if (p == NULL) {
+			UNLOCK(lock);
+			MUSL_LOGE("call atexit with invalid callback ptr=%{public}p", arg);
+			return -1;
+		}
+	}
+#endif
+
 	/* If the current function list is full, add a new one */
 	if (slot==COUNT) {
 		struct fl *new_fl = calloc(sizeof(struct fl), 1);
@@ -62,6 +102,9 @@ int __cxa_atexit(void (*func)(void *), void *arg, void *dso)
 	/* Append function to the list. */
 	head->f[slot] = func;
 	head->a[slot] = arg;
+	head->dso[slot] = dso;
+	head->internal_dso[slot] = p;
+
 	slot++;
 
 	UNLOCK(lock);
@@ -70,10 +113,33 @@ int __cxa_atexit(void (*func)(void *), void *arg, void *dso)
 
 static void call(void *p)
 {
-	((void (*)(void))(uintptr_t)p)();
+	if (p != NULL)
+		((void (*)(void))(uintptr_t)p)();
 }
 
 int atexit(void (*func)(void))
 {
 	return __cxa_atexit(call, (void *)(uintptr_t)func, 0);
 }
+
+int invalidate_exit_funcs(struct dso *p)
+{
+	struct fl *head_tmp = head;
+	int slot_tmp = slot;
+
+	LOCK(lock);
+	for (; head_tmp; head_tmp=head_tmp->next, slot_tmp=COUNT) {
+		while(slot_tmp-->0) {
+			// if found exit callback relative to this dso, and
+			if (p == head_tmp->internal_dso[slot_tmp]) {
+				if ((head_tmp->dso[slot_tmp] == NULL) && head_tmp->f[slot_tmp] == (void *)call) {
+					MUSL_LOGD("invalidate callback ptr=%{public}p when uninstall %{public}%s", head_tmp->a[slot_tmp], p->name);
+					head_tmp->a[slot_tmp] = NULL;
+				}
+			}
+		}
+	}
+	UNLOCK(lock);
+
+	return 0;
+}
\ No newline at end of file
diff --git a/src/fortify/fortify.c b/src/fortify/fortify.c
new file mode 100644
index 00000000..d30c6c8a
--- /dev/null
+++ b/src/fortify/fortify.c
@@ -0,0 +1,410 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#define _GNU_SOURCE
+#define _BSD_SOURCE
+
+#include <fortify/fortify.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <poll.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#define FILE_MODE_ALL (0777)
+
+void __fortify_error(const char* info, ...)
+{
+    va_list ap;
+    va_start(ap, info);
+    fprintf(stderr, FORTIFY_RUNTIME_ERROR_PREFIX);
+    vfprintf(stderr, info, ap);
+    va_end(ap);
+    abort();
+}
+
+static inline int __force_O_LARGEFILE(int flags)
+{
+#if defined(__LP64__)
+    return flags; // No need, and aarch64's strace gets confused.
+#else
+    return flags | O_LARGEFILE;
+#endif
+}
+
+static inline bool __needs_mode(int flags)
+{
+    return ((flags & O_CREAT) == O_CREAT) || ((flags & O_TMPFILE) == O_TMPFILE);
+}
+
+int __open_chk(const char* pathname, int flags)
+{
+    if (__needs_mode(flags)) {
+        __fortify_error("open: " OPEN_TOO_FEW_ARGS_ERROR);
+    }
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(open)(pathname, __force_O_LARGEFILE(flags), 0);
+}
+
+int __openat_chk(int fd, const char* pathname, int flags)
+{
+    if (__needs_mode(flags)) {
+        __fortify_error("openat: " OPEN_TOO_FEW_ARGS_ERROR);
+    }
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(openat)(fd, pathname, __force_O_LARGEFILE(flags), 0);
+}
+
+#if defined(_LARGEFILE64_SOURCE) || defined(_GNU_SOURCE)
+int __open64_chk(const char* pathname, int flags)
+{
+    if (__needs_mode(flags)) {
+        __fortify_error("open64: " OPEN_TOO_FEW_ARGS_ERROR);
+    }
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(open64)(pathname, __force_O_LARGEFILE(flags), 0);
+}
+
+int __openat64_chk(int fd, const char* pathname, int flags)
+{
+    if (__needs_mode(flags)) {
+        __fortify_error("openat64: " OPEN_TOO_FEW_ARGS_ERROR);
+    }
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(openat64)(fd, pathname, __force_O_LARGEFILE(flags), 0);
+}
+#endif
+
+static inline void __diagnose_pollfd_array(const char* fn, size_t fds_size, nfds_t fd_count)
+{
+    size_t pollfd_array_length = fds_size / sizeof(struct pollfd);
+    if (__DIAGNOSE_PREDICT_FALSE(pollfd_array_length < fd_count)) {
+        __fortify_error("%s: %zu-element pollfd array too small for %u fds\n",
+        fn, pollfd_array_length, fd_count);
+    }
+}
+
+int __poll_chk(struct pollfd* fds, nfds_t fd_count, int timeout, size_t fds_size)
+{
+    __diagnose_pollfd_array("poll", fds_size, fd_count);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(poll)(fds, fd_count, timeout);
+}
+
+#ifdef _GNU_SOURCE
+int __ppoll_chk(struct pollfd* fds, nfds_t fd_count, const struct timespec* timeout,
+    const sigset_t* mask, size_t fds_size)
+{
+    __diagnose_pollfd_array("ppoll", fds_size, fd_count);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(ppoll)(fds, fd_count, timeout, mask);
+}
+#endif
+
+static inline void __diagnose_buffer_access(const char* fn, const char* action,
+    size_t claim, size_t actual)
+{
+    if (__DIAGNOSE_PREDICT_FALSE(claim > actual)) {
+        __fortify_error("%s: avoid %zu-byte %s %zu-byte buffer\n", fn, claim, action, actual);
+    }
+}
+
+ssize_t __recvfrom_chk(int socket, void* buf, size_t len, size_t buf_size,
+    int flags, struct sockaddr* src_addr, socklen_t* addrlen)
+{
+    __diagnose_buffer_access("recvfrom", "write into", len, buf_size);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(recvfrom)(socket, buf, len, flags, src_addr, addrlen);
+}
+
+ssize_t __sendto_chk(int socket, const void* buf, size_t len, size_t buflen,
+    int flags, const struct sockaddr* dest_addr, socklen_t addrlen)
+{
+    __diagnose_buffer_access("sendto", "read from", len, buflen);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(sendto)(socket, buf, len, flags, dest_addr, addrlen);
+}
+
+ssize_t __recv_chk(int socket, void* buf, size_t len, size_t buf_size, int flags)
+{
+    __diagnose_buffer_access("recv", "write into", len, buf_size);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(recv)(socket, buf, len, flags);
+}
+
+ssize_t __send_chk(int socket, const void* buf, size_t len, size_t buflen, int flags)
+{
+    __diagnose_buffer_access("send", "read from", len, buflen);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(send)(socket, buf, len, flags);
+}
+
+mode_t __umask_chk(mode_t mode)
+{
+    if (__DIAGNOSE_PREDICT_FALSE((mode & FILE_MODE_ALL) != mode)) {
+        __fortify_error("umask: called with invalid mask %o\n", mode);
+    }
+    return __umask_real(mode);
+}
+
+// Runtime implementation of the string-dependent interface.
+// Used directly by the compiler, not in a header file.
+static inline void __diagnose_count(const char *fn, const char *identifier, size_t value)
+{
+    if (__DIAGNOSE_PREDICT_FALSE(value > LONG_MAX)) {
+        __fortify_error("%s: %s %zu > SSIZE_MAX\n", fn, identifier, value);
+    }
+}
+
+size_t __strlen_chk(const char* s, size_t s_len)
+{
+    size_t ret = __DIAGNOSE_CALL_BYPASSING_FORTIFY(strlen)(s);
+    if (__DIAGNOSE_PREDICT_FALSE(ret >= s_len)) {
+        __fortify_error("strlen: diagnose read exceed end of buffer\n");
+    }
+    return ret;
+}
+
+char* __strncat_chk(char* dest, const char* src, size_t len, size_t dst_buf_size)
+{
+    size_t src_len = strlen(src) + strlen(dest);
+    __diagnose_buffer_access("strncat", "write into", src_len, dst_buf_size);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(strncat)(dest, src, len);
+}
+
+char* __strcat_chk(char* dest, const char* src, size_t dst_buf_size)
+{
+    size_t src_len = strlen(src) + strlen(dest);
+    __diagnose_buffer_access("strcat", "write into", src_len, dst_buf_size);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(strcat)(dest, src);
+}
+
+char* __strcpy_chk(char* dest, const char* src, size_t dst_len)
+{
+    size_t src_len = strlen(src) + 1;
+    __diagnose_buffer_access("strcpy", "write into", src_len, dst_len);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(strcpy)(dest, src);
+}
+
+void* __memmove_chk(void* dest, const void* src, size_t len, size_t dst_len)
+{
+    __diagnose_buffer_access("memmove", "write into", len, dst_len);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(memmove)(dest, src, len);
+}
+
+void* __memcpy_chk(void* dest, const void* src, size_t count, size_t dst_len)
+{
+    __diagnose_count("memcpy", "count", count);
+    __diagnose_buffer_access("memcpy", "write into", count, dst_len);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(memcpy)(dest, src, count);
+}
+
+#ifdef _GNU_SOURCE
+void* __mempcpy_chk(void* dest, const void* src, size_t count, size_t dst_len)
+{
+    __diagnose_count("mempcpy", "count", count);
+    __diagnose_buffer_access("mempcpy", "write into", count, dst_len);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(mempcpy)(dest, src, count);
+}
+#endif
+
+char* __stpcpy_chk(char* dest, const char* src, size_t dst_len)
+{
+    size_t src_len = strlen(src);
+    __diagnose_buffer_access("stpcpy", "write into", src_len, dst_len);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(stpcpy)(dest, src);
+}
+
+void* __memchr_chk(const void* s, int c, size_t n, size_t actual_size)
+{
+    __diagnose_buffer_access("memchr", "read from", n, actual_size);
+    void* const_cast_s = s;
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(memchr)(const_cast_s, c, n);
+}
+
+char* __stpncpy_chk(char* dest, const char* src, size_t len, size_t dst_len)
+{
+    __diagnose_buffer_access("stpncpy", "write into", len, dst_len);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(stpncpy)(dest, src, len);
+}
+
+char *__strncpy_chk(char *dest, const char *src, size_t len, size_t dst_len)
+{
+    __diagnose_buffer_access("strncpy", "write into", len, dst_len);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(strncpy)(dest, src, len);
+}
+
+void *__memset_chk(void *dest, int byte, size_t count, size_t dst_len)
+{
+    __diagnose_count("memset", "count", count);
+    __diagnose_buffer_access("memset", "write into", count, dst_len);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(memset)(dest, byte, count);
+}
+
+#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)
+size_t __strlcpy_chk(char *dest, const char *src,
+    size_t supplied_size, size_t dst_len_from_compiler)
+{
+    __diagnose_buffer_access("strlcpy", "write into", supplied_size, dst_len_from_compiler);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(strlcpy)(dest, src, supplied_size);
+}
+
+size_t __strlcat_chk(char *dest, const char *src,
+    size_t supplied_size, size_t dst_len_from_compiler)
+{
+    __diagnose_buffer_access("strlcat", "write into", supplied_size, dst_len_from_compiler);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(strlcat)(dest, src, supplied_size);
+}
+#endif
+
+char* __strchr_chk(const char *s, int c, size_t s_len)
+{
+    if (s_len == 0) {
+        __fortify_error("strchr: avoid read exceed end of buffer\n");
+    }
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(strchr)(s, c);
+}
+
+char *__strrchr_chk(const char *s, int c, size_t s_len)
+{
+    if (s_len == 0) {
+        __fortify_error("strrchr: avoid read exceed end of buffer\n");
+    }
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(strrchr)(s, c);
+}
+
+#ifdef _GNU_SOURCE
+void* __memrchr_chk(const void *s, int c, size_t n, size_t actual_size)
+{
+    __diagnose_buffer_access("memrchr", "read from", n, actual_size);
+    void *const_cast_s = s;
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(memrchr)(const_cast_s, c, n);
+}
+#endif
+
+char* __getcwd_chk(char* buf, size_t len, size_t actual_size)
+{
+    __diagnose_buffer_access("getcwd", "write into", len, actual_size);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(getcwd)(buf, len);
+}
+
+ssize_t __pread_chk(int fd, void* buf, size_t count, off_t offset, size_t buf_size)
+{
+    __diagnose_count("pread", "count", count);
+    __diagnose_buffer_access("pread", "write into", count, buf_size);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(pread)(fd, buf, count, offset);
+}
+
+ssize_t __pwrite_chk(int fd, const void* buf, size_t count, off_t offset, size_t buf_size)
+{
+    __diagnose_count("pwrite", "count", count);
+    __diagnose_buffer_access("pwrite", "read from", count, buf_size);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(pwrite)(fd, buf, count, offset);
+}
+
+ssize_t __read_chk(int fd, void* buf, size_t count, size_t buf_size)
+{
+    __diagnose_count("read", "count", count);
+    __diagnose_buffer_access("read", "write into", count, buf_size);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(read)(fd, buf, count);
+}
+
+ssize_t __write_chk(int fd, const void* buf, size_t count, size_t buf_size)
+{
+    __diagnose_count("write", "count", count);
+    __diagnose_buffer_access("write", "read from", count, buf_size);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(write)(fd, buf, count);
+}
+
+ssize_t __readlink_chk(const char* path, char* buf, size_t size, size_t buf_size)
+{
+    __diagnose_count("readlink", "size", size);
+    __diagnose_buffer_access("readlink", "write into", size, buf_size);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(readlink)(path, buf, size);
+}
+
+ssize_t __readlinkat_chk(int dirfd, const char* path, char* buf, size_t size, size_t buf_size)
+{
+    __diagnose_count("readlinkat", "size", size);
+    __diagnose_buffer_access("readlinkat", "write into", size, buf_size);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(readlinkat)(dirfd, path, buf, size);
+}
+
+size_t __fread_chk(void* buf, size_t size, size_t count, FILE* stream, size_t buf_size)
+{
+    size_t total;
+    if (__DIAGNOSE_PREDICT_FALSE(__DIAGNOSE__SIZE_MUL_OVERFLOW(size, count, &total))) {
+        // overflow: trigger the error path in fread
+        return fread(buf, size, count, stream);
+    }
+    __diagnose_buffer_access("fread", "write into", total, buf_size);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(fread)(buf, size, count, stream);
+}
+
+size_t __fwrite_chk(const void* buf, size_t size, size_t count, FILE* stream, size_t buf_size)
+{
+    size_t total;
+    if (__DIAGNOSE_PREDICT_FALSE(__DIAGNOSE__SIZE_MUL_OVERFLOW(size, count, &total))) {
+        // overflow: trigger the error path in fwrite
+        return fwrite(buf, size, count, stream);
+    }
+    __diagnose_buffer_access("fwrite", "read from", total, buf_size);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(fwrite)(buf, size, count, stream);
+}
+
+char* __fgets_chk(char* dest, int supplied_size, FILE* stream, size_t dst_len_from_compiler)
+{
+    __diagnose_buffer_access("fgets", "write into", supplied_size, dst_len_from_compiler);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(fgets)(dest, supplied_size, stream);
+}
+
+int __vsnprintf_chk(char* dest, size_t supplied_size, int flags,
+    size_t dst_len_from_compiler, const char* format, va_list va)
+{
+    __diagnose_buffer_access("vsnprintf", "write into", supplied_size, dst_len_from_compiler);
+    return __DIAGNOSE_CALL_BYPASSING_FORTIFY(vsnprintf)(dest, supplied_size, format, va);
+}
+
+int __vsprintf_chk(char* dest, int flags,
+    size_t dst_len_from_compiler, const char* format, va_list va)
+{
+    // The compiler has SIZE_MAX, But vsnprintf cannot use such a large size.
+    int result = __DIAGNOSE_CALL_BYPASSING_FORTIFY(vsnprintf)(dest,
+        dst_len_from_compiler == SIZE_MAX ? SSIZE_MAX : dst_len_from_compiler,
+        format, va);
+
+    // Attempts to find out after the fact fail.
+    __diagnose_buffer_access("vsprintf", "write into", result + 1, dst_len_from_compiler);
+    return result;
+}
+#undef SSIZE_MAX
+#undef SIZE_MAX
+
+int __snprintf_chk(char* dest, size_t supplied_size, int flags,
+    size_t dst_len_from_compiler, const char* format, ...)
+{
+    va_list va;
+    va_start(va, format);
+    int result = __vsnprintf_chk(dest, supplied_size, flags, dst_len_from_compiler, format, va);
+    va_end(va);
+    return result;
+}
+
+int __sprintf_chk(char* dest, int flags, size_t dst_len_from_compiler, const char* format, ...)
+{
+    va_list va;
+    va_start(va, format);
+    int result = __vsprintf_chk(dest, flags, dst_len_from_compiler, format, va);
+    va_end(va);
+    return result;
+}
diff --git a/src/hilog/hilog_adapter.c b/src/hilog/hilog_adapter.c
new file mode 100644
index 00000000..8b63f03b
--- /dev/null
+++ b/src/hilog/hilog_adapter.c
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define _GNU_SOURCE
+
+#include <hilog_adapter.h>
+
+#include <errno.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <sys/uio.h>
+#include <sys/un.h>
+#include <time.h>
+#include <unistd.h>
+
+#include "hilog_common.h"
+#ifdef OHOS_ENABLE_PARAMETER
+#include "sys_param.h"
+#endif
+#include "vsnprintf_s_p.h"
+
+#define LOG_LEN 3
+#define ERROR_FD 2
+#ifdef OHOS_ENABLE_PARAMETER
+#define SYSPARAM_LENGTH 32
+#endif
+
+const int SOCKET_TYPE = SOCK_DGRAM | SOCK_NONBLOCK | SOCK_CLOEXEC;
+const int INVALID_SOCKET = -1;
+const struct sockaddr_un SOCKET_ADDR = {AF_UNIX, SOCKET_FILE_DIR INPUT_SOCKET_NAME};
+
+static bool musl_log_enable = false;
+
+#ifdef OHOS_ENABLE_PARAMETER
+static const char *param_name = "musl.log.enable";
+#endif
+
+static int SendMessage(HilogMsg *header, const char *tag, uint16_t tagLen, const char *fmt, uint16_t fmtLen)
+{
+    int socketFd = TEMP_FAILURE_RETRY(socket(AF_UNIX, SOCKET_TYPE, 0));
+    if (socketFd < 0) {
+        dprintf(ERROR_FD, "HiLogAdapter: Can't create socket! Errno: %d\n", errno);
+        return socketFd;
+    }
+
+    long int result =
+        TEMP_FAILURE_RETRY(connect(socketFd, (const struct sockaddr *)(&SOCKET_ADDR), sizeof(SOCKET_ADDR)));
+    if (result < 0) {
+        dprintf(ERROR_FD, "HiLogAdapter: Can't connect to server. Errno: %d\n", errno);
+        if (socketFd >= 0) {
+            close(socketFd);
+        }
+        return result;
+    }
+    struct timespec ts = {0};
+    (void)clock_gettime(CLOCK_REALTIME, &ts);
+    struct timespec ts_mono = {0};
+    (void)clock_gettime(CLOCK_MONOTONIC, &ts_mono);
+    header->tv_sec = (uint32_t)(ts.tv_sec);
+    header->tv_nsec = (uint32_t)(ts.tv_nsec);
+    header->mono_sec = (uint32_t)(ts_mono.tv_sec);
+    header->len = sizeof(HilogMsg) + tagLen + fmtLen;
+    header->tag_len = tagLen;
+
+    struct iovec vec[LOG_LEN] = {0};
+    vec[0].iov_base = header;                   // 0 : index of hos log header
+    vec[0].iov_len = sizeof(HilogMsg);          // 0 : index of hos log header
+    vec[1].iov_base = (void *)((char *)(tag));  // 1 : index of log tag
+    vec[1].iov_len = tagLen;                    // 1 : index of log tag
+    vec[2].iov_base = (void *)((char *)(fmt));  // 2 : index of log content
+    vec[2].iov_len = fmtLen;                    // 2 : index of log content
+    int ret = TEMP_FAILURE_RETRY(writev(socketFd, vec, LOG_LEN));
+    if (socketFd >= 0) {
+        close(socketFd);
+    }
+    return ret;
+}
+
+HILOG_LOCAL_API
+int HiLogAdapterPrintArgs(
+    const LogType type, const LogLevel level, const unsigned int domain, const char *tag, const char *fmt, va_list ap)
+{
+    char buf[MAX_LOG_LEN] = {0};
+
+    vsnprintfp_s(buf, MAX_LOG_LEN, MAX_LOG_LEN - 1, true, fmt, ap);
+
+    size_t tagLen = strnlen(tag, MAX_TAG_LEN - 1);
+    size_t logLen = strnlen(buf, MAX_LOG_LEN - 1);
+    HilogMsg header = {0};
+    header.type = type;
+    header.level = level;
+#ifndef __RECV_MSG_WITH_UCRED_
+    header.pid = getpid();
+#endif
+    header.tid = (uint32_t)(gettid());
+    header.domain = domain;
+
+    return SendMessage(&header, tag, tagLen + 1, buf, logLen + 1);
+}
+
+HILOG_LOCAL_API
+int HiLogAdapterPrint(LogType type, LogLevel level, unsigned int domain, const char *tag, const char *fmt, ...)
+{
+    if (!HiLogAdapterIsLoggable(domain, tag, level)) {
+        return -1;
+    }
+
+    int ret;
+    va_list ap;
+    va_start(ap, fmt);
+    ret = HiLogAdapterPrintArgs(type, level, domain, tag, fmt, ap);
+    va_end(ap);
+    return ret;
+}
+
+bool is_musl_log_enable()
+{
+    if (getpid() == 1) {
+        return false;
+    }
+    return musl_log_enable;
+}
+
+bool HiLogAdapterIsLoggable(unsigned int domain, const char *tag, LogLevel level)
+{
+    if (!is_musl_log_enable()) {
+        return false;
+    }
+
+    if ((level <= LOG_LEVEL_MIN) || (level >= LOG_LEVEL_MAX) || tag == NULL) {
+        return false;
+    }
+    return true;
+}
+
+#ifdef OHOS_ENABLE_PARAMETER
+bool get_bool_sysparam(CachedHandle cachedhandle)
+{
+    char *param_value = CachedParameterGet(cachedhandle);
+    if (param_value != NULL) {
+        if (strcmp(param_value, "true") == 0) {
+            return true;
+        }
+    }
+    return false;
+}
+#endif
+
+void musl_log_reset()
+{
+#if (defined(OHOS_ENABLE_PARAMETER))
+    static CachedHandle musl_log_Handle = NULL;
+    if (musl_log_Handle == NULL) {
+        musl_log_Handle = CachedParameterCreate(param_name, "false");
+    }
+    musl_log_enable = get_bool_sysparam(musl_log_Handle);
+#elif (defined(ENABLE_MUSL_LOG))
+    musl_log_enable = true;
+#endif
+}
diff --git a/src/hilog/hilog_common.h b/src/hilog/hilog_common.h
new file mode 100644
index 00000000..14e4c679
--- /dev/null
+++ b/src/hilog/hilog_common.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef HILOG_COMMON_H
+#define HILOG_COMMON_H
+
+#include <stdint.h>
+#include <stddef.h>
+
+#define SOCKET_FILE_DIR "/dev/unix/socket/"
+#define INPUT_SOCKET_NAME "hilogInput"
+
+#define MAX_LOG_LEN 1024 /* maximum length of a log, include '\0' */
+#define MAX_TAG_LEN 32   /* log tag size, include '\0' */
+
+/*
+ * header of log message from libhilog to hilogd
+ */
+typedef struct __attribute__((__packed__)) {
+    uint16_t len;
+    uint16_t version : 3;
+    uint16_t type : 4; /* APP,CORE,INIT,SEC etc */
+    uint16_t level : 3;
+    uint16_t tag_len : 6; /* include '\0' */
+    uint32_t tv_sec;
+    uint32_t tv_nsec;
+    uint32_t mono_sec;
+    uint32_t pid;
+    uint32_t tid;
+    uint32_t domain;
+    char tag[]; /* shall be end with '\0' */
+} HilogMsg;
+
+#if defined(__GNUC__) && (__GNUC__ >= 4)
+#define HILOG_PUBLIC_API __attribute__((visibility("default")))
+#define HILOG_LOCAL_API __attribute__((visibility("hidden")))
+#else
+#define HILOG_PUBLIC_API
+#define HILOG_LOCAL_API
+#endif
+
+#endif /* HILOG_COMMON_H */
diff --git a/src/hilog/output_p.inl b/src/hilog/output_p.inl
new file mode 100644
index 00000000..70ca112f
--- /dev/null
+++ b/src/hilog/output_p.inl
@@ -0,0 +1,1300 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/* [Standardize-exceptions] Use unsafe function: Portability
+ * [reason] Use unsafe function to implement security function to maintain platform compatibility.
+ *          And sufficient input validation is performed before calling
+ */
+
+#ifndef OUTPUT_P_INL_2B263E9C_43D8_44BB_B17A_6D2033DECEE5
+#define OUTPUT_P_INL_2B263E9C_43D8_44BB_B17A_6D2033DECEE5
+
+#define SECUREC_FLOAT_BUFSIZE (309+40)  /* max float point value */
+#define SECUREC_FLOAT_BUFSIZE_LB (4932+40)  /* max long double value */
+
+#define SECUREC_INT_MAX       2147483647
+
+#define SECUREC_MUL10(x) ((((x) << 2) + (x)) << 1)
+#define SECUREC_INT_MAX_DIV_TEN       21474836
+#define SECUREC_MUL10_ADD_BEYOND_MAX(val) (((val) > SECUREC_INT_MAX_DIV_TEN))
+
+#ifdef SECUREC_STACK_SIZE_LESS_THAN_1K
+#define SECUREC_FMT_STR_LEN (8)
+#else
+#define SECUREC_FMT_STR_LEN (16)
+#endif
+
+typedef struct {
+    unsigned int flags;
+    int fldWidth;
+    int precision;
+    int bufferIsWide;           /* flag for buffer contains wide chars */
+    int dynWidth;               /* %*   1 width from variable parameter ;0 not */
+    int dynPrecision;           /* %.*  1 precision from variable parameter ;0 not */
+} SecFormatAttr;
+
+typedef union {
+    char *str;                  /* not a null terminated  string */
+    wchar_t *wStr;
+} SecFormatBuf;
+
+typedef union {
+    char str[SECUREC_BUFFER_SIZE + 1];
+#ifdef SECUREC_FOR_WCHAR
+    wchar_t wStr[SECUREC_BUFFER_SIZE + 1];
+#endif
+} SecBuffer;
+
+static int SecIndirectSprintf(char *strDest, const char *format, ...)
+{
+    int ret;                    /* If initialization causes  e838 */
+    va_list arglist;
+
+    va_start(arglist, format);
+    SECUREC_MASK_MSVC_CRT_WARNING
+    ret = vsprintf(strDest, format, arglist);
+    SECUREC_END_MASK_MSVC_CRT_WARNING
+    va_end(arglist);
+    (void)arglist;              /* to clear e438 last value assigned not used , the compiler will optimize this code */
+
+    return ret;
+}
+
+#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
+/* to clear e506 warning */
+static int SecIsSameSize(size_t sizeA, size_t sizeB)
+{
+    return sizeA == sizeB;
+}
+#endif
+
+#define SECUREC_SPECIAL(_val, Base) \
+            case Base: \
+            do { \
+                *--formatBuf.str = digits[_val % Base]; \
+            }while ((_val /= Base) != 0)
+
+#define SECUREC_SAFE_WRITE_PREFIX(src, txtLen, _stream, outChars) do { \
+            for (ii = 0; ii < txtLen; ++ii) { \
+                *((SecChar *)(void *)(_stream->cur)) = *(src); \
+                _stream->cur += sizeof(SecChar);              \
+                ++(src);                                      \
+            } \
+            _stream->count -= txtLen * (int)(sizeof(SecChar)); \
+            *(outChars) = *(outChars) + (txtLen); \
+        } SECUREC_WHILE_ZERO
+
+#define SECUREC_SAFE_WRITE_STR(src, txtLen, _stream, outChars) do { \
+            if (txtLen < 12 /* for mobile number length */) { \
+                for (ii = 0; ii < txtLen; ++ii) { \
+                    *((SecChar *)(void *)(_stream->cur)) = *(src); \
+                    _stream->cur += sizeof(SecChar); \
+                    ++(src); \
+                } \
+            } else { \
+                (void)memcpy(_stream->cur, src, ((size_t)(unsigned int)txtLen * (sizeof(SecChar)))); \
+                _stream->cur += (size_t)(unsigned int)txtLen * (sizeof(SecChar)); \
+            } \
+            _stream->count -= txtLen * (int)(sizeof(SecChar)); \
+            *(outChars) = *(outChars) + (txtLen); \
+        } SECUREC_WHILE_ZERO
+
+#define SECUREC_SAFE_WRITE_CHAR(_ch, _stream, outChars) do { \
+            *((SecChar *)(void *)(_stream->cur)) = (SecChar)_ch; \
+            _stream->cur += sizeof(SecChar); \
+            _stream->count -= (int)(sizeof(SecChar)); \
+            *(outChars) = *(outChars) + 1; \
+        } SECUREC_WHILE_ZERO
+
+#define SECUREC_SAFE_PADDING(padChar, padLen, _stream, outChars) do { \
+            for (ii = 0; ii < padLen; ++ii) { \
+                *((SecChar *)(void *)(_stream->cur)) = (SecChar)padChar; \
+                _stream->cur += sizeof(SecChar); \
+            } \
+            _stream->count -= padLen * (int)(sizeof(SecChar)); \
+            *(outChars) = *(outChars) + (padLen); \
+        } SECUREC_WHILE_ZERO
+
+/* The count variable can be reduced to 0, and the external function complements the \0 terminator. */
+#define SECUREC_IS_REST_BUF_ENOUGH(needLen) ((int)(stream->count - (int)needLen * (int)(sizeof(SecChar)))  >= 0)
+
+#define SECUREC_FMT_STATE_OFFSET  256
+#ifdef SECUREC_FOR_WCHAR
+#define SECUREC_FMT_TYPE(c,fmtTable)  ((((unsigned int)(int)(c)) <= (unsigned int)(int)SECUREC_CHAR('~')) ? \
+                                      (fmtTable[(unsigned char)(c)]) : 0)
+#define SECUREC_DECODE_STATE(c,fmtTable,laststate) (SecFmtState)(((fmtTable[(SECUREC_FMT_TYPE(c,fmtTable)) * \
+                                                                            ((unsigned char)STAT_INVALID + 1) + \
+                                                                            (unsigned char)(laststate) + \
+                                                                            SECUREC_FMT_STATE_OFFSET])))
+#else
+#define SECUREC_DECODE_STATE(c,fmtTable,laststate) (SecFmtState)((fmtTable[(fmtTable[(unsigned char)(c)]) * \
+                                                                           ((unsigned char)STAT_INVALID + 1) + \
+                                                                           (unsigned char)(laststate) + \
+                                                                           SECUREC_FMT_STATE_OFFSET]))
+#endif
+
+#define PUBLIC_FLAG_LEN  8
+#define PRIVATE_FLAG_LEN 9
+#define PUBLIC_FLAG      "{public}"
+#define PRIVATE_FLAG     "{private}"
+
+static void SecWritePrivateStr(SecPrintfStream *stream, int *pCharsOut)
+{
+    int ii = 0;
+#define PRIVATE_STR_LEN (9)
+#ifndef SECUREC_FOR_WCHAR
+    static const char privacyString[] = "<private>";
+    const char *pPrivStr = privacyString;
+
+    if (SECUREC_IS_REST_BUF_ENOUGH(PRIVATE_STR_LEN)) {
+        SECUREC_SAFE_WRITE_STR(pPrivStr, PRIVATE_STR_LEN, stream, pCharsOut);
+    } else {
+        SECUREC_WRITE_STRING(pPrivStr, PRIVATE_STR_LEN, stream, pCharsOut);
+    }
+#else
+    static const wchar_t wprivacyString[] = { L'<', L'p', L'r', L'i', L'v', L'a', L't', L'e', L'>', L'\0' };
+    const wchar_t *pwPrivStr = wprivacyString;
+
+    if (SECUREC_IS_REST_BUF_ENOUGH(PRIVATE_STR_LEN)) {
+        SECUREC_SAFE_WRITE_STR(pwPrivStr, PRIVATE_STR_LEN, stream, pCharsOut);
+    } else {
+        SECUREC_WRITE_STRING(pwPrivStr, PRIVATE_STR_LEN, stream, pCharsOut);
+    }
+#endif
+}
+
+static void SecDecodeFlags(SecChar ch, SecFormatAttr *attr)
+{
+    switch (ch) {
+    case SECUREC_CHAR(' '):
+        attr->flags |= SECUREC_FLAG_SIGN_SPACE;
+        break;
+    case SECUREC_CHAR('+'):
+        attr->flags |= SECUREC_FLAG_SIGN;
+        break;
+    case SECUREC_CHAR('-'):
+        attr->flags |= SECUREC_FLAG_LEFT;
+        break;
+    case SECUREC_CHAR('0'):
+        attr->flags |= SECUREC_FLAG_LEADZERO;   /* add zero th the front */
+        break;
+    case SECUREC_CHAR('#'):
+        attr->flags |= SECUREC_FLAG_ALTERNATE;  /* output %x with 0x */
+        break;
+    default:
+        break;
+    }
+    return;
+}
+
+static int SecDecodeSize(SecChar ch, SecFormatAttr *attr, const SecChar **format)
+{
+    switch (ch) {
+#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
+    case SECUREC_CHAR('j'):
+        attr->flags |= SECUREC_FLAG_INTMAX;
+        break;
+#endif
+    case SECUREC_CHAR('q'):
+    case SECUREC_CHAR('L'):
+        attr->flags |= SECUREC_FLAG_LONGLONG | SECUREC_FLAG_LONG_DOUBLE;
+        break;
+    case SECUREC_CHAR('l'):
+        if (**format == SECUREC_CHAR('l')) {
+            ++(*format);
+            attr->flags |= SECUREC_FLAG_LONGLONG;   /* long long */
+        } else {
+            attr->flags |= SECUREC_FLAG_LONG;   /* long int or wchar_t */
+        }
+        break;
+    case SECUREC_CHAR('t'):
+        attr->flags |= SECUREC_FLAG_PTRDIFF;
+        break;
+#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
+    case SECUREC_CHAR('z'):
+        attr->flags |= SECUREC_FLAG_SIZE;
+        break;
+    case SECUREC_CHAR('Z'):
+        attr->flags |= SECUREC_FLAG_SIZE;
+        break;
+#endif
+
+    case SECUREC_CHAR('I'):
+#ifdef SECUREC_ON_64BITS
+        attr->flags |= SECUREC_FLAG_I64;    /* %I  to  INT64 */
+#endif
+        if ((**format == SECUREC_CHAR('6')) && (*((*format) + 1) == SECUREC_CHAR('4'))) {
+            (*format) += 2;
+            attr->flags |= SECUREC_FLAG_I64;    /* %I64  to  INT64 */
+        } else if ((**format == SECUREC_CHAR('3')) && (*((*format) + 1) == SECUREC_CHAR('2'))) {
+            (*format) += 2;
+            attr->flags &= ~SECUREC_FLAG_I64;   /* %I64  to  INT32 */
+        } else if ((**format == SECUREC_CHAR('d')) || (**format == SECUREC_CHAR('i')) ||
+                   (**format == SECUREC_CHAR('o')) || (**format == SECUREC_CHAR('u')) ||
+                   (**format == SECUREC_CHAR('x')) || (**format == SECUREC_CHAR('X'))) {
+            /* do nothing */
+        } else {
+            /* Compatibility  code for "%I" just print I */
+            return -1;
+        }
+        break;
+
+    case SECUREC_CHAR('h'):
+        if (**format == SECUREC_CHAR('h'))
+            attr->flags |= SECUREC_FLAG_CHAR;   /* char */
+        else
+            attr->flags |= SECUREC_FLAG_SHORT;  /* short int */
+        break;
+
+    case SECUREC_CHAR('w'):
+        attr->flags |= SECUREC_FLAG_WIDECHAR;   /* wide char */
+        break;
+    default:
+        break;
+
+    }
+
+    return 0;
+}
+
+static int SecDecodeTypeC(SecFormatAttr *attr, unsigned int cValue, SecFormatBuf *formatBuf, SecBuffer *buffer)
+{
+    int textLen;
+    wchar_t wchar;
+
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT)) && !(defined(__hpux)) && !(defined(SECUREC_ON_SOLARIS))
+    attr->flags &= ~SECUREC_FLAG_LEADZERO;
+#endif
+
+#ifdef SECUREC_FOR_WCHAR
+    attr->bufferIsWide = 1;
+    wchar = (wchar_t)cValue;
+    if (attr->flags & SECUREC_FLAG_SHORT) {
+        /* multibyte character to wide  character */
+        char tempchar[2];
+        tempchar[0] = (char)(wchar & 0x00ff);
+        tempchar[1] = '\0';
+
+        if (mbtowc(buffer->wStr, tempchar, sizeof(tempchar)) < 0) {
+            return -1;
+        }
+    } else {
+        buffer->wStr[0] = wchar;
+    }
+    formatBuf->wStr = buffer->wStr;
+    textLen = 1;                /* only 1 wide character */
+#else
+    attr->bufferIsWide = 0;
+    if (attr->flags & (SECUREC_FLAG_LONG | SECUREC_FLAG_WIDECHAR)) {
+        wchar = (wchar_t)cValue;
+        /* wide  character  to multibyte character */
+        SECUREC_MASK_MSVC_CRT_WARNING
+        textLen = wctomb(buffer->str, wchar);
+        SECUREC_END_MASK_MSVC_CRT_WARNING
+        if (textLen < 0) {
+            return -1;
+        }
+    } else {
+        /* get  multibyte character from argument */
+        unsigned short temp;
+        temp = (unsigned short)cValue;
+        buffer->str[0] = (char)temp;
+        textLen = 1;
+    }
+    formatBuf->str = buffer->str;
+#endif
+
+    return textLen;
+}
+
+static int SecDecodeTypeS(SecFormatAttr *attr, char *argPtr, SecFormatBuf *formatBuf)
+{
+    /* literal string to print null ptr, define it on stack rather than const text area
+       is to avoid gcc warning with pointing const text with variable */
+    static char strNullString[8] = "(null)";
+    static wchar_t wStrNullString[8] = { L'(', L'n', L'u', L'l', L'l', L')', L'\0', L'\0' };
+
+    int finalPrecision;
+    char *strEnd = NULL;
+    wchar_t *wStrEnd = NULL;
+    int textLen;
+
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT)) && (!defined(SECUREC_ON_UNIX))
+    attr->flags &= ~SECUREC_FLAG_LEADZERO;
+#endif
+    finalPrecision = (attr->precision == -1) ? SECUREC_INT_MAX : attr->precision;
+    formatBuf->str = argPtr;
+
+#ifdef SECUREC_FOR_WCHAR
+#if defined(SECUREC_COMPATIBLE_LINUX_FORMAT)
+    if (!(attr->flags & SECUREC_FLAG_LONG)) {
+        attr->flags |= SECUREC_FLAG_SHORT;
+    }
+#endif
+    if (attr->flags & SECUREC_FLAG_SHORT) {
+        if (formatBuf->str == NULL) {   /* NULL passed, use special string */
+            formatBuf->str = strNullString;
+        }
+        strEnd = formatBuf->str;
+        for (textLen = 0; textLen < finalPrecision && *strEnd; textLen++) {
+            ++strEnd;
+        }
+        /* textLen now contains length in multibyte chars */
+    } else {
+        if (formatBuf->wStr == NULL) {  /* NULL passed, use special string */
+            formatBuf->wStr = wStrNullString;
+        }
+        attr->bufferIsWide = 1;
+        wStrEnd = formatBuf->wStr;
+        while (finalPrecision-- && *wStrEnd) {
+            ++wStrEnd;
+        }
+        textLen = (int)(wStrEnd - formatBuf->wStr); /* in wchar_ts */
+        /* textLen now contains length in wide chars */
+    }
+#else /* SECUREC_FOR_WCHAR */
+    if (attr->flags & (SECUREC_FLAG_LONG | SECUREC_FLAG_WIDECHAR)) {
+        if (formatBuf->wStr == NULL) {  /* NULL passed, use special string */
+            formatBuf->wStr = wStrNullString;
+        }
+        attr->bufferIsWide = 1;
+        wStrEnd = formatBuf->wStr;
+        while (finalPrecision-- && *wStrEnd) {
+            ++wStrEnd;
+        }
+        textLen = (int)(wStrEnd - formatBuf->wStr);
+    } else {
+        if (formatBuf->str == NULL) {   /* meet NULL, use special string */
+            formatBuf->str = strNullString;
+        }
+
+        if (finalPrecision == SECUREC_INT_MAX) {
+            /* precision NOT assigned */
+            /* The strlen performance is high when the string length is greater than 32 */
+            textLen = (int)strlen(formatBuf->str);
+        } else {
+            /* precision assigned */
+            strEnd = formatBuf->str;
+            while (finalPrecision-- && *strEnd) {
+                ++strEnd;
+            }
+            textLen = (int)(strEnd - formatBuf->str);   /* length of the string */
+        }
+
+    }
+
+#endif /* SECUREC_FOR_WCHAR */
+    return textLen;
+}
+
+HILOG_LOCAL_API
+int SecOutputPS(SecPrintfStream *stream, int priv, const char *cformat, va_list arglist)
+{
+    const SecChar *format = cformat;
+
+    char *floatBuf = NULL;
+    SecFormatBuf formatBuf;
+    static const char *itoaUpperDigits = "0123456789ABCDEFX";
+    static const char *itoaLowerDigits = "0123456789abcdefx";
+    const char *digits = itoaUpperDigits;
+    int ii = 0;
+
+    unsigned int radix;
+    int charsOut;               /* characters written */
+
+    int prefixLen = 0;
+    int padding = 0;
+
+    int textLen;                /* length of the text */
+    int bufferSize = 0;         /* size of formatBuf.str */
+    int noOutput = 0;
+
+    SecFmtState state;
+    SecFmtState laststate;
+
+    SecChar prefix[2] = { 0 };
+    SecChar ch;                 /* currently read character */
+
+    static const unsigned char fmtCharTable[337] = {
+        /* type 0:    nospecial meaning;
+           1:   '%';
+           2:    '.'
+           3:    '*'
+           4:    '0'
+           5:    '1' ... '9'
+           6:    ' ', '+', '-', '#'
+           7:     'h', 'l', 'L', 'F', 'w' , 'N','z','q','t','j'
+           8:     'd','o','u','i','x','X','e','f','g'
+         */
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x00,
+        0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x08, 0x08, 0x00, 0x07, 0x00, 0x00, 0x07, 0x00, 0x07, 0x00,
+        0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x07, 0x08, 0x07, 0x00, 0x07, 0x00, 0x00, 0x08,
+        0x08, 0x07, 0x00, 0x08, 0x07, 0x08, 0x00, 0x07, 0x08, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
+        /* fill zero  for normal char 128 byte for 0x80 - 0xff */
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        /* state  0: normal
+           1: percent
+           2: flag
+           3: width
+           4: dot
+           5: precis
+           6: size
+           7: type
+           8: invalid
+         */
+        0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x01, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08,
+        0x01, 0x00, 0x00, 0x04, 0x04, 0x04, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x03, 0x03, 0x08, 0x05,
+        0x08, 0x08, 0x00, 0x00, 0x00, 0x02, 0x02, 0x03, 0x05, 0x05, 0x08, 0x00, 0x00, 0x00, 0x03, 0x03,
+        0x03, 0x05, 0x05, 0x08, 0x00, 0x00, 0x00, 0x02, 0x02, 0x02, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00,
+        0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x00,
+        0x00
+    };
+
+    SecFormatAttr formatAttr;
+    SecBuffer buffer;
+    formatAttr.flags = 0;
+    formatAttr.bufferIsWide = 0;    /* flag for buffer contains wide chars */
+    formatAttr.fldWidth = 0;
+    formatAttr.precision = 0;
+    formatAttr.dynWidth = 0;
+    formatAttr.dynPrecision = 0;
+
+    charsOut = 0;
+    textLen = 0;
+    state = STAT_NORMAL;        /* starting state */
+    formatBuf.str = NULL;
+
+    int isPrivacy = 1; /*whether show private string*/
+
+    /* loop each format character */
+    /* remove format != NULL */
+    while ((ch = *format++) != SECUREC_CHAR('\0') && charsOut >= 0) {
+        laststate = state;
+        state = SECUREC_DECODE_STATE(ch, fmtCharTable, laststate);
+
+        switch (state) {
+        case STAT_NORMAL:
+
+NORMAL_CHAR:
+
+            /* normal state, write character */
+            if (SECUREC_IS_REST_BUF_ENOUGH(1 /* only one char */ )) {
+                SECUREC_SAFE_WRITE_CHAR(ch, stream, &charsOut); /* char * cast to wchar * */
+            } else {
+#ifdef SECUREC_FOR_WCHAR
+                SECUREC_WRITE_CHAR(ch, stream, &charsOut);
+#else
+                /* optimize function call to code */
+                charsOut = -1;
+                stream->count = -1;
+#endif
+            }
+
+            continue;
+
+        case STAT_PERCENT:
+            /* set default values */
+            prefixLen = 0;
+            noOutput = 0;
+            formatAttr.flags = 0;
+            formatAttr.fldWidth = 0;
+            formatAttr.precision = -1;
+            formatAttr.bufferIsWide = 0;
+            if (*format == SECUREC_CHAR('{')) {
+                if (strncmp(format, PUBLIC_FLAG, PUBLIC_FLAG_LEN) == 0) {
+                    isPrivacy = 0;
+                    format += PUBLIC_FLAG_LEN;
+                }
+                else if (strncmp(format, PRIVATE_FLAG, PRIVATE_FLAG_LEN) == 0) {
+                    isPrivacy = 1;
+                    format += PRIVATE_FLAG_LEN;
+                }
+            }
+            else {
+                isPrivacy = 1;
+            }
+
+            if (0 == priv) {
+                isPrivacy = 0;
+            }
+
+            break;
+
+        case STAT_FLAG:
+            /* set flag based on which flag character */
+            SecDecodeFlags(ch, &formatAttr);
+            break;
+
+        case STAT_WIDTH:
+            /* update width value */
+            if (ch == SECUREC_CHAR('*')) {
+                /* get width */
+                formatAttr.fldWidth = (int)va_arg(arglist, int);
+                if (formatAttr.fldWidth < 0) {
+                    formatAttr.flags |= SECUREC_FLAG_LEFT;
+                    formatAttr.fldWidth = -formatAttr.fldWidth;
+                }
+                formatAttr.dynWidth = 1;
+            } else {
+                if (laststate != STAT_WIDTH) {
+                    formatAttr.fldWidth = 0;
+                }
+                if (SECUREC_MUL10_ADD_BEYOND_MAX(formatAttr.fldWidth)) {
+                    return -1;
+                }
+                formatAttr.fldWidth = (int)SECUREC_MUL10((unsigned int)formatAttr.fldWidth) + (ch - SECUREC_CHAR('0'));
+                formatAttr.dynWidth = 0;
+            }
+            break;
+
+        case STAT_DOT:
+            formatAttr.precision = 0;
+            break;
+
+        case STAT_PRECIS:
+            /* update precision value */
+            if (ch == SECUREC_CHAR('*')) {
+                /* get precision from arg list */
+                formatAttr.precision = (int)va_arg(arglist, int);
+                if (formatAttr.precision < 0) {
+                    formatAttr.precision = -1;
+                }
+                formatAttr.dynPrecision = 1;
+            } else {
+                /* add digit to current precision */
+                if (SECUREC_MUL10_ADD_BEYOND_MAX(formatAttr.precision)) {
+                    return -1;
+                }
+                formatAttr.precision =
+                    (int)SECUREC_MUL10((unsigned int)formatAttr.precision) + (ch - SECUREC_CHAR('0'));
+                formatAttr.dynPrecision = 0;
+            }
+            break;
+
+        case STAT_SIZE:
+            /* read a size specifier, set the formatAttr.flags based on it */
+            if (SecDecodeSize(ch, &formatAttr, &format) != 0) {
+                /* Compatibility  code for "%I" just print I */
+                state = STAT_NORMAL;
+                goto NORMAL_CHAR;
+            }
+            break;
+
+        case STAT_TYPE:
+
+            switch (ch) {
+
+            case SECUREC_CHAR('C'):
+                /* wide char */
+                if (!(formatAttr.flags & (SECUREC_FLAG_SHORT | SECUREC_FLAG_LONG | SECUREC_FLAG_WIDECHAR))) {
+
+#ifdef SECUREC_FOR_WCHAR
+                    formatAttr.flags |= SECUREC_FLAG_SHORT;
+#else
+                    formatAttr.flags |= SECUREC_FLAG_WIDECHAR;
+#endif
+                }
+                /* fall-through */
+                /* FALLTHRU */
+            case SECUREC_CHAR('c'):
+                {
+                    unsigned int cValue = (unsigned int)va_arg(arglist, int);
+                    /*if it's a private arg, just write <priate> to stream*/
+                    if (isPrivacy == 1) {
+                        break;
+                    }
+                    textLen = SecDecodeTypeC(&formatAttr, cValue, &formatBuf, &buffer);
+                    if (textLen < 0) {
+                        noOutput = 1;
+                    }
+                }
+                break;
+            case SECUREC_CHAR('S'):    /* wide char string */
+#ifndef SECUREC_FOR_WCHAR
+                if (!(formatAttr.flags & (SECUREC_FLAG_SHORT | SECUREC_FLAG_LONG | SECUREC_FLAG_WIDECHAR))) {
+                    formatAttr.flags |= SECUREC_FLAG_WIDECHAR;
+                }
+#else
+                if (!(formatAttr.flags & (SECUREC_FLAG_SHORT | SECUREC_FLAG_LONG | SECUREC_FLAG_WIDECHAR))) {
+                    formatAttr.flags |= SECUREC_FLAG_SHORT;
+                }
+#endif
+                /* fall-through */
+                /* FALLTHRU */
+            case SECUREC_CHAR('s'):
+                {
+                    char *argPtr = (char *)va_arg(arglist, char *);
+                    /*if it's a private arg, just write <priate> to stream*/
+                    if (isPrivacy == 1) {
+                        break;
+                    }
+                    textLen = SecDecodeTypeS(&formatAttr, argPtr, &formatBuf);
+                }
+                break;
+
+            case SECUREC_CHAR('n'):
+                /* higher risk disable it */
+                return -1;
+
+            case SECUREC_CHAR('E'):    /* fall-through */ /* FALLTHRU */
+            case SECUREC_CHAR('F'):    /* fall-through */ /* FALLTHRU */
+            case SECUREC_CHAR('G'):    /* fall-through */ /* FALLTHRU */
+            case SECUREC_CHAR('A'):    /* fall-through */ /* FALLTHRU */
+                /* convert format char to lower , use Explicit conversion to clean up compilation warning */
+                ch = (SecChar) (ch + ((SecChar) (SECUREC_CHAR('a')) - (SECUREC_CHAR('A'))));
+                /* fall-through */
+                /* FALLTHRU */
+            case SECUREC_CHAR('e'):    /* fall-through */ /* FALLTHRU */
+            case SECUREC_CHAR('f'):    /* fall-through */ /* FALLTHRU */
+            case SECUREC_CHAR('g'):    /* fall-through */ /* FALLTHRU */
+            case SECUREC_CHAR('a'):
+                {
+                    /*if it's a private arg, just write <priate> to stream*/
+                    if (isPrivacy == 1) {
+#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
+                        if (formatAttr.flags & SECUREC_FLAG_LONG_DOUBLE) {
+                            (void)va_arg(arglist, long double);
+                        } else
+#endif
+                        {
+                            (void)va_arg(arglist, double);
+                        }
+                        break;
+                    }
+
+                    /* floating point conversion */
+                    formatBuf.str = buffer.str; /* output buffer for float string with default size */
+
+                    /* compute the precision value */
+                    if (formatAttr.precision < 0) {
+                        formatAttr.precision = 6;
+                    } else if (formatAttr.precision == 0 && ch == SECUREC_CHAR('g')) {
+                        formatAttr.precision = 1;
+                    }
+
+                    /* calc buffer size to store long double value */
+                    if (formatAttr.flags & SECUREC_FLAG_LONG_DOUBLE) {
+                        if (formatAttr.precision > (SECUREC_INT_MAX - SECUREC_FLOAT_BUFSIZE_LB)) {
+                            noOutput = 1;
+                            break;
+                        }
+                        bufferSize = SECUREC_FLOAT_BUFSIZE_LB + formatAttr.precision;
+                    } else {
+                        if (formatAttr.precision > (SECUREC_INT_MAX - SECUREC_FLOAT_BUFSIZE)) {
+                            noOutput = 1;
+                            break;
+                        }
+                        bufferSize = SECUREC_FLOAT_BUFSIZE + formatAttr.precision;
+                    }
+                    if (formatAttr.fldWidth > bufferSize) {
+                        bufferSize = formatAttr.fldWidth;
+                    }
+
+                    if (bufferSize >= SECUREC_BUFFER_SIZE) {
+                        /* the current value of SECUREC_BUFFER_SIZE could NOT store the formatted float string */
+                        /* size include '+' and '\0' */
+                        floatBuf = (char *)SECUREC_MALLOC(((size_t)(unsigned int)bufferSize + (size_t)2));
+                        if (floatBuf != NULL) {
+                            formatBuf.str = floatBuf;
+                        } else {
+                            noOutput = 1;
+                            break;
+                        }
+                    }
+
+                    {
+                        /* add following code to call system sprintf API for float number */
+                        const SecChar *pFltFmt = format - 2;    /* point to the position before 'f' or 'g' */
+                        int k;
+                        int fltFmtStrLen;
+                        char fltFmtBuf[SECUREC_FMT_STR_LEN];
+                        char *fltFmtStr = fltFmtBuf;
+                        char *fltFmtHeap = NULL;    /* to clear warning */
+
+                        /* must meet '%' (normal format) or '}'(with{private} or{public} format)*/
+                        while (SECUREC_CHAR('%') != *pFltFmt && SECUREC_CHAR('}') != *pFltFmt) {
+                            --pFltFmt;
+                        }
+                        fltFmtStrLen = (int)((format - pFltFmt) + 1);   /* with ending terminator */
+                        if (fltFmtStrLen > SECUREC_FMT_STR_LEN) {
+                            /* if SECUREC_FMT_STR_LEN is NOT enough, alloc a new buffer */
+                            fltFmtHeap = (char *)SECUREC_MALLOC((size_t)((unsigned int)fltFmtStrLen));
+                            if (fltFmtHeap == NULL) {
+                                noOutput = 1;
+                                break;
+                            } else {
+                                fltFmtHeap[0] = '%';
+                                for (k = 1; k < fltFmtStrLen - 1; ++k) {
+                                    /* convert wchar to char */
+                                    fltFmtHeap[k] = (char)(pFltFmt[k]); /* copy the format string */
+                                }
+                                fltFmtHeap[k] = '\0';
+
+                                fltFmtStr = fltFmtHeap;
+                            }
+                        } else {
+                            /* purpose of the repeat code is to solve the tool alarm  Redundant_Null_Check */
+                            fltFmtBuf[0] = '%';
+                            for (k = 1; k < fltFmtStrLen - 1; ++k) {
+                                /* convert wchar to char */
+                                fltFmtBuf[k] = (char)(pFltFmt[k]);  /* copy the format string */
+                            }
+                            fltFmtBuf[k] = '\0';
+                        }
+
+#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
+                        if (formatAttr.flags & SECUREC_FLAG_LONG_DOUBLE) {
+                            long double tmp = (long double)va_arg(arglist, long double);
+                            /* call system sprintf to format float value */
+                            if (formatAttr.dynWidth && formatAttr.dynPrecision) {
+                                textLen = SecIndirectSprintf(formatBuf.str, (char *)fltFmtStr,
+                                                             formatAttr.fldWidth,formatAttr.precision, tmp);
+                            } else if (formatAttr.dynWidth) {
+                                textLen = SecIndirectSprintf(formatBuf.str, (char *)fltFmtStr,
+                                                             formatAttr.fldWidth, tmp);
+                            } else if (formatAttr.dynPrecision) {
+                                textLen = SecIndirectSprintf(formatBuf.str, (char *)fltFmtStr,
+                                                             formatAttr.precision, tmp);
+                            } else {
+                                textLen = SecIndirectSprintf(formatBuf.str, (char *)fltFmtStr, tmp);
+                            }
+                        } else
+#endif
+                        {
+                            double tmp = (double)va_arg(arglist, double);
+                            if (formatAttr.dynWidth && formatAttr.dynPrecision) {
+                                textLen = SecIndirectSprintf(formatBuf.str, (char *)fltFmtStr, formatAttr.fldWidth,
+                                                             formatAttr.precision, tmp);
+                            } else if (formatAttr.dynWidth) {
+                                textLen = SecIndirectSprintf(formatBuf.str, (char *)fltFmtStr, formatAttr.fldWidth,
+                                                             tmp);
+                            } else if (formatAttr.dynPrecision) {
+                                textLen = SecIndirectSprintf(formatBuf.str, (char *)fltFmtStr, formatAttr.precision,
+                                                             tmp);
+                            } else {
+                                textLen = SecIndirectSprintf(formatBuf.str, (char *)fltFmtStr, tmp);
+                            }
+                        }
+
+                        if (fltFmtHeap != NULL) {
+                            /* if buffer is allocated on heap, free it */
+                            SECUREC_FREE(fltFmtHeap);
+                            fltFmtHeap = NULL;
+                            /* to clear e438 last value assigned not used , the compiler will optimize this code */
+                            (void)fltFmtHeap;
+                        }
+                        if (textLen < 0) {
+                            /* bufferSize is large enough,just validation the return value */
+                            noOutput = 1;
+                            break;
+                        }
+
+                        formatAttr.fldWidth = textLen;  /* no padding ,this variable to calculate amount of padding */
+                        prefixLen = 0;  /* no padding ,this variable to  calculate amount of padding */
+                        formatAttr.flags = 0;   /* clear all internal formatAttr.flags */
+                        break;
+                    }
+                }
+
+            case SECUREC_CHAR('p'):
+                /* print a pointer */
+#if defined(SECUREC_COMPATIBLE_WIN_FORMAT)
+                formatAttr.flags &= ~SECUREC_FLAG_LEADZERO;
+#else
+                formatAttr.flags |= SECUREC_FLAG_POINTER;
+#endif
+
+#ifdef SECUREC_ON_64BITS
+                formatAttr.flags |= SECUREC_FLAG_I64;   /* converting an int64 */
+#else
+                formatAttr.flags |= SECUREC_FLAG_LONG;  /* converting a long */
+#endif
+
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) || defined(SECUREC_VXWORKS_PLATFORM)) && (!defined(SECUREC_ON_UNIX))
+
+#if defined(SECUREC_VXWORKS_PLATFORM)
+                formatAttr.precision = 1;
+#else
+                formatAttr.precision = 0;
+#endif
+                formatAttr.flags |= SECUREC_FLAG_ALTERNATE; /* "0x" is not default prefix in UNIX */
+                digits = itoaLowerDigits;
+                goto OUTPUT_HEX;
+#else
+/* not linux vxwoks */
+#if defined(_AIX) || defined(SECUREC_ON_SOLARIS)
+                formatAttr.precision = 1;
+#else
+                formatAttr.precision = 2 * sizeof(void *);
+#endif
+
+#endif
+
+#if defined(SECUREC_ON_UNIX)
+                digits = itoaLowerDigits;
+                goto OUTPUT_HEX;
+#endif
+
+                /* fall-through */
+                /* FALLTHRU */
+            case SECUREC_CHAR('X'):
+                /* unsigned upper hex output */
+                digits = itoaUpperDigits;
+                goto OUTPUT_HEX;
+            case SECUREC_CHAR('x'):
+                /* unsigned lower hex output */
+                digits = itoaLowerDigits;
+
+OUTPUT_HEX:
+                radix = 16;
+                if (formatAttr.flags & SECUREC_FLAG_ALTERNATE) {
+                    /* alternate form means '0x' prefix */
+                    prefix[0] = SECUREC_CHAR('0');
+                    prefix[1] = (SecChar) (digits[16]); /* 'x' or 'X' */
+
+#if (defined(SECUREC_COMPATIBLE_LINUX_FORMAT) || defined(SECUREC_VXWORKS_PLATFORM))
+                    if (ch == 'p') {
+                        prefix[1] = SECUREC_CHAR('x');
+                    }
+#endif
+#if defined(_AIX) || defined(SECUREC_ON_SOLARIS)
+                    if (ch == 'p') {
+                        prefixLen = 0;
+                    } else {
+                        prefixLen = 2;
+                    }
+#else
+                    prefixLen = 2;
+#endif
+
+                }
+                goto OUTPUT_INT;
+            case SECUREC_CHAR('i'):    /* fall-through */ /* FALLTHRU */
+            case SECUREC_CHAR('d'):    /* fall-through */ /* FALLTHRU */
+                /* signed decimal output */
+                formatAttr.flags |= SECUREC_FLAG_SIGNED;
+                /* fall-through */
+                /* FALLTHRU */
+            case SECUREC_CHAR('u'):
+                radix = 10;
+                goto OUTPUT_INT;
+            case SECUREC_CHAR('o'):
+                /* unsigned octal output */
+                radix = 8;
+                if (formatAttr.flags & SECUREC_FLAG_ALTERNATE) {
+                    /* alternate form means force a leading 0 */
+                    formatAttr.flags |= SECUREC_FLAG_FORCE_OCTAL;
+                }
+OUTPUT_INT:
+                {
+
+                    SecUnsignedInt64 number = 0;    /* number to convert */
+                    SecInt64 l; /* temp long value */
+                    unsigned char tch;
+#if defined(SECUREC_VXWORKS_VERSION_5_4) && !defined(SECUREC_ON_64BITS)
+                    SecUnsignedInt32 digit = 0; /* ascii value of digit */
+                    SecUnsignedInt32 quotientHigh = 0;
+                    SecUnsignedInt32 quotientLow = 0;
+#endif
+
+                    /* read argument into variable l */
+                    if (formatAttr.flags & SECUREC_FLAG_I64) {
+                        l = (SecInt64)va_arg(arglist, SecInt64);
+                    } else if (formatAttr.flags & SECUREC_FLAG_LONGLONG) {
+                        l = (SecInt64)va_arg(arglist, SecInt64);
+                    } else
+#ifdef SECUREC_ON_64BITS
+                    if (formatAttr.flags & SECUREC_FLAG_LONG) {
+                        l = (long)va_arg(arglist, long);
+                    } else
+#endif /* SECUREC_ON_64BITS */
+                    if (formatAttr.flags & SECUREC_FLAG_CHAR) {
+                        if (formatAttr.flags & SECUREC_FLAG_SIGNED) {
+                            l = (char)va_arg(arglist, int); /* sign extend */
+                            if (l >= 128) { /* on some platform, char is always unsigned */
+                                SecUnsignedInt64 tmpL = (SecUnsignedInt64)l;
+                                formatAttr.flags |= SECUREC_FLAG_NEGATIVE;
+                                tch = (unsigned char)(~(tmpL));
+                                l = tch + 1;
+                            }
+                        } else {
+                            l = (unsigned char)va_arg(arglist, int);    /* zero-extend */
+                        }
+
+                    } else if (formatAttr.flags & SECUREC_FLAG_SHORT) {
+                        if (formatAttr.flags & SECUREC_FLAG_SIGNED) {
+                            l = (short)va_arg(arglist, int);    /* sign extend */
+                        } else {
+                            l = (unsigned short)va_arg(arglist, int);   /* zero-extend */
+                        }
+
+                    }
+#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
+                    else if (formatAttr.flags & SECUREC_FLAG_PTRDIFF) {
+                        l = (ptrdiff_t)va_arg(arglist, ptrdiff_t);  /* sign extend */
+                    } else if (formatAttr.flags & SECUREC_FLAG_SIZE) {
+                        if (formatAttr.flags & SECUREC_FLAG_SIGNED) {
+                            /* No suitable macros were found to handle the branch */
+                            if (SecIsSameSize(sizeof(size_t), sizeof(long))) {
+                                l = va_arg(arglist, long);  /* sign extend */
+                            } else if (SecIsSameSize(sizeof(size_t), sizeof(long long))) {
+                                l = va_arg(arglist, long long); /* sign extend */
+                            } else {
+                                l = va_arg(arglist, int);   /* sign extend */
+                            }
+                        } else {
+                            l = (SecInt64)(size_t)va_arg(arglist, size_t);  /* sign extend */
+                        }
+                    } else if (formatAttr.flags & SECUREC_FLAG_INTMAX) {
+                        if (formatAttr.flags & SECUREC_FLAG_SIGNED) {
+                            l = va_arg(arglist, SecInt64);  /* sign extend */
+                        } else {
+                            l = (SecInt64)(SecUnsignedInt64)va_arg(arglist, SecUnsignedInt64);  /* sign extend */
+                        }
+                    }
+#endif
+                    else {
+                        if (formatAttr.flags & SECUREC_FLAG_SIGNED) {
+                            l = va_arg(arglist, int);   /* sign extend */
+                        } else {
+                            l = (unsigned int)va_arg(arglist, int); /* zero-extend */
+                        }
+
+                    }
+                    /*if it's a private arg, just write <priate> to stream*/
+                    if (isPrivacy == 1) {
+                        break;
+                    }
+
+                    /* check for negative; copy into number */
+                    if ((formatAttr.flags & SECUREC_FLAG_SIGNED) && l < 0) {
+                        number = (SecUnsignedInt64)(-l);
+                        formatAttr.flags |= SECUREC_FLAG_NEGATIVE;
+                    } else {
+                        number = (SecUnsignedInt64)l;
+                    }
+
+                    if (((formatAttr.flags & SECUREC_FLAG_I64) == 0) &&
+#ifdef SECUREC_COMPATIBLE_LINUX_FORMAT
+                        ((formatAttr.flags & SECUREC_FLAG_INTMAX) == 0) &&
+#endif
+#ifdef SECUREC_ON_64BITS
+                        ((formatAttr.flags & SECUREC_FLAG_PTRDIFF) == 0) &&
+                        ((formatAttr.flags & SECUREC_FLAG_SIZE) == 0) &&
+#if !defined(SECUREC_COMPATIBLE_WIN_FORMAT)  /* on window 64 system sizeof long is 32bit */
+                        ((formatAttr.flags & SECUREC_FLAG_LONG) == 0) &&
+#endif
+#endif
+                        ((formatAttr.flags & SECUREC_FLAG_LONGLONG) == 0)) {
+
+                            number &= 0xffffffff;
+                    }
+
+                    /* check precision value for default */
+                    if (formatAttr.precision < 0) {
+                        formatAttr.precision = 1;   /* default precision */
+                    } else {
+#if defined(SECUREC_COMPATIBLE_WIN_FORMAT)
+                        formatAttr.flags &= ~SECUREC_FLAG_LEADZERO;
+#else
+                        if (!(formatAttr.flags & SECUREC_FLAG_POINTER)) {
+                            formatAttr.flags &= ~SECUREC_FLAG_LEADZERO;
+                        }
+#endif
+                        if (formatAttr.precision > SECUREC_MAX_PRECISION) {
+                            formatAttr.precision = SECUREC_MAX_PRECISION;
+                        }
+                    }
+
+                    /* Check if data is 0; if so, turn off hex prefix,if 'p',add 0x prefix,else not add prefix */
+                    if (number == 0) {
+#if !(defined(SECUREC_VXWORKS_PLATFORM)||defined(__hpux))
+                        prefixLen = 0;
+#else
+                        if ((ch == 'p') && (formatAttr.flags & SECUREC_FLAG_ALTERNATE))
+                            prefixLen = 2;
+                        else
+                            prefixLen = 0;
+#endif
+                    }
+
+                    /* Convert data to ASCII */
+                    formatBuf.str = &buffer.str[SECUREC_BUFFER_SIZE];
+
+                    if (number > 0) {
+#ifdef SECUREC_ON_64BITS
+                        switch (radix) {
+                            /* the compiler will optimize each one */
+                            SECUREC_SPECIAL(number, 10);
+                            break;
+                            SECUREC_SPECIAL(number, 16);
+                            break;
+                            SECUREC_SPECIAL(number, 8);
+                            break;
+                        default:
+                            break;
+                        }
+#else /* for 32 bits system */
+                        if (number <= 0xFFFFFFFFUL) {
+                            /* in most case, the value to be converted is small value */
+                            SecUnsignedInt32 n32Tmp = (SecUnsignedInt32)number;
+                            switch (radix) {
+                                SECUREC_SPECIAL(n32Tmp, 16);
+                                break;
+                                SECUREC_SPECIAL(n32Tmp, 8);
+                                break;
+
+#ifdef _AIX
+                                /* the compiler will optimize div 10 */
+                                SECUREC_SPECIAL(n32Tmp, 10);
+                                break;
+#else
+                            case 10:
+                                {
+                                    /* fast div 10 */
+                                    SecUnsignedInt32 q;
+                                    SecUnsignedInt32 r;
+                                    do {
+                                        *--formatBuf.str = digits[n32Tmp % 10];
+                                        q = (n32Tmp >> 1) + (n32Tmp >> 2);
+                                        q = q + (q >> 4);
+                                        q = q + (q >> 8);
+                                        q = q + (q >> 16);
+                                        q = q >> 3;
+                                        r = n32Tmp - (((q << 2) + q) << 1);
+                                        n32Tmp = (r > 9) ? (q + 1) : q;
+                                    } while (n32Tmp != 0);
+                                }
+                                break;
+#endif
+                            default:
+                                break;
+                            }   /* end switch */
+                        } else {
+                            /* the value to be converted is greater than 4G */
+#if defined(SECUREC_VXWORKS_VERSION_5_4)
+                            do {
+                                if (0 != SecU64Div32((SecUnsignedInt32)((number >> 16) >> 16),
+                                                     (SecUnsignedInt32)number,
+                                                     (SecUnsignedInt32)radix, &quotientHigh, &quotientLow, &digit)) {
+                                    noOutput = 1;
+                                    break;
+                                }
+                                *--formatBuf.str = digits[digit];
+
+                                number = (SecUnsignedInt64)quotientHigh;
+                                number = (number << 32) + quotientLow;
+                            } while (number != 0);
+#else
+                            switch (radix) {
+                                /* the compiler will optimize div 10 */
+                                SECUREC_SPECIAL(number, 10);
+                                break;
+                                SECUREC_SPECIAL(number, 16);
+                                break;
+                                SECUREC_SPECIAL(number, 8);
+                                break;
+                            default:
+                                break;
+                            }
+#endif
+                        }
+#endif
+                    }           /* END if (number > 0) */
+                    /* compute length of number,.if textLen > 0, then formatBuf.str must be in buffer.str */
+                    textLen = (int)((char *)&buffer.str[SECUREC_BUFFER_SIZE] - formatBuf.str);
+                    if (formatAttr.precision > textLen) {
+                        for (ii = 0; ii < formatAttr.precision - textLen; ++ii) {
+                            *--formatBuf.str = '0';
+                        }
+                        textLen = formatAttr.precision;
+                    }
+
+                    /* Force a leading zero if FORCEOCTAL flag set */
+                    if ((formatAttr.flags & SECUREC_FLAG_FORCE_OCTAL) && (textLen == 0 || formatBuf.str[0] != '0')) {
+                        *--formatBuf.str = '0';
+                        ++textLen;  /* add a zero */
+                    }
+                }
+                break;
+            default:
+                break;
+            }
+            /*if it's a private arg, just write <priate> to stream*/
+            if (isPrivacy == 1) {
+                SecWritePrivateStr(stream, &charsOut);
+                break;
+            }
+
+            if (noOutput == 0) {
+                if (formatAttr.flags & SECUREC_FLAG_SIGNED) {
+                    if (formatAttr.flags & SECUREC_FLAG_NEGATIVE) {
+                        /* prefix is a '-' */
+                        prefix[0] = SECUREC_CHAR('-');
+                        prefixLen = 1;
+                    } else if (formatAttr.flags & SECUREC_FLAG_SIGN) {
+                        /* prefix is '+' */
+                        prefix[0] = SECUREC_CHAR('+');
+                        prefixLen = 1;
+                    } else if (formatAttr.flags & SECUREC_FLAG_SIGN_SPACE) {
+                        /* prefix is ' ' */
+                        prefix[0] = SECUREC_CHAR(' ');
+                        prefixLen = 1;
+                    }
+                }
+
+#if defined(SECUREC_COMPATIBLE_LINUX_FORMAT) && (!defined(SECUREC_ON_UNIX))
+                if ((formatAttr.flags & SECUREC_FLAG_POINTER) && (0 == textLen)) {
+                    formatAttr.flags &= ~SECUREC_FLAG_LEADZERO;
+                    formatBuf.str = &buffer.str[SECUREC_BUFFER_SIZE - 1];
+                    *formatBuf.str-- = '\0';
+                    *formatBuf.str-- = ')';
+                    *formatBuf.str-- = 'l';
+                    *formatBuf.str-- = 'i';
+                    *formatBuf.str-- = 'n';
+                    *formatBuf.str = '(';
+                    textLen = 5;
+                }
+#endif
+
+                /* calculate amount of padding */
+                padding = (formatAttr.fldWidth - textLen) - prefixLen;
+
+                /* put out the padding, prefix, and text, in the correct order */
+
+                if (!(formatAttr.flags & (SECUREC_FLAG_LEFT | SECUREC_FLAG_LEADZERO)) && padding > 0) {
+                    /* pad on left with blanks */
+                    if (SECUREC_IS_REST_BUF_ENOUGH(padding)) {
+                        /* char * cast to wchar * */
+                        SECUREC_SAFE_PADDING(SECUREC_CHAR(' '), padding, stream, &charsOut);
+                    } else {
+                        SECUREC_WRITE_MULTI_CHAR(SECUREC_CHAR(' '), padding, stream, &charsOut);
+                    }
+                }
+
+                /* write prefix */
+                if (prefixLen > 0) {
+                    SecChar *pPrefix = prefix;
+                    if (SECUREC_IS_REST_BUF_ENOUGH(prefixLen)) {
+                        /* max prefix len is 2, use loop copy */ /* char * cast to wchar * */
+                        SECUREC_SAFE_WRITE_PREFIX(pPrefix, prefixLen, stream, &charsOut);
+                    } else {
+                        SECUREC_WRITE_STRING(prefix, prefixLen, stream, &charsOut);
+                    }
+                }
+
+                if ((formatAttr.flags & SECUREC_FLAG_LEADZERO) && !(formatAttr.flags & SECUREC_FLAG_LEFT)
+                    && padding > 0) {
+                    /* write leading zeros */
+                    if (SECUREC_IS_REST_BUF_ENOUGH(padding)) {
+                        /* char * cast to wchar * */
+                        SECUREC_SAFE_PADDING(SECUREC_CHAR('0'), padding, stream, &charsOut);
+                    } else {
+                        SECUREC_WRITE_MULTI_CHAR(SECUREC_CHAR('0'), padding, stream, &charsOut);
+                    }
+                }
+
+                /* write text */
+#ifndef SECUREC_FOR_WCHAR
+                if (formatAttr.bufferIsWide && (textLen > 0)) {
+                    wchar_t *p = formatBuf.wStr;
+                    int count = textLen;
+                    while (count--) {
+                        char tmpBuf[SECUREC_MB_LEN + 1];
+                        SECUREC_MASK_MSVC_CRT_WARNING
+                        int retVal = wctomb(tmpBuf, *p++);
+                        SECUREC_END_MASK_MSVC_CRT_WARNING
+                        if (retVal <= 0) {
+                            charsOut = -1;
+                            break;
+                        }
+                        SECUREC_WRITE_STRING(tmpBuf, retVal, stream, &charsOut);
+                    }
+                } else {
+                    if (SECUREC_IS_REST_BUF_ENOUGH(textLen)) {
+                        SECUREC_SAFE_WRITE_STR(formatBuf.str, textLen, stream, &charsOut);
+                    } else {
+                        SECUREC_WRITE_STRING(formatBuf.str, textLen, stream, &charsOut);
+                    }
+                }
+#else /* SECUREC_FOR_WCHAR */
+                if (formatAttr.bufferIsWide == 0 && textLen > 0) {
+                    int count = textLen;
+                    char *p = formatBuf.str;
+
+                    while (count > 0) {
+                        wchar_t wchar = L'\0';
+                        int retVal = mbtowc(&wchar, p, (size_t)MB_CUR_MAX);
+                        if (retVal <= 0) {
+                            charsOut = -1;
+                            break;
+                        }
+                        SECUREC_WRITE_CHAR(wchar, stream, &charsOut);
+                        p += retVal;
+                        count -= retVal;
+                    }
+                } else {
+                    if (SECUREC_IS_REST_BUF_ENOUGH(textLen)) {
+                        SECUREC_SAFE_WRITE_STR(formatBuf.wStr, textLen, stream, &charsOut); /* char * cast to wchar * */
+                    } else {
+                        SECUREC_WRITE_STRING(formatBuf.wStr, textLen, stream, &charsOut);
+                    }
+                }
+#endif /* SECUREC_FOR_WCHAR */
+
+                if (charsOut >= 0 && (formatAttr.flags & SECUREC_FLAG_LEFT) && padding > 0) {
+                    /* pad on right with blanks */
+                    if (SECUREC_IS_REST_BUF_ENOUGH(padding)) {
+                        /* char * cast to wchar * */
+                        SECUREC_SAFE_PADDING(SECUREC_CHAR(' '), padding, stream, &charsOut);
+                    } else {
+                        SECUREC_WRITE_MULTI_CHAR(SECUREC_CHAR(' '), padding, stream, &charsOut);
+                    }
+                }
+
+                /* we're done! */
+            }
+            if (floatBuf != NULL) {
+                SECUREC_FREE(floatBuf);
+                floatBuf = NULL;
+            }
+            break;
+        case STAT_INVALID:
+            return -1;
+        default:
+            return -1;          /* input format is wrong, directly return */
+        }
+    }
+
+    if (state != STAT_NORMAL && state != STAT_TYPE) {
+        return -1;
+    }
+
+    return charsOut;            /* the number of characters written */
+}                               /* arglist must not be declare as const */
+#endif /* OUTPUT_P_INL_2B263E9C_43D8_44BB_B17A_6D2033DECEE5 */
+
diff --git a/src/hilog/vsnprintf_s_p.c b/src/hilog/vsnprintf_s_p.c
new file mode 100644
index 00000000..f93215e0
--- /dev/null
+++ b/src/hilog/vsnprintf_s_p.c
@@ -0,0 +1,293 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "vsnprintf_s_p.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+/* Do not malloc in vsnprintf, thus the log api can be called inside signal handler*/
+#define HILOG_PROHIBIT_ALLOCATION
+
+/* Define the max length of the string */
+#ifndef SECUREC_STRING_MAX_LEN
+#define SECUREC_STRING_MAX_LEN 0x7fffffffUL
+#endif
+
+#if SECUREC_STRING_MAX_LEN > 0x7fffffffUL
+#error "max string is 2G"
+#endif
+
+#if defined(_DEBUG) || defined(DEBUG)
+    #if defined(SECUREC_ERROR_HANDLER_BY_ASSERT)
+        #define SECUREC_ERROR_INVALID_PARAMTER(msg) assert( msg "invalid argument" == NULL)
+        #define SECUREC_ERROR_INVALID_RANGE(msg)    assert( msg "invalid dest buffer size" == NULL)
+    #elif defined(SECUREC_ERROR_HANDLER_BY_PRINTF)
+        #if SECUREC_IN_KERNEL
+            #define SECUREC_ERROR_INVALID_PARAMTER(msg) printk( "%s invalid argument\n",msg)
+            #define SECUREC_ERROR_INVALID_RANGE(msg)    printk( "%s invalid dest buffer size\n", msg)
+        #else
+            #define SECUREC_ERROR_INVALID_PARAMTER(msg) printf( "%s invalid argument\n",msg)
+            #define SECUREC_ERROR_INVALID_RANGE(msg)    printf( "%s invalid dest buffer size\n", msg)
+        #endif
+    #elif defined(SECUREC_ERROR_HANDLER_BY_FILE_LOG)
+        #define SECUREC_ERROR_INVALID_PARAMTER(msg) LogSecureCRuntimeError(msg " EINVAL\n")
+        #define SECUREC_ERROR_INVALID_RANGE(msg)    LogSecureCRuntimeError(msg " ERANGE\n")
+    #else
+        #define SECUREC_ERROR_INVALID_PARAMTER(msg) ((void)0)
+        #define SECUREC_ERROR_INVALID_RANGE(msg)    ((void)0)
+    #endif
+
+#else
+    #define SECUREC_ERROR_INVALID_PARAMTER(msg) ((void)0)
+    #define SECUREC_ERROR_INVALID_RANGE(msg)    ((void)0)
+    #define SECUREC_ERROR_BUFFER_OVERLAP(msg)   ((void)0)
+#endif
+
+#define SECUREC_PRINTF_TRUNCATE (-2)
+typedef struct {
+    int count;
+    char *cur;
+} SecPrintfStream;
+
+#ifdef SECUREC_STACK_SIZE_LESS_THAN_1K
+/* SECUREC_BUFFER_SIZE Can not be less than 23 ,
+ *the length of the octal representation of 64-bit integers with zero lead
+ */
+#define SECUREC_BUFFER_SIZE    256
+#else
+#define SECUREC_BUFFER_SIZE    512
+#endif
+#define SECUREC_MAX_PRECISION  SECUREC_BUFFER_SIZE
+/* max. # bytes in multibyte char  ,see MB_LEN_MAX */
+#define SECUREC_MB_LEN 16
+
+#if (defined(_MSC_VER)) && (_MSC_VER >= 1400)
+#define SECUREC_MASK_MSVC_CRT_WARNING __pragma(warning(push)) \
+    __pragma(warning(disable:4996 4127))
+#define SECUREC_END_MASK_MSVC_CRT_WARNING  __pragma(warning(pop))
+#else
+#define SECUREC_MASK_MSVC_CRT_WARNING
+#define SECUREC_END_MASK_MSVC_CRT_WARNING
+#endif
+
+#define SECUREC_WHILE_ZERO SECUREC_MASK_MSVC_CRT_WARNING while (0) SECUREC_END_MASK_MSVC_CRT_WARNING
+
+/* flag definitions */
+/* Using macros instead of enumerations is because some of the enumerated types under the compiler are 16bit. */
+#define SECUREC_FLAG_SIGN           0x00001U
+#define SECUREC_FLAG_SIGN_SPACE     0x00002U
+#define SECUREC_FLAG_LEFT           0x00004U
+#define SECUREC_FLAG_LEADZERO       0x00008U
+#define SECUREC_FLAG_LONG           0x00010U
+#define SECUREC_FLAG_SHORT          0x00020U
+#define SECUREC_FLAG_SIGNED         0x00040U
+#define SECUREC_FLAG_ALTERNATE      0x00080U
+#define SECUREC_FLAG_NEGATIVE       0x00100U
+#define SECUREC_FLAG_FORCE_OCTAL    0x00200U
+#define SECUREC_FLAG_LONG_DOUBLE    0x00400U
+#define SECUREC_FLAG_WIDECHAR       0x00800U
+#define SECUREC_FLAG_LONGLONG       0x01000U
+#define SECUREC_FLAG_CHAR           0x02000U
+#define SECUREC_FLAG_POINTER        0x04000U
+#define SECUREC_FLAG_I64            0x08000U
+#define SECUREC_FLAG_PTRDIFF        0x10000U
+#define SECUREC_FLAG_SIZE           0x20000U
+#ifdef  SECUREC_COMPATIBLE_LINUX_FORMAT
+#define SECUREC_FLAG_INTMAX         0x40000U
+#endif
+
+/* put a char to output */
+#define SECUREC_PUTC(_c,_stream)    ((--(_stream)->count >= 0) ? ((*(_stream)->cur++ = (char)(_c)) & 0xff) : EOF)
+/* to clear e835 */
+#define SECUREC_PUTC_ZERO(_stream)    ((--(_stream)->count >= 0) ? ((*(_stream)->cur++ = (char)('\0'))) : EOF)
+
+/* state definitions */
+typedef enum {
+    STAT_NORMAL,
+    STAT_PERCENT,
+    STAT_FLAG,
+    STAT_WIDTH,
+    STAT_DOT,
+    STAT_PRECIS,
+    STAT_SIZE,
+    STAT_TYPE,
+    STAT_INVALID
+} SecFmtState;
+
+#ifndef HILOG_PROHIBIT_ALLOCATION
+#ifndef SECUREC_MALLOC
+#define SECUREC_MALLOC(x) __libc_malloc((size_t)(x))
+#endif
+
+#ifndef SECUREC_FREE
+#define SECUREC_FREE(x)   __libc_free((void *)(x))
+#endif
+
+#else
+#define SECUREC_MALLOC(x) (NULL)
+#define SECUREC_FREE(x) {}
+#endif
+
+#if (defined(_WIN32) || defined(_WIN64) || defined(_MSC_VER)) || defined(__ARMCC_VERSION)
+typedef __int64 SecInt64;
+typedef unsigned __int64 SecUnsignedInt64;
+#if defined(__ARMCC_VERSION)
+typedef int SecInt32;
+typedef unsigned int SecUnsignedInt32;
+#else
+typedef __int32 SecInt32;
+typedef unsigned __int32 SecUnsignedInt32;
+#endif
+#else
+typedef int SecInt32;
+typedef unsigned int SecUnsignedInt32;
+typedef long long SecInt64;
+typedef unsigned long long SecUnsignedInt64;
+#endif
+
+static inline void SecWriteString(const char *string, int len, SecPrintfStream *f, int *pnumwritten)
+{
+    const char *str = string;
+    int count = len;
+    while (count-- > 0) {
+        if (SECUREC_PUTC(*str, f) == EOF) {
+            *pnumwritten = -1;
+            break;
+        } else {
+            ++(*pnumwritten);
+            ++str;
+        }
+    }
+}
+
+static inline void SecWriteMultiChar(char ch, int num, SecPrintfStream *f, int *pnumwritten)
+{
+    int count = num;
+    while (count-- > 0) {
+        if (SECUREC_PUTC(ch, f) == EOF) {
+            *pnumwritten = -1;
+            break;
+        } else {
+            ++(*pnumwritten);
+        }
+    }
+}
+
+static inline int SecVsnprintfPImpl(char *string, size_t count, int priv, const char *format, va_list arglist);
+
+/*******************************************************************************
+ * <FUNCTION DESCRIPTION>
+ *    The vsnprintf_s function is equivalent to the vsnprintf function
+ *     except for the parameter destMax/count and the explicit runtime-constraints violation
+ *    The vsnprintf_s function takes a pointer to an argument list, then formats
+ *    and writes up to count characters of the given data to the memory pointed
+ *    to by strDest and appends a terminating null.
+ *
+ * <INPUT PARAMETERS>
+ *    strDest                  Storage location for the output.
+ *    destMax                The size of the strDest for output.
+ *    count                    Maximum number of character to write(not including
+ *                                the terminating NULL)
+ *    priv_on               whether print <private> for not-public args
+ *    format                   Format-control string.
+ *    arglist                     pointer to list of arguments.
+ *
+ * <OUTPUT PARAMETERS>
+ *    strDest                is updated
+ *
+ * <RETURN VALUE>
+ *    return  the number of characters written, not including the terminating null
+ *    return -1 if an  error occurs.
+ *    return -1 if count < destMax and the output string  has been truncated
+ *
+ * If there is a runtime-constraint violation, strDest[0] will be set to the '\0' when strDest and destMax valid
+ *******************************************************************************
+ */
+ HILOG_LOCAL_API
+int vsnprintfp_s(char *strDest, size_t destMax, size_t count, int priv,  const char *format, va_list arglist)
+{
+    int retVal;
+
+    if (format == NULL || strDest == NULL || destMax == 0 || destMax > SECUREC_STRING_MAX_LEN ||
+        (count > (SECUREC_STRING_MAX_LEN - 1) && count != (size_t)-1)) {
+        if (strDest != NULL && destMax > 0) {
+            strDest[0] = '\0';
+        }
+        SECUREC_ERROR_INVALID_PARAMTER("vsnprintfp_s");
+        return -1;
+    }
+
+    if (destMax > count) {
+        retVal = SecVsnprintfPImpl(strDest, count + 1, priv, format, arglist);
+        if (retVal == SECUREC_PRINTF_TRUNCATE) {  /* lsd add to keep dest buffer not destroyed 2014.2.18 */
+            /* the string has been truncated, return  -1 */
+            return -1;          /* to skip error handler,  return strlen(strDest) or -1 */
+        }
+    } else {                    /* destMax <= count */
+        retVal = SecVsnprintfPImpl(strDest, destMax, priv, format, arglist);
+#ifdef SECUREC_COMPATIBLE_WIN_FORMAT
+        if (retVal == SECUREC_PRINTF_TRUNCATE && count == (size_t)-1) {
+            return -1;
+        }
+#endif
+    }
+
+    if (retVal < 0) {
+        strDest[0] = '\0';      /* empty the dest strDest */
+
+        if (retVal == SECUREC_PRINTF_TRUNCATE) {
+            /* Buffer too small */
+            SECUREC_ERROR_INVALID_RANGE("vsnprintfp_s");
+        }
+
+        SECUREC_ERROR_INVALID_PARAMTER("vsnprintfp_s");
+        return -1;
+    }
+
+    return retVal;
+}
+
+#ifdef SECUREC_FOR_WCHAR
+#undef SECUREC_FOR_WCHAR
+#endif
+
+typedef char SecChar;
+#define SECUREC_CHAR(x) x
+
+#define SECUREC_WRITE_MULTI_CHAR  SecWriteMultiChar
+#define SECUREC_WRITE_STRING      SecWriteString
+#include "output_p.inl"
+
+static inline int SecVsnprintfPImpl(char *string, size_t count, int priv, const char *format, va_list arglist)
+{
+    SecPrintfStream str;
+    int retVal;
+
+    str.count = (int)count;     /* this count include \0 character */
+    str.cur = string;
+
+    retVal = SecOutputPS(&str, priv, format, arglist);
+    if ((retVal >= 0) && (SECUREC_PUTC_ZERO(&str) != EOF)) {
+        return (retVal);
+    } else if (str.count < 0) {
+        /* the buffer was too small; we return truncation */
+        string[count - 1] = 0;
+        return SECUREC_PRINTF_TRUNCATE;
+    }
+
+    return -1;
+}
diff --git a/src/hilog/vsnprintf_s_p.h b/src/hilog/vsnprintf_s_p.h
new file mode 100644
index 00000000..77eec4bc
--- /dev/null
+++ b/src/hilog/vsnprintf_s_p.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __VSNPRINTFP_S_H__
+#define __VSNPRINTFP_S_H__
+
+#include "hilog_common.h"
+
+#include <stddef.h>
+#include <stdarg.h>
+/**
+* @Description: The vsnprintfp_s function is equivalent to the vsnprintf function except for the parameter destMax/count
+*               and the explicit runtime-constraints violation
+* @param strDest -  produce output according to a format ,write to the character string strDest
+* @param destMax - The maximum length of destination buffer(including the terminating null  byte ('\0'))
+* @param count - do not write more than count bytes to strDest(not including the terminating null  byte ('\0'))
+* @param priv_on - if true, any not %{public} prefix formatter arguments will be printed as "<private>"
+* @param format - format string
+* @param arglist - instead of  a variable  number of arguments
+* @return:return the number of characters printed(not including the terminating null byte ('\0')),
+*         If an error occurred return -1.Pay special attention to returning -1 when truncation occurs
+*/
+HILOG_LOCAL_API
+int vsnprintfp_s(char *strDest, size_t destMax, size_t count, int priv, const char *format, va_list arglist);
+
+#endif /* __VSNPRINTFP_S_H__ */
diff --git a/src/hook/common_def.h b/src/hook/common_def.h
new file mode 100644
index 00000000..7d74b3da
--- /dev/null
+++ b/src/hook/common_def.h
@@ -0,0 +1,10 @@
+#ifndef _COMMON_DEF_H
+#define _COMMON_DEF_H
+
+#include <unistd.h>
+#include <stdlib.h>
+
+#define	__predict_true(exp) __builtin_expect((exp) != 0, 1)
+#define	__predict_false(exp) __builtin_expect((exp) != 0, 0)
+
+#endif
\ No newline at end of file
diff --git a/src/hook/malloc_common.c b/src/hook/malloc_common.c
new file mode 100644
index 00000000..617f506d
--- /dev/null
+++ b/src/hook/malloc_common.c
@@ -0,0 +1,118 @@
+#ifdef HOOK_ENABLE
+#include <unistd.h>
+#include <sys/types.h>
+#include "musl_malloc.h"
+#include <malloc.h>
+#include "musl_malloc_dispatch_table.h"
+#include "common_def.h"
+#include "musl_preinit_common.h"
+
+void* malloc(size_t bytes)
+{
+	volatile const struct MallocDispatchType* dispatch_table = (struct MallocDispatchType *)atomic_load_explicit(
+		&__musl_libc_globals.current_dispatch_table, memory_order_acquire);
+	if (__predict_false(dispatch_table != NULL)) {
+		if (__get_memleak_hook_flag()) {
+			return dispatch_table->malloc(bytes);
+		}
+		if (!__get_global_hook_flag()) {
+			return MuslFunc(malloc)(bytes);
+		}
+		else if (!__get_hook_flag()) {
+			return MuslFunc(malloc)(bytes);
+		}
+		return dispatch_table->malloc(bytes);
+	}
+	return  MuslFunc(malloc)(bytes);
+}
+
+void free(void* mem)
+{
+	volatile const struct MallocDispatchType* dispatch_table = (struct MallocDispatchType *)atomic_load_explicit(
+		&__musl_libc_globals.current_dispatch_table, memory_order_acquire);
+	if (__predict_false(dispatch_table != NULL)) {
+		if (__get_memleak_hook_flag()) {
+			dispatch_table->free(mem);
+			return;
+		}
+		if (!__get_global_hook_flag()) {
+			MuslFunc(free)(mem);
+			return;
+		}
+		else if (!__get_hook_flag()) {
+			MuslFunc(free)(mem);
+			return;
+		}
+		dispatch_table->free(mem);
+		return;
+	}
+	MuslFunc(free)(mem);
+}
+
+void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset)
+{
+	volatile const struct MallocDispatchType* dispatch_table = get_current_dispatch_table();
+	if (__predict_false(dispatch_table != NULL)) {
+		return dispatch_table->mmap(addr, length, prot, flags, fd, offset);
+	} else {
+		return MuslMalloc(mmap)(addr, length, prot, flags, fd, offset);
+	}
+}
+
+int munmap(void* addr, size_t length)
+{
+	volatile const struct MallocDispatchType* dispatch_table = get_current_dispatch_table();
+	if (__predict_false(dispatch_table != NULL)) {
+		return dispatch_table->munmap(addr, length);
+	} else {
+		return MuslMalloc(munmap)(addr, length);
+	}
+}
+
+void* calloc(size_t m, size_t n)
+{
+	volatile const struct MallocDispatchType* dispatch_table = get_current_dispatch_table();
+	if (__predict_false(dispatch_table != NULL)) {
+		return dispatch_table->calloc(m, n);
+	} else {
+		return MuslFunc(calloc)(m, n);
+	}
+}
+
+void* realloc(void *p, size_t n)
+{
+	volatile const struct MallocDispatchType* dispatch_table = get_current_dispatch_table();
+	if (__predict_false(dispatch_table != NULL)) {
+		return dispatch_table->realloc(p, n);
+	} else {
+		return MuslFunc(realloc)(p, n);
+	}
+}
+
+size_t malloc_usable_size(void* addr)
+{
+	volatile const struct MallocDispatchType* dispatch_table = get_current_dispatch_table();
+	if (__predict_false(dispatch_table != NULL)) {
+		return dispatch_table->malloc_usable_size(addr);
+	} else {
+		return MuslMalloc(malloc_usable_size)(addr);
+	}
+}
+
+int prctl(int option, ...)
+{
+	unsigned long x[4];
+	int i;
+	va_list ap;
+	va_start(ap, option);
+	for (i=0; i<4; i++) x[i] = va_arg(ap, unsigned long);
+	va_end(ap);
+	volatile const struct MallocDispatchType* dispatch_table = get_current_dispatch_table();
+	if (__predict_false(dispatch_table != NULL)) {
+		return dispatch_table->prctl(option, x[0], x[1], x[2], x[3]);
+	} else {
+		return MuslMalloc(prctl)(option, x[0], x[1], x[2], x[3]);
+	}
+}
+
+#endif
diff --git a/src/hook/memory_trace.c b/src/hook/memory_trace.c
new file mode 100644
index 00000000..e72858ba
--- /dev/null
+++ b/src/hook/memory_trace.c
@@ -0,0 +1,26 @@
+#include "memory_trace.h"
+#ifdef HOOK_ENABLE
+#include "common_def.h"
+#include "musl_preinit_common.h"
+#endif
+
+void memtrace(void* addr, size_t size, const char* tag, bool is_using)
+{
+#ifdef HOOK_ENABLE
+	volatile const struct MallocDispatchType* dispatch_table = (struct MallocDispatchType *)atomic_load_explicit(
+		&__musl_libc_globals.current_dispatch_table, memory_order_acquire);
+	if (__predict_false(dispatch_table != NULL)) {
+		if (__get_memleak_hook_flag()) {
+			return;
+		}
+		if (!__get_global_hook_flag()) {
+			return;
+		}
+		else if (!__get_hook_flag()) {
+			return;
+		}
+		return dispatch_table->memtrace(addr, size, tag, is_using);
+	}
+#endif
+    return;
+}
diff --git a/src/hook/memory_trace.h b/src/hook/memory_trace.h
new file mode 100644
index 00000000..152d2c0f
--- /dev/null
+++ b/src/hook/memory_trace.h
@@ -0,0 +1,14 @@
+#ifndef _MEMORY_TRACE_H
+#define _MEMORY_TRACE_H
+
+#include <stdbool.h>
+#include <unistd.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+void memtrace(void* addr, size_t size, const char* tag, bool is_using);
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/src/hook/musl_malloc.h b/src/hook/musl_malloc.h
new file mode 100644
index 00000000..f3b86f4e
--- /dev/null
+++ b/src/hook/musl_malloc.h
@@ -0,0 +1,58 @@
+#ifndef _MUSL_MALLOC_H
+#define _MUSL_MALLOC_H
+
+#include "malloc.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef HOOK_ENABLE
+#define MuslMalloc(func) __libc_ ## func
+#else
+#define MuslMalloc(func) func
+#endif
+
+#ifdef USE_JEMALLOC
+extern void* je_malloc(size_t size);
+extern void* je_calloc(size_t count, size_t size);
+extern void* je_realloc(void* p, size_t newsize);
+extern void je_free(void* p);
+#define MuslFunc(func) je_ ## func
+#else
+extern void *__libc_malloc(size_t size);
+extern void __libc_free(void* p);
+extern void *hook_calloc(size_t, size_t);
+#define hook_malloc __libc_malloc 
+#define hook_free __libc_free 
+#define hook_realloc __libc_realloc 
+#define MuslFunc(func) hook_ ## func
+#endif
+
+void *__libc_mmap(void*, size_t, int, int, int, off_t);
+int __libc_munmap(void*, size_t);
+void *__libc_calloc(size_t, size_t);
+void *__libc_realloc(void *, size_t);
+void *__libc_valloc(size_t);
+void *__libc_memalign(size_t, size_t);
+size_t __libc_malloc_usable_size(void *);
+int __libc_prctl(int, ...);
+
+struct mallinfo2 __libc_mallinfo2(void);
+
+int __libc_malloc_iterate(void* base, size_t size, void (*callback)(void* base, size_t size, void* arg), void* arg);
+void __libc_malloc_disable(void);
+void __libc_malloc_enable(void);
+
+int __libc_malloc_info(int options, FILE* fp);
+void __libc_malloc_stats_print(void (*write_cb) (void *, const char *), void *cbopaque, const char *opts);
+
+int __libc_mallopt(int param, int value);
+ssize_t __libc_malloc_backtrace(void* pointer, uintptr_t* frames, size_t frame_count);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/hook/musl_malloc_dispatch.h b/src/hook/musl_malloc_dispatch.h
new file mode 100644
index 00000000..9ca98d6c
--- /dev/null
+++ b/src/hook/musl_malloc_dispatch.h
@@ -0,0 +1,65 @@
+#ifndef _MUSL_MALLOC_DISPATCH_H
+#define _MUSL_MALLOC_DISPATCH_H
+
+#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+typedef void* (*MallocMmapType) (void*, size_t, int, int, int, off_t);
+typedef int (*MallocMunmapType) (void*, size_t);
+typedef void* (*MallocMallocType)(size_t);
+typedef void* (*MallocReallocType)(void*, size_t);
+typedef void* (*MallocCallocType)(size_t, size_t);
+typedef void* (*MallocVallocType)(size_t);
+typedef void (*MallocFreeType)(void*);
+typedef void* (*MallocMemalignType)(size_t, size_t);
+typedef size_t (*MallocMallocUsableSizeType)(void*);
+typedef int (*MallocPrctlType)(int, ...);
+
+typedef struct mallinfo (*MallinfoType)(void);
+typedef struct mallinfo2 (*Mallinfo2Type)(void);
+typedef int (*MallocIterateType)(void*, size_t, void (*callback)(void*, size_t, void*), void*);
+typedef void (*MallocDisableType)(void);
+typedef void (*MallocEnableType)(void);
+typedef int (*MallocInfoType)(int, FILE*);
+typedef void (*MallocStatsPrintType)(void (*) (void *, const char *), void *, const char *);
+typedef int (*MalloptType)(int, int);
+typedef ssize_t (*MallocBacktraceType)(void*, uintptr_t*, size_t);
+typedef void (*MemTrace)(void*, size_t, const char*, bool);
+
+typedef bool (*GetHookFlagType)();
+typedef bool (*SetHookFlagType)(bool);
+
+struct MallocDispatchType {
+	MallocMmapType mmap;
+	MallocMunmapType munmap;
+	MallocMallocType malloc;
+	MallocCallocType calloc;
+	MallocReallocType realloc;
+	MallocVallocType valloc;
+	MallocFreeType free;
+	MallocMemalignType memalign;
+	MallocMallocUsableSizeType malloc_usable_size;
+	MallinfoType mallinfo;
+	Mallinfo2Type mallinfo2;
+	MallocIterateType malloc_iterate;
+	MallocDisableType malloc_disable;
+	MallocEnableType malloc_enable;
+	MallocInfoType malloc_info;
+	MallocStatsPrintType malloc_stats_print;
+	MalloptType mallopt;
+	MallocBacktraceType malloc_backtrace;
+	GetHookFlagType get_hook_flag;
+	SetHookFlagType set_hook_flag;
+	MemTrace memtrace;
+	MallocPrctlType prctl;
+};
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/hook/musl_malloc_dispatch_table.h b/src/hook/musl_malloc_dispatch_table.h
new file mode 100644
index 00000000..f78ec03b
--- /dev/null
+++ b/src/hook/musl_malloc_dispatch_table.h
@@ -0,0 +1,15 @@
+#ifndef _MUSL_MALLOC_DISPATCH_TABLE_H
+#define _MUSL_MALLOC_DISPATCH_TABLE_H
+
+#include "musl_malloc_dispatch.h"
+#include <stdatomic.h>
+
+struct musl_libc_globals {
+	volatile atomic_llong current_dispatch_table;
+	volatile atomic_llong so_dispatch_table;
+	volatile atomic_llong memleak_tracker_so_dispatch_table;
+	struct MallocDispatchType malloc_dispatch_table;
+	struct MallocDispatchType memleak_tracker_malloc_dispatch_table;
+};
+
+#endif
diff --git a/src/hook/musl_preinit.c b/src/hook/musl_preinit.c
new file mode 100644
index 00000000..2c2f9a55
--- /dev/null
+++ b/src/hook/musl_preinit.c
@@ -0,0 +1,687 @@
+/*
+The hook mode has 3 kinds which can be set by command "param set":
+(1) param set libc.hook_mode "startup:\"prog1 \""
+(2) param set libc.hook_mode startup:program1
+(3) param set libc.hook_mode step
+(4) param set libc.hook_mode direct
+
+Case 1 represents "startup" mode, and the hooked process is "prog1 ",
+which loads hooking shared library when the program starts up.
+The path is added with two quotation marks because a quotation mark is a special charcter,
+which need be escaped.
+(2) is similar with (1), but no escaped character, so quotation marks doesn't need.
+(3) represents "step" mode, which loads hooking shared library by some steps.
+(4) represetnt  "direct" mode, which loads hooking shared library by a step.
+*/
+
+#ifdef HOOK_ENABLE
+#include <unistd.h>
+#include <signal.h>
+#include "musl_malloc_dispatch_table.h"
+#include "musl_malloc.h"
+#include "musl_preinit_common.h"
+#ifdef OHOS_ENABLE_PARAMETER
+#include "sys_param.h"
+#endif
+#include <pthread.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <dlfcn.h>
+#include <errno.h>
+#include <stdatomic.h>
+#include <ctype.h>
+#include <assert.h>
+#include <string.h>
+#include <malloc.h>
+#include "musl_log.h"
+
+void* ohos_malloc_hook_init_function(size_t bytes);
+void default_memtrace(void* addr, size_t size, const char* tag, bool is_using) {}
+
+static struct MallocDispatchType __ohos_malloc_hook_init_dispatch = {
+	.malloc = ohos_malloc_hook_init_function,
+	.free = MuslFunc(free),
+	.mmap = MuslMalloc(mmap),
+	.munmap = MuslMalloc(munmap),
+	.calloc = MuslFunc(calloc),
+	.realloc = MuslFunc(realloc),
+	.prctl = MuslMalloc(prctl),
+	.malloc_usable_size = MuslMalloc(malloc_usable_size),
+	.memtrace = default_memtrace,
+};
+#define MAX_SYM_NAME_SIZE 1000
+#define MAX_PROC_NAME_SIZE 256
+#define ADDR_NATIVE_ENABLE (1<<4)
+#define ADDR_NATIVE_DISABLE (1<<5)
+#define ADDR_NATIVE_SAVE (1<<6)
+#define ADDR_NATIVE_CLEAR (1<<7)
+static char *__malloc_hook_shared_lib = "libnative_hook.z.so";
+static char *__malloc_hook_function_prefix = "ohos_malloc_hook";
+volatile atomic_llong ohos_malloc_hook_shared_library;
+static char *kMemTrackSharedLib = "libmemleak_tracker.so";
+static char *kMemTrackPrefix = "track";
+static char *kMemTrackPropertyEnable = "const.hiview.memleak_tracker.enable";
+static char *kMemTrackSign = "true";
+bool checkLoadMallocMemTrack = false;
+unsigned int memLeakTypeContent = 0;
+volatile atomic_llong memleak_ever_shared_library_handle;
+volatile atomic_llong ohos_malloc_ever_shared_library_handle;
+void* function_of_shared_lib[LAST_FUNCTION];
+void* function_of_ohos_malloc_shared_lib[LAST_FUNCTION];
+void* function_of_memleak_shared_lib[LAST_FUNCTION];
+static enum EnumHookMode __hook_mode = STEP_HOOK_MODE;
+
+static void get_native_hook_param(char *buf, unsigned int buf_len)
+{
+#ifdef OHOS_ENABLE_PARAMETER
+	CachedHandle handle = CachedParameterCreate(MUSL_HOOK_PARAM_NAME,  "");
+	const char *value = CachedParameterGet(handle);
+	if (value != NULL) {
+		size_t size = strlen(value);
+		if (size > 0 && size < buf_len) {
+			strcpy(buf, value);
+		}
+	}
+	CachedParameterDestroy(handle);
+#else
+	return;
+#endif
+}
+
+static void get_memleak_hook_param()
+{
+#ifdef OHOS_ENABLE_PARAMETER
+	CachedHandle handle = CachedParameterCreate(kMemTrackPropertyEnable,  "false");
+	const char *value = CachedParameterGet(handle);
+	if (value != NULL && strncmp(value, kMemTrackSign, strlen(kMemTrackSign)) == 0) {
+		checkLoadMallocMemTrack = true;
+	}
+	CachedParameterDestroy(handle);
+#else
+	return;
+#endif
+}
+
+static int parse_hook_variable(enum EnumHookMode* mode, char* path, int size)
+{
+	if (!mode || !path || size <= 0) {
+		return -1;
+	}
+	char hook_param_value[OHOS_PARAM_MAX_SIZE + 1] = {0};
+	unsigned int len = OHOS_PARAM_MAX_SIZE;
+	get_native_hook_param(hook_param_value, len);
+	if (hook_param_value[0] == '\0') {
+		*mode = STEP_HOOK_MODE;
+		path[0] = '\0';
+	} else {
+		char* ptr = hook_param_value;
+		while (*ptr && *ptr != ':') {
+			++ptr;
+		}
+
+		if (*ptr == ':') {
+			*ptr = '\0';
+			++ptr;
+		}
+
+		if (strcmp(hook_param_value, "startup") == 0) {
+			*mode = STARTUP_HOOK_MODE;
+		} else if (strcmp(hook_param_value, "direct") == 0) {
+			*mode = DIRECT_HOOK_MODE;
+		} else if (strcmp(hook_param_value, "step") == 0) {
+			*mode = STEP_HOOK_MODE;
+		} else {
+			*mode = STEP_HOOK_MODE;
+		}
+		if (*mode == STARTUP_HOOK_MODE) {
+			if (*ptr == '\"') {
+				++ptr;
+				int idx = 0;
+				while (idx < size - 1 && *ptr && *ptr != '\"') {
+					path[idx++] = *ptr++;
+				}
+				path[idx] = '\0';
+			} else {
+				int idx = 0;
+				while (idx < size - 1 && *ptr) {
+					path[idx++] = *ptr++;
+				}
+				path[idx] = '\0';
+			}
+		}
+	}
+	return 0;
+}
+
+static bool get_proc_name(pid_t pid, char *buf, unsigned int buf_len)
+{
+	if (pid <= 0) {
+		return false;
+	}
+	char target_file[FILE_NAME_MAX_SIZE] = {0};
+	(void)snprintf(target_file, sizeof(target_file), "/proc/%d/cmdline", pid);
+	FILE *f = fopen(target_file, "r");
+	if (f == NULL) {
+		return false;
+	}
+	if (fgets(buf, buf_len, f) == NULL) {
+		(void)fclose(f);
+		return false;
+	}
+	(void)fclose(f);
+	return true;
+}
+
+static bool init_malloc_function(void* malloc_shared_library_handler, MallocMallocType* func, const char* prefix)
+{
+	char symbol[MAX_SYM_NAME_SIZE];
+	snprintf(symbol, sizeof(symbol), "%s_%s", prefix, "malloc");
+	*func = (MallocMallocType)(dlsym(malloc_shared_library_handler, symbol));
+	if (*func == NULL) {
+		return false;
+	}
+	return true;
+}
+
+static bool init_free_function(void* malloc_shared_library_handler, MallocFreeType* func, const char* prefix)
+{
+	char symbol[MAX_SYM_NAME_SIZE];
+	snprintf(symbol, sizeof(symbol), "%s_%s", prefix, "free");
+	*func = (MallocFreeType)(dlsym(malloc_shared_library_handler, symbol));
+	if (*func == NULL) {
+		return false;
+	}
+	return true;
+}
+
+static bool init_mmap_function(void* malloc_shared_library_handler, MallocMmapType* func, const char* prefix)
+{
+	char symbol[MAX_SYM_NAME_SIZE];
+	snprintf(symbol, sizeof(symbol), "%s_%s", prefix, "mmap");
+	*func = (MallocMmapType)(dlsym(malloc_shared_library_handler, symbol));
+	if (*func == NULL) {
+		return false;
+	}
+	return true;
+}
+
+static bool init_munmap_function(void* malloc_shared_library_handler, MallocMunmapType* func, const char* prefix)
+{
+	char symbol[MAX_SYM_NAME_SIZE];
+	snprintf(symbol, sizeof(symbol), "%s_%s", prefix, "munmap");
+	*func = (MallocMunmapType)(dlsym(malloc_shared_library_handler, symbol));
+	if (*func == NULL) {
+		return false;
+	}
+	return true;
+}
+
+static bool init_memtrace_function(void* malloc_shared_library_handler, MemTrace* func, const char* prefix)
+{
+	char symbol[MAX_SYM_NAME_SIZE];
+	snprintf(symbol, sizeof(symbol), "%s_%s", prefix, "memtrace");
+	*func = (MemTrace)(dlsym(malloc_shared_library_handler, symbol));
+	if (*func == NULL) {
+		return false;
+	}
+	return true;
+}
+
+static bool init_calloc_function(void* malloc_shared_library_handler, MallocCallocType* func, const char* prefix)
+{
+	char symbol[MAX_SYM_NAME_SIZE];
+	snprintf(symbol, sizeof(symbol), "%s_%s", prefix, "calloc");
+	*func = (MallocCallocType)(dlsym(malloc_shared_library_handler, symbol));
+	if (*func == NULL) {
+		return false;
+	}
+	return true;
+}
+
+static bool init_realloc_function(void* malloc_shared_library_handler, MallocReallocType* func, const char* prefix)
+{
+	char symbol[MAX_SYM_NAME_SIZE];
+	snprintf(symbol, sizeof(symbol), "%s_%s", prefix, "realloc");
+	*func = (MallocReallocType)(dlsym(malloc_shared_library_handler, symbol));
+	if (*func == NULL) {
+		return false;
+	}
+	return true;
+}
+
+static bool init_malloc_usable_size_function(void* malloc_shared_library_handler, MallocMallocUsableSizeType* func, const char* prefix)
+{
+	char symbol[MAX_SYM_NAME_SIZE];
+	snprintf(symbol, sizeof(symbol), "%s_%s", prefix, "malloc_usable_size");
+	*func = (MallocMallocUsableSizeType)(dlsym(malloc_shared_library_handler, symbol));
+	if (*func == NULL) {
+		return false;
+	}
+	return true;
+}
+
+static bool init_prctl_function(void* malloc_shared_library_handler, MallocPrctlType* func, const char* prefix)
+{
+	char symbol[MAX_SYM_NAME_SIZE];
+	snprintf(symbol, sizeof(symbol), "%s_%s", prefix, "prctl");
+	*func = (MallocPrctlType)(dlsym(malloc_shared_library_handler, symbol));
+	if (*func == NULL) {
+		return false;
+	}
+	return true;
+}
+
+#ifdef USE_JEMALLOC_RECYCLE_FUNC
+extern int je_reclaim_cache();
+static void handle_recycle_cache()
+{
+	int ret;
+	ret = je_reclaim_cache();
+	MUSL_LOGD("je_reclaim_cache result=%{public}d", ret);
+}
+
+static void init_jemalloc_recycle_handler()
+{
+	struct sigaction action = {};
+	action.sa_handler = NULL;
+	action.sa_sigaction = handle_recycle_cache;
+	sigemptyset(&action.sa_mask);
+	sigaddset(&action.sa_mask, MUSL_SIGNAL_RECYCLE_JEMALLOC);
+	action.sa_flags = SA_SIGINFO | SA_RESTART;
+	action.sa_restorer = NULL;
+	sigaction(MUSL_SIGNAL_RECYCLE_JEMALLOC, &action, NULL);
+}
+#endif
+
+static bool init_hook_functions(void* shared_library_handler, struct MallocDispatchType* table, const char* prefix)
+{
+	if (!init_malloc_function(shared_library_handler, &table->malloc, prefix)) {
+		return false;
+	}
+	if (!init_free_function(shared_library_handler, &table->free, prefix)) {
+		return false;
+	}
+	if (!init_mmap_function(shared_library_handler, &table->mmap, prefix)) {
+		return false;
+	}
+	if (!init_munmap_function(shared_library_handler, &table->munmap, prefix)) {
+		return false;
+	}
+	if (!init_calloc_function(shared_library_handler, &table->calloc, prefix)) {
+		return false;
+	}
+	if (!init_realloc_function(shared_library_handler, &table->realloc, prefix)) {
+		return false;
+	}
+	if (!init_memtrace_function(shared_library_handler, &table->memtrace, prefix)) {
+		return false;
+	}
+	if (!init_malloc_usable_size_function(shared_library_handler, &table->malloc_usable_size, prefix)) {
+		return false;
+	}
+	if (!init_prctl_function(shared_library_handler, &table->prctl, prefix)) {
+		return false;
+	}
+	return true;
+}
+
+static void clear_function_table()
+{
+	for (size_t i = 0; i < LAST_FUNCTION; i++) {
+		function_of_shared_lib[i] = NULL;
+		if (__get_memleak_hook_flag()) {
+			function_of_memleak_shared_lib[i] = NULL;
+		} else if (__get_global_hook_flag()) {
+			function_of_ohos_malloc_shared_lib[i] = NULL;
+		}
+	}
+}
+
+bool init_malloc_hook_shared_library(void* shared_library_handle, const char* shared_lib, const char* prefix, struct MallocDispatchType* dispatch_table)
+{
+	static const char* names[] = {
+		"initialize",
+		"finalize",
+		"get_hook_flag",
+		"set_hook_flag",
+		"on_start",
+		"on_end",
+	};
+
+	for (int i = 0; i < LAST_FUNCTION; i++) {
+		char symbol[MAX_SYM_NAME_SIZE];
+		snprintf(symbol, sizeof(symbol), "%s_%s", prefix, names[i]);
+		function_of_shared_lib[i] = dlsym(shared_library_handle, symbol);
+		if (__get_memleak_hook_flag()) {
+			function_of_memleak_shared_lib[i] = function_of_shared_lib[i];
+		} else if (__get_global_hook_flag()) {
+			function_of_ohos_malloc_shared_lib[i] = function_of_shared_lib[i];
+		}
+		if (function_of_shared_lib[i] == NULL) {
+			// __musl_log(__MUSL_LOG_ERROR, "%s: %s routine not found in %s\n", getprogname(), symbol, shared_lib);
+			clear_function_table();
+			return false;
+		}
+	}
+
+	if (!init_hook_functions(shared_library_handle, dispatch_table, prefix)) {
+		clear_function_table();
+		return false;
+	}
+
+	return true;
+}
+
+void* load_malloc_hook_shared_library(const char* shared_lib, const char* prefix, struct MallocDispatchType* dispatch_table)
+{
+	void* shared_library_handle = NULL;
+
+	shared_library_handle = dlopen(shared_lib, RTLD_NOW | RTLD_LOCAL);
+
+	if (shared_library_handle == NULL) {
+		MUSL_LOGI("HiProfiler, Unable to open shared library %{public}s: %{public}s.", shared_lib, dlerror());
+		return NULL;
+	}
+
+	if (!init_malloc_hook_shared_library(shared_library_handle, shared_lib, prefix, dispatch_table)) {
+		dlclose(shared_library_handle);
+		shared_library_handle = NULL;
+	}
+	MUSL_LOGI("HiProfiler, load_malloc_hook_shared_library success.");
+	return shared_library_handle;
+}
+
+typedef void (*finalize_func_t)();
+typedef bool (*init_func_t)(const struct MallocDispatchType*, bool*, const char*);
+typedef bool (*on_start_func_t)();
+typedef bool (*on_end_func_t)();
+
+static void malloc_finalize()
+{
+	__set_hook_flag(false);
+	((finalize_func_t)function_of_shared_lib[FINALIZE_FUNCTION])();
+
+	fclose(stdin);
+	fclose(stdout);
+	fclose(stderr);
+}
+
+bool finish_install_ohos_malloc_hooks(struct musl_libc_globals* globals, const char* options, const char* prefix, void* shared_library_handle)
+{
+	init_func_t init_func = (init_func_t)(function_of_shared_lib[INITIALIZE_FUNCTION]);
+	if (!init_func(&__libc_malloc_default_dispatch, NULL, options)) {
+		// __musl_log(__MUSL_LOG_ERROR, "%s: failed to enable malloc %s\n", getprogname(), prefix);
+		clear_function_table();
+		return false;
+	}
+	on_start_func_t start_func = (on_start_func_t)(function_of_shared_lib[ON_START_FUNCTION]);
+	if (__get_global_hook_flag()) {
+		if (!start_func()) {
+			// __musl_log(__MUSL_LOG_ERROR, "%s: failed to start %s\n", getprogname(), prefix);
+			clear_function_table();
+			return false;
+		}
+		atomic_store_explicit(&ohos_malloc_hook_shared_library, (volatile long long)shared_library_handle, memory_order_seq_cst);
+		atomic_store_explicit(&__musl_libc_globals.so_dispatch_table, (volatile long long)&globals->malloc_dispatch_table, memory_order_seq_cst);
+		atomic_store_explicit(&__musl_libc_globals.current_dispatch_table, (volatile long long)&globals->malloc_dispatch_table, memory_order_seq_cst);
+	}
+	if (__get_memleak_hook_flag() && checkLoadMallocMemTrack) {
+		if (!start_func(memLeakTypeContent)) {
+			clear_function_table();
+			return false;
+		}
+		atomic_store_explicit(&__musl_libc_globals.memleak_tracker_so_dispatch_table, (volatile long long)&globals->memleak_tracker_malloc_dispatch_table, memory_order_seq_cst);
+		atomic_store_explicit(&__musl_libc_globals.current_dispatch_table, (volatile long long)&globals->memleak_tracker_malloc_dispatch_table, memory_order_seq_cst);
+	}
+	int ret_value = atexit(malloc_finalize);
+	if (ret_value != 0) {
+		// __musl_log(__MUSL_LOG_ERROR, "failed to set atexit cleanup function: %d\n", ret_value);
+	}
+	return true;
+}
+
+static bool is_empty_string(const char* str)
+{
+	while (*str) {
+		if (!isspace((unsigned char)(*str))) {
+			return false;
+		}
+	}
+	return true;
+}
+
+static void install_ohos_malloc_hook(struct musl_libc_globals* globals, const char* shared_lib, const char* prefix)
+{
+	volatile void* shared_library_handle = (volatile void *)atomic_load_explicit(&ohos_malloc_hook_shared_library, memory_order_acquire);
+	assert(shared_library_handle == NULL || shared_library_handle == (volatile void*)-1);
+	if (__get_memleak_hook_flag()) {
+		shared_library_handle = (volatile void*)load_malloc_hook_shared_library(shared_lib, prefix, &globals->memleak_tracker_malloc_dispatch_table);
+	} else if (__get_global_hook_flag()) {
+		shared_library_handle = (volatile void*)load_malloc_hook_shared_library(shared_lib, prefix, &globals->malloc_dispatch_table);
+	}
+	if (shared_library_handle == NULL) {
+		// __musl_log(__MUSL_LOG_ERROR, "Can't load shared library '%s'\n", __malloc_hook_shared_lib);
+		return;
+	}
+
+	if (finish_install_ohos_malloc_hooks(globals, NULL, prefix, shared_library_handle)) {
+		if (strncmp(__malloc_hook_function_prefix, prefix, strlen(prefix)) == 0) {
+			atomic_store_explicit(&ohos_malloc_ever_shared_library_handle, (volatile long long)shared_library_handle, memory_order_seq_cst);
+		} else {
+			atomic_store_explicit(&memleak_ever_shared_library_handle, (volatile long long)shared_library_handle, memory_order_seq_cst);
+		}
+	} else {
+		// __musl_log(__MUSL_LOG_ERROR, "finish_install_ohos_malloc_hooks failed\n");
+		dlclose((void *)shared_library_handle);
+		atomic_store_explicit(&ohos_malloc_hook_shared_library, (volatile long long)0, memory_order_seq_cst);
+	}
+}
+
+static void* init_ohos_malloc_hook()
+{
+	if (__get_memleak_hook_flag()) {
+		get_memleak_hook_param();
+		if (checkLoadMallocMemTrack) {
+			install_ohos_malloc_hook(&__musl_libc_globals, kMemTrackSharedLib, kMemTrackPrefix);
+		}
+	}
+	if (__get_global_hook_flag()) {
+		install_ohos_malloc_hook(&__musl_libc_globals, __malloc_hook_shared_lib, __malloc_hook_function_prefix);
+	}
+	return NULL;
+}
+
+void* ohos_malloc_hook_init_function(size_t bytes)
+{
+	if (atomic_exchange(&__musl_libc_globals.current_dispatch_table, (volatile const long long)NULL)) {
+		pthread_t thread_id;
+		MUSL_LOGI("HiProfiler, ohos_malloc_hook_init_function, pthread_create.");
+		if (pthread_create(&thread_id, NULL, init_ohos_malloc_hook, NULL) != 0) {
+			// __musl_log(__MUSL_LOG_ERROR, "%s: ohos_malloc_hook: failed to pthread_create\n", getprogname());
+		} else if (pthread_detach(thread_id) != 0) {
+			// __musl_log(__MUSL_LOG_ERROR, "%s: ohos_malloc_hook: failed to pthread_detach\n", getprogname());
+		}
+	}
+	void*ptr = MuslFunc(malloc)(bytes);
+	return ptr;
+
+}
+
+static void __set_default_malloc()
+{
+	atomic_store_explicit(&__musl_libc_globals.current_dispatch_table, (volatile const long long)NULL, memory_order_seq_cst);
+}
+
+static void __restore_hook_function_table()
+{
+	for (size_t i = 0; i < LAST_FUNCTION; i++) {
+		if (__get_memleak_hook_flag()) {
+			function_of_shared_lib[i] = function_of_memleak_shared_lib[i];
+		} else if (__get_global_hook_flag()) {
+			function_of_shared_lib[i] = function_of_ohos_malloc_shared_lib[i];
+		}
+	}
+}
+
+static void __install_malloc_hook()
+{
+	if (__get_memleak_hook_flag()) {
+		return;
+	}
+	atomic_store_explicit(&__hook_enable_hook_flag, (volatile bool)true, memory_order_seq_cst);
+	volatile void* ohos_malloc_ever_handle = (volatile void* )atomic_load_explicit(&ohos_malloc_ever_shared_library_handle, memory_order_acquire);
+	if (ohos_malloc_ever_handle != NULL) {
+		atomic_store_explicit(&ohos_malloc_hook_shared_library, (volatile long long)ohos_malloc_ever_handle, memory_order_seq_cst);
+	} else {
+		atomic_store_explicit(&ohos_malloc_hook_shared_library, (volatile long long)0, memory_order_seq_cst);
+	}
+	volatile void* shared_library_handle = (volatile void* )atomic_load_explicit(&ohos_malloc_hook_shared_library, memory_order_acquire);
+	if (shared_library_handle == NULL) {
+		MUSL_LOGI("HiProfiler, __install_malloc_hook __hook_mode %{public}d", __hook_mode);
+		if (__hook_mode == STEP_HOOK_MODE) {
+			atomic_store_explicit(&__musl_libc_globals.current_dispatch_table, (volatile const long long)&__ohos_malloc_hook_init_dispatch, memory_order_seq_cst);
+			atomic_store_explicit(&ohos_malloc_hook_shared_library, (volatile long long)-1, memory_order_seq_cst);
+		} else {
+			init_ohos_malloc_hook();
+		}
+	} else if (shared_library_handle != (void*)-1) {
+		__restore_hook_function_table();
+		volatile const struct MallocDispatchType* so_dispatch_value = (volatile const struct MallocDispatchType* )atomic_load_explicit(&__musl_libc_globals.so_dispatch_table, memory_order_acquire);
+		atomic_store_explicit(&__musl_libc_globals.current_dispatch_table, (volatile long long)so_dispatch_value, memory_order_seq_cst);
+		on_start_func_t start_func = (on_start_func_t)(function_of_shared_lib[ON_START_FUNCTION]);
+		if (start_func && !start_func()) {
+			// __musl_log(__MUSL_LOG_ERROR, "%s: failed to enable malloc\n", getprogname());
+		}
+
+	}
+}
+
+static void __uninstal_malloc_hook()
+{
+	if (__get_memleak_hook_flag()) {
+		return;
+	}
+	atomic_store_explicit(&__hook_enable_hook_flag, (volatile bool)false, memory_order_seq_cst);
+	bool flag = __set_hook_flag(false);
+	__set_default_malloc();
+	on_end_func_t end_func = (on_end_func_t)(function_of_shared_lib[ON_END_FUNCTION]);
+	if (end_func) {
+		end_func();
+	}
+}
+
+static void __install_memleak_tracker_hook(int32_t sigNum, siginfo_t *info, void *ptr)
+{
+	if (__get_global_hook_flag()) {
+		return;
+	}
+	atomic_store_explicit(&__memleak_hook_flag, (volatile bool)true, memory_order_seq_cst);
+	volatile void* memleak_ever_handle = (volatile void* )atomic_load_explicit(&memleak_ever_shared_library_handle, memory_order_acquire);
+	if (memleak_ever_handle != NULL) {
+		atomic_store_explicit(&ohos_malloc_hook_shared_library, (volatile long long)memleak_ever_handle, memory_order_seq_cst);
+	} else {
+		atomic_store_explicit(&ohos_malloc_hook_shared_library, (volatile long long)0, memory_order_seq_cst);
+	}
+	volatile void* shared_library_handle = (volatile void* )atomic_load_explicit(&ohos_malloc_hook_shared_library, memory_order_acquire);
+	memLeakTypeContent = (unsigned int)(siginfo_t *)((info)->si_addr);
+	if (shared_library_handle == NULL) {
+		if (__hook_mode == STEP_HOOK_MODE) {
+			if (memLeakTypeContent & ADDR_NATIVE_ENABLE) {
+				atomic_store_explicit(&__musl_libc_globals.current_dispatch_table, (volatile const long long)&__ohos_malloc_hook_init_dispatch, memory_order_seq_cst);
+				atomic_store_explicit(&ohos_malloc_hook_shared_library, (volatile long long)-1, memory_order_seq_cst);
+			}
+		} else {
+			init_ohos_malloc_hook();
+		}
+	} else if (shared_library_handle != (void*)-1) {
+		if (checkLoadMallocMemTrack) {
+			__restore_hook_function_table();
+			on_start_func_t start_func = (on_start_func_t)(function_of_shared_lib[ON_START_FUNCTION]);
+			if (memLeakTypeContent & ADDR_NATIVE_ENABLE) {
+				volatile const struct MallocDispatchType* memleak_tracker_so_dispatch_value = (volatile const struct MallocDispatchType* )atomic_load_explicit(&__musl_libc_globals.memleak_tracker_so_dispatch_table, memory_order_acquire);
+				atomic_store_explicit(&__musl_libc_globals.current_dispatch_table, (volatile long long)memleak_tracker_so_dispatch_value, memory_order_seq_cst);
+			}
+			if (start_func && !start_func(memLeakTypeContent)) {
+				// __musl_log(__MUSL_LOG_ERROR, "%s: failed to enable malloc\n", getprogname());
+				clear_function_table();
+			}
+			if (memLeakTypeContent & ADDR_NATIVE_CLEAR) {
+				atomic_store_explicit(&__memleak_hook_flag, (volatile bool)false, memory_order_seq_cst);
+				bool flag = __set_hook_flag(false);
+				__set_default_malloc();
+				on_end_func_t end_func = (on_end_func_t)(function_of_shared_lib[ON_END_FUNCTION]);
+				if (end_func) {
+					end_func();
+				}
+				memLeakTypeContent = 0;
+			}
+		}
+	}
+}
+
+
+static void __install_malloc_hook_signal_handler()
+{
+	struct sigaction actionInstallHook = {};
+	actionInstallHook.sa_handler = __install_malloc_hook;
+	sigemptyset(&actionInstallHook.sa_mask);
+	sigaddset(&actionInstallHook.sa_mask, MUSL_SIGNAL_UNHOOK);
+	sigaction(MUSL_SIGNAL_HOOK, &actionInstallHook, NULL);
+
+	struct sigaction actionDef = {};
+	actionDef.sa_handler = __uninstal_malloc_hook;
+	sigemptyset(&actionDef.sa_mask);
+	sigaddset(&actionDef.sa_mask, MUSL_SIGNAL_HOOK);
+	sigaction(MUSL_SIGNAL_UNHOOK, &actionDef, NULL);
+
+	struct sigaction actionInstallMemleakHook = {};
+	actionInstallMemleakHook.sa_handler = NULL;
+	actionInstallMemleakHook.sa_sigaction = __install_memleak_tracker_hook;
+	sigemptyset(&actionInstallMemleakHook.sa_mask);
+	sigaddset(&actionInstallMemleakHook.sa_mask, MUSL_SIGNAL_MEMCHECK);
+	actionInstallMemleakHook.sa_flags = SA_SIGINFO;
+	actionInstallMemleakHook.sa_restorer = NULL;
+	sigaction(MUSL_SIGNAL_MEMCHECK, &actionInstallMemleakHook, NULL);
+}
+
+static void __initialize_malloc()
+{
+	__install_malloc_hook_signal_handler();
+#ifdef USE_JEMALLOC_RECYCLE_FUNC
+	init_jemalloc_recycle_handler();
+#endif
+}
+
+__attribute__((constructor(1))) static void __musl_initialize()
+{
+	atomic_store_explicit(&__hook_enable_hook_flag, (volatile bool)false, memory_order_seq_cst);
+	atomic_store_explicit(&__memleak_hook_flag, (volatile bool)false, memory_order_seq_cst);
+	__set_default_malloc();
+	char hook_process_path[MAX_PROC_NAME_SIZE + 1] = {0};
+	parse_hook_variable(&__hook_mode, hook_process_path, sizeof(hook_process_path) - 1);
+	MUSL_LOGI("HiProfiler, __musl_initialize %{public}d", __hook_mode);
+	if (__hook_mode == STARTUP_HOOK_MODE) {
+		char proc_name[MAX_PROC_NAME_SIZE + 1] = {0};
+		if (get_proc_name(getpid(), proc_name, sizeof(proc_name) - 1)) {
+			const char *pos = strrchr(proc_name, '/');
+			const char* file_name;
+			if (pos != NULL) {
+				file_name = pos + 1;
+			} else {
+				file_name = proc_name;
+			}
+			MUSL_LOGI("HiProfiler, current proc %{public}s, , target proc %{public}s", file_name, hook_process_path);
+			if (strncmp(file_name, hook_process_path, strlen(hook_process_path)) == 0) {
+				atomic_store_explicit(&__hook_enable_hook_flag, (volatile bool)true, memory_order_seq_cst);
+				init_ohos_malloc_hook();
+			} else {
+				__hook_mode = STEP_HOOK_MODE;
+			}
+		} else {
+			__hook_mode = STEP_HOOK_MODE;
+		}
+	}
+	__initialize_malloc();
+	errno = 0;
+}
+#endif
diff --git a/src/hook/musl_preinit_common.c b/src/hook/musl_preinit_common.c
new file mode 100644
index 00000000..203c229c
--- /dev/null
+++ b/src/hook/musl_preinit_common.c
@@ -0,0 +1,24 @@
+#ifdef HOOK_ENABLE
+#include "musl_preinit_common.h"
+#include "musl_malloc.h"
+#include <stdatomic.h>
+#include <malloc.h>
+#include <stdlib.h>
+
+struct musl_libc_globals __musl_libc_globals;
+
+struct MallocDispatchType __libc_malloc_default_dispatch = {
+	.malloc = MuslFunc(malloc),
+	.free = MuslFunc(free),
+	.mmap = MuslMalloc(mmap),
+	.munmap = MuslMalloc(munmap),
+	.calloc = MuslFunc(calloc),
+	.realloc = MuslFunc(realloc),
+	.malloc_usable_size = MuslMalloc(malloc_usable_size),
+	.prctl = MuslMalloc(prctl),
+};
+
+volatile atomic_bool __hook_enable_hook_flag;
+volatile atomic_bool __memleak_hook_flag;
+
+#endif
diff --git a/src/hook/musl_preinit_common.h b/src/hook/musl_preinit_common.h
new file mode 100644
index 00000000..6666c97e
--- /dev/null
+++ b/src/hook/musl_preinit_common.h
@@ -0,0 +1,136 @@
+#ifndef _MUSL_PREINIT_COMMON_H
+#define _MUSL_PREINIT_COMMON_H
+
+#include <stdatomic.h>
+#include "musl_malloc_dispatch_table.h"
+#include "musl_malloc_dispatch.h"
+
+extern struct musl_libc_globals __musl_libc_globals;
+
+extern struct MallocDispatchType __libc_malloc_default_dispatch;
+
+extern volatile atomic_bool __hook_enable_hook_flag;
+
+extern volatile atomic_bool __memleak_hook_flag;
+extern bool checkLoadMallocMemTrack;
+
+enum EnumFunc {
+	INITIALIZE_FUNCTION,
+	FINALIZE_FUNCTION,
+	GET_HOOK_FLAG_FUNCTION,
+	SET_HOOK_FLAG_FUNCTION,
+	ON_START_FUNCTION,
+	ON_END_FUNCTION,
+	LAST_FUNCTION,
+};
+
+enum EnumHookMode {
+	STARTUP_HOOK_MODE,
+	DIRECT_HOOK_MODE,
+	STEP_HOOK_MODE,
+};
+
+#ifdef HOOK_ENABLE
+extern void* function_of_shared_lib[];
+extern volatile atomic_llong ohos_malloc_hook_shared_library;
+#endif // HOOK_ENABLE
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+__attribute__((always_inline))
+inline bool __get_global_hook_flag()
+{
+#ifdef HOOK_ENABLE
+	volatile bool g_flag = atomic_load_explicit(&__hook_enable_hook_flag, memory_order_acquire);
+	return g_flag;
+#else
+	return false;
+#endif // HOOK_ENABLE
+}
+
+__attribute__((always_inline))
+inline bool __get_memleak_hook_flag()
+{
+#ifdef HOOK_ENABLE
+	volatile bool memleak_flag = atomic_load_explicit(&__memleak_hook_flag, memory_order_acquire);
+	return memleak_flag;
+#else
+	return false;
+#endif // HOOK_ENABLE
+}
+
+
+__attribute__((always_inline))
+inline bool __get_hook_flag()
+{
+#ifdef HOOK_ENABLE
+	volatile void* impl_handle = (void *)atomic_load_explicit(&ohos_malloc_hook_shared_library, memory_order_acquire);
+	if (impl_handle == NULL) {
+		return false;
+	}
+	else if (impl_handle == (void *)-1) {
+		return true;
+	}
+	else {
+		GetHookFlagType get_hook_func_ptr = (GetHookFlagType)(function_of_shared_lib[GET_HOOK_FLAG_FUNCTION]);
+		bool flag = get_hook_func_ptr();
+		return flag;
+	}
+#else
+	return false;
+#endif // HOOK_ENABLE
+}
+
+__attribute__((always_inline))
+inline bool __set_hook_flag(bool flag)
+{
+#ifdef HOOK_ENABLE
+	volatile void* impl_handle = (void *)atomic_load_explicit(&ohos_malloc_hook_shared_library, memory_order_acquire);
+	if (impl_handle == NULL) {
+		return false;
+	}
+	else if (impl_handle == (void *)-1) {
+		return true;
+	}
+	else {
+		SetHookFlagType set_hook_func_ptr = (SetHookFlagType)(function_of_shared_lib[SET_HOOK_FLAG_FUNCTION]);
+		return set_hook_func_ptr(flag);
+	}
+#else
+	return false;
+#endif // HOOK_ENABLE
+}
+
+__attribute__((always_inline))
+inline volatile const struct MallocDispatchType* get_current_dispatch_table()
+{
+#ifdef HOOK_ENABLE
+	volatile const struct MallocDispatchType* ret = (struct MallocDispatchType *)atomic_load_explicit(&__musl_libc_globals.current_dispatch_table, memory_order_acquire);
+	if (ret != NULL) {
+		if (__get_memleak_hook_flag()) {
+			return ret;
+		}
+		if (!__get_global_hook_flag()) {
+			ret = NULL;
+		}
+		else if (!__get_hook_flag()) {
+			ret = NULL;
+		}
+	}
+	return ret;
+#else
+	return NULL;
+#endif // HOOK_ENABLE
+}
+
+#define MUSL_HOOK_PARAM_NAME "libc.hook_mode"
+#define OHOS_PARAM_MAX_SIZE 96
+#define FILE_NAME_MAX_SIZE 40
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/hook/musl_socket.h b/src/hook/musl_socket.h
new file mode 100644
index 00000000..5e5b838c
--- /dev/null
+++ b/src/hook/musl_socket.h
@@ -0,0 +1,21 @@
+#ifndef _MUSL_SOCKET_H
+#define _MUSL_SOCKET_H
+
+#include <sys/socket.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef OHOS_SOCKET_HOOK_ENABLE
+#define MuslSocket(func) __libc_ ## func
+int __libc_socket(int, int, int);
+#else
+#define MuslSocket(func) func
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/src/hook/musl_socket_dispatch.h b/src/hook/musl_socket_dispatch.h
new file mode 100644
index 00000000..5d17cc6c
--- /dev/null
+++ b/src/hook/musl_socket_dispatch.h
@@ -0,0 +1,26 @@
+#ifndef _MUSL_SOCKET_DISPATCH_H
+#define _MUSL_SOCKET_DISPATCH_H
+
+#include <stdbool.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef int (*SocketSocketType)(int, int, int);
+
+typedef bool (*SocketGetHookFlagType)();
+typedef bool (*SocketSetHookFlagType)(bool);
+
+struct SocketDispatchType
+{
+    SocketSocketType socket;
+    SocketGetHookFlagType get_hook_flag;
+    SocketSetHookFlagType set_hook_flag;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/src/hook/musl_socket_preinit.c b/src/hook/musl_socket_preinit.c
new file mode 100644
index 00000000..74f55ee6
--- /dev/null
+++ b/src/hook/musl_socket_preinit.c
@@ -0,0 +1,150 @@
+#ifdef OHOS_SOCKET_HOOK_ENABLE
+#include <unistd.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <dlfcn.h>
+#include <errno.h>
+#include <ctype.h>
+#include <assert.h>
+#include <string.h>
+#include <stdio.h>
+#include "musl_socket_preinit_common.h"
+#include "musl_log.h"
+
+static char *__socket_hook_shared_lib = "libfwmark_client.z.so";
+static char *__socket_hook_function_prefix = "ohos_socket_hook";
+void* shared_lib_func[LAST_FUNC];
+long long __ohos_socket_hook_shared_library;
+typedef bool (*init_func_type)(const struct SocketDispatchType*, bool*, const char*);
+typedef void (*finalize_func_type)();
+#define MAX_SYMBOL_SIZE 1000
+
+static bool init_socket_function(void* shared_library_handler, SocketSocketType* func)
+{
+	char symbol[MAX_SYMBOL_SIZE];
+	(void)snprintf(symbol, sizeof(symbol), "%s_%s", __socket_hook_function_prefix, "socket");
+	*func = (SocketSocketType)(dlsym(shared_library_handler, symbol));
+	if (*func == NULL) {
+		return false;
+	}
+	return true;
+}
+
+static void clear_socket_function()
+{
+	memset(shared_lib_func, 0, sizeof(shared_lib_func));
+}
+
+static void socket_finalize()
+{
+	((finalize_func_type)shared_lib_func[FINALIZE_FUNC])();
+	__current_dispatch = 0;
+	__socket_hook_begin_flag = false;
+	// Don't dlclose because hidumper crash
+}
+
+static bool finish_install_ohos_socket_hooks(const char* options)
+{
+	init_func_type init_func = (init_func_type)(shared_lib_func[INITIALIZE_FUNC]);
+	if (!init_func(&__libc_socket_default_dispatch, NULL, options)) {
+		MUSL_LOGI("Netsys, init_func failed.");
+		clear_socket_function();
+		return false;
+	}
+
+	int ret_value = atexit(socket_finalize);
+	if (ret_value != 0) {
+		MUSL_LOGI("Netsys, set atexit failed.");
+	}
+	return true;
+}
+
+static bool init_socket_hook_shared_library(void* shared_library_handle)
+{
+	static const char* names[] = {
+		"initialize",
+		"finalize",
+		"get_hook_flag",
+		"set_hook_flag",
+	};
+
+	for (int i = 0; i < LAST_FUNC; i++) {
+		char symbol[MAX_SYMBOL_SIZE];
+		(void)snprintf(symbol, sizeof(symbol), "%s_%s", __socket_hook_function_prefix, names[i]);
+		shared_lib_func[i] = dlsym(shared_library_handle, symbol);
+		if (shared_lib_func[i] == NULL) {
+			clear_socket_function();
+			return false;
+		}
+	}
+
+	if (!init_socket_function(shared_library_handle, &(__musl_libc_socket_dispatch.socket))) {
+		MUSL_LOGI("Netsys, set socket function failed.");
+		clear_socket_function();
+		return false;
+	}
+
+	return true;
+}
+
+static void* load_socket_hook_shared_library()
+{
+	void* shared_library_handle = NULL;
+
+	shared_library_handle = dlopen(__socket_hook_shared_lib, RTLD_NOW | RTLD_LOCAL);
+
+	if (shared_library_handle == NULL) {
+		MUSL_LOGI("Netsys, Unable to open shared library %s: %s.\n", __socket_hook_shared_lib, dlerror());
+		return NULL;
+	}
+
+	if (!init_socket_hook_shared_library(shared_library_handle)) {
+		dlclose(shared_library_handle);
+		shared_library_handle = NULL;
+	}
+	return shared_library_handle;
+}
+
+static void install_ohos_socket_hook()
+{
+	void* shared_library_handle = (void *)__ohos_socket_hook_shared_library;
+	if (shared_library_handle != NULL && shared_library_handle != (void*)-1) {
+		MUSL_LOGI("Netsys, ohos_socket_hook_shared_library has had.");
+		return;
+	}
+
+	__current_dispatch = 0;
+	shared_library_handle = load_socket_hook_shared_library();
+	if (shared_library_handle == NULL) {
+		MUSL_LOGI("Netsys, load_socket_hook_shared_library failed.");
+		return;
+	}
+	MUSL_LOGI("Netsys, load_socket_hook_shared_library success.");
+
+	if (finish_install_ohos_socket_hooks(NULL)) {
+		MUSL_LOGI("Netsys, finish_install_ohos_socket_hooks success.");
+		__ohos_socket_hook_shared_library = (long long)shared_library_handle;
+		__current_dispatch = (long long)(&__musl_libc_socket_dispatch);
+	} else {
+		MUSL_LOGI("Netsys, finish_install_ohos_socket_hooks failed.");
+		__ohos_socket_hook_shared_library = 0;
+		dlclose((void *)shared_library_handle);
+	}
+}
+
+static void init_ohos_socket_hook()
+{
+	install_ohos_socket_hook();
+}
+
+__attribute__((constructor())) static void __musl_socket_initialize()
+{
+	bool begin_flag = __get_socket_hook_begin_flag();
+	MUSL_LOGI("Netsys, %d begin musl_socket_initialize, flag %d.\n", getpid(), begin_flag);
+	if (!begin_flag) {
+		__socket_hook_begin_flag = true;
+		init_ohos_socket_hook();
+	}
+}
+#endif
\ No newline at end of file
diff --git a/src/hook/musl_socket_preinit_common.c b/src/hook/musl_socket_preinit_common.c
new file mode 100644
index 00000000..a586cf87
--- /dev/null
+++ b/src/hook/musl_socket_preinit_common.c
@@ -0,0 +1,16 @@
+#ifdef OHOS_SOCKET_HOOK_ENABLE
+#include <sys/socket.h>
+#include "musl_socket.h"
+#include "musl_socket_preinit_common.h"
+
+struct SocketDispatchType __musl_libc_socket_dispatch;
+
+long long __current_dispatch;
+
+struct SocketDispatchType __libc_socket_default_dispatch = {
+	.socket = MuslSocket(socket),
+};
+
+bool __socket_hook_begin_flag;
+
+#endif
\ No newline at end of file
diff --git a/src/hook/musl_socket_preinit_common.h b/src/hook/musl_socket_preinit_common.h
new file mode 100644
index 00000000..c13b6320
--- /dev/null
+++ b/src/hook/musl_socket_preinit_common.h
@@ -0,0 +1,83 @@
+#ifndef _MUSL_SOCKET_PREINIT_COMMON_H
+#define _MUSL_SOCKET_PREINIT_COMMON_H
+
+#include <stdio.h>
+#include "musl_socket_dispatch.h"
+#include "common_def.h"
+
+extern struct SocketDispatchType __musl_libc_socket_dispatch;
+extern struct SocketDispatchType __libc_socket_default_dispatch;
+
+enum SocketFuncEnum {
+	INITIALIZE_FUNC,
+	FINALIZE_FUNC,
+	GET_HOOK_FLAG_FUNC,
+	SET_HOOK_FLAG_FUNC,
+	LAST_FUNC,
+};
+
+#ifdef OHOS_SOCKET_HOOK_ENABLE
+extern long long __current_dispatch;
+extern bool __socket_hook_begin_flag;
+extern long long __ohos_socket_hook_shared_library;
+extern void* shared_lib_func[LAST_FUNC];
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+__attribute__((always_inline))
+inline bool __get_socket_hook_begin_flag()
+{
+#ifdef OHOS_SOCKET_HOOK_ENABLE
+	return __socket_hook_begin_flag;
+#else
+	return false;
+#endif
+}
+
+__attribute__((always_inline))
+inline bool __get_socket_hook_flag()
+{
+#ifdef OHOS_SOCKET_HOOK_ENABLE
+	void* handle = (void *)__ohos_socket_hook_shared_library;
+	if (handle == NULL) {
+		return false;
+	} else if (handle == (void *)-1) {
+		return true;
+	} else {
+		SocketGetHookFlagType get_hook_func_ptr = (SocketGetHookFlagType)(shared_lib_func[GET_HOOK_FLAG_FUNC]);
+		bool flag = get_hook_func_ptr();
+		return flag;
+	}
+#else
+	return false;
+#endif
+}
+
+__attribute__((always_inline))
+inline volatile const struct SocketDispatchType* get_socket_dispatch()
+{
+#ifdef OHOS_SOCKET_HOOK_ENABLE
+	volatile const struct SocketDispatchType* ret = (struct SocketDispatchType *)__current_dispatch;
+	if (ret != NULL) {
+		if (!__get_socket_hook_begin_flag()) {
+			ret = NULL;
+		} else if (!__get_socket_hook_flag()) {
+			ret = NULL;
+		} else {
+			return ret;
+		}
+	}
+	return ret;
+#else
+	return NULL;
+#endif
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/src/hook/socket_common.c b/src/hook/socket_common.c
new file mode 100644
index 00000000..939b75c5
--- /dev/null
+++ b/src/hook/socket_common.c
@@ -0,0 +1,18 @@
+#ifdef OHOS_SOCKET_HOOK_ENABLE
+#include "musl_socket.h"
+#include <sys/socket.h>
+#include "common_def.h"
+#include "musl_socket_preinit_common.h"
+
+int socket(int domain, int type, int protocol)
+{
+	volatile const struct SocketDispatchType* dispatch = get_socket_dispatch();
+	if (__predict_false(dispatch != NULL)) {
+		int ret = dispatch->socket(domain, type, protocol);
+		return ret;
+	}
+	int result = MuslSocket(socket)(domain, type, protocol);
+	return result;
+}
+
+#endif
\ No newline at end of file
diff --git a/src/info/application_target_sdk_version.c b/src/info/application_target_sdk_version.c
new file mode 100644
index 00000000..00906c0f
--- /dev/null
+++ b/src/info/application_target_sdk_version.c
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <info/application_target_sdk_version.h>
+
+static int application_target_sdk_version = SDK_VERSION_FUTURE;
+
+int get_application_target_sdk_version(void)
+{
+    return application_target_sdk_version;
+}
+
+void set_application_target_sdk_version(int target)
+{
+    if (target == 0) {
+        target = SDK_VERSION_FUTURE;
+    }
+    application_target_sdk_version = target;
+}
diff --git a/src/info/device_api_version.c b/src/info/device_api_version.c
new file mode 100644
index 00000000..86208c18
--- /dev/null
+++ b/src/info/device_api_version.c
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <info/device_api_version.h>
+
+#define API_VERSION_DEFAULT 0
+
+int get_device_api_version(void)
+{
+    // depend subsystem of syspara support the interface of get system property
+
+    return API_VERSION_DEFAULT;
+}
\ No newline at end of file
diff --git a/src/info/fatal_message.c b/src/info/fatal_message.c
new file mode 100644
index 00000000..5b659416
--- /dev/null
+++ b/src/info/fatal_message.c
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <info/fatal_message.h>
+
+#include <pthread.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/prctl.h>
+#include "musl_log.h"
+
+static pthread_mutex_t fatal_msg_lock = PTHREAD_MUTEX_INITIALIZER;
+static fatal_msg_t *fatal_message = NULL;
+
+void set_fatal_message(const char *msg)
+{
+    pthread_mutex_lock(&fatal_msg_lock);
+
+    if (msg == NULL) {
+        MUSL_LOGW("message null");
+        pthread_mutex_unlock(&fatal_msg_lock);
+        return;
+    }
+
+    if (fatal_message != NULL) {
+        pthread_mutex_unlock(&fatal_msg_lock);
+        return;
+    }
+
+    size_t size = sizeof(fatal_msg_t) + strlen(msg) + 1;
+    void *map = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);
+    if (map == MAP_FAILED) {
+        MUSL_LOGW("mmap failed");
+        fatal_message = NULL;
+        pthread_mutex_unlock(&fatal_msg_lock);
+        return;
+    }
+
+    int ret = prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, map, size, "fatal message");
+    if (ret < 0) {
+        MUSL_LOGW("prctl set vma failed");
+        munmap(map, size);
+        fatal_message = NULL;
+        pthread_mutex_unlock(&fatal_msg_lock);
+        return;
+    }
+
+    fatal_message = (fatal_msg_t *)(map);
+    fatal_message->size = size;
+    strcpy(fatal_message->msg, msg);
+    pthread_mutex_unlock(&fatal_msg_lock);
+    return;
+}
+
+fatal_msg_t *get_fatal_message(void)
+{
+    return fatal_message;
+}
diff --git a/src/internal/dynlink.h b/src/internal/dynlink.h
index 51c0639f..620ea808 100644
--- a/src/internal/dynlink.h
+++ b/src/internal/dynlink.h
@@ -6,11 +6,20 @@
 #include <stdint.h>
 #include <stddef.h>
 #include <stdarg.h>
+#include <link.h>
+#include <sys/types.h>
+#include <stdlib.h>
+#include "libc.h"
+#include "../../ldso/namespace.h"
 
 #if UINTPTR_MAX == 0xffffffff
 typedef Elf32_Ehdr Ehdr;
 typedef Elf32_Phdr Phdr;
 typedef Elf32_Sym Sym;
+typedef Elf32_Verdaux Verdaux;
+typedef Elf32_Verdef Verdef;
+typedef Elf32_Vernaux Vernaux;
+typedef Elf32_Verneed Verneed;
 #define R_TYPE(x) ((x)&255)
 #define R_SYM(x) ((x)>>8)
 #define R_INFO ELF32_R_INFO
@@ -18,6 +27,10 @@ typedef Elf32_Sym Sym;
 typedef Elf64_Ehdr Ehdr;
 typedef Elf64_Phdr Phdr;
 typedef Elf64_Sym Sym;
+typedef Elf64_Verdaux Verdaux;
+typedef Elf64_Verdef Verdef;
+typedef Elf64_Vernaux Vernaux;
+typedef Elf64_Verneed Verneed;
 #define R_TYPE(x) ((x)&0x7fffffff)
 #define R_SYM(x) ((x)>>32)
 #define R_INFO ELF64_R_INFO
@@ -45,6 +58,104 @@ enum {
 	REL_FUNCDESC_VAL,
 };
 
+struct td_index {
+	size_t args[2];
+	struct td_index *next;
+};
+
+struct verinfo {
+	const char *s;
+	const char *v;
+	bool use_vna_hash;
+	uint32_t vna_hash;
+};
+
+struct sym_info_pair {
+	uint_fast32_t sym_h;
+	uint32_t sym_l;
+};
+
+struct dso {
+#if DL_FDPIC
+	struct fdpic_loadmap *loadmap;
+#else
+	unsigned char *base;
+#endif
+	char *name;
+	size_t *dynv;
+	struct dso *next, *prev;
+	/* add namespace */
+	ns_t *namespace;
+	int cache_sym_index;
+	struct dso *cache_dso;
+	Sym *cache_sym;
+	Phdr *phdr;
+	int phnum;
+	size_t phentsize;
+	Sym *syms;
+	Elf_Symndx *hashtab;
+	uint32_t *ghashtab;
+	int16_t *versym;
+	Verdef *verdef;
+	Verneed *verneed;
+	char *strings;
+	struct dso *syms_next, *lazy_next;
+	size_t *lazy, lazy_cnt;
+	unsigned char *map;
+	size_t map_len;
+	dev_t dev;
+	ino_t ino;
+	uint64_t file_offset;
+	pthread_t ctor_visitor;
+	char *rpath_orig, *rpath;
+	struct tls_module tls;
+	size_t tls_id;
+	size_t relro_start, relro_end;
+	uintptr_t *new_dtv;
+	unsigned char *new_tls;
+	struct td_index *td_index;
+	struct dso *fini_next;
+	char *shortname;
+#if DL_FDPIC
+	unsigned char *base;
+#else
+	struct fdpic_loadmap *loadmap;
+#endif
+	struct funcdesc {
+		void *addr;
+		size_t *got;
+	} *funcdescs;
+	size_t *got;
+	struct dso **deps, *needed_by;
+	uint16_t ndeps_direct;
+	uint16_t next_dep;
+	uint16_t parents_count;
+	uint16_t parents_capacity;
+	struct dso **parents;
+	struct dso **reloc_can_search_dso_list;
+	uint16_t reloc_can_search_dso_count;
+	uint16_t reloc_can_search_dso_capacity;
+	/* mark the dso status */
+	uint32_t flags;
+	uint8_t nr_dlopen;
+	bool is_global;
+	bool is_reloc_head_so_dep;
+	char relocated;
+	char constructed;
+	char kernel_mapped;
+	char mark;
+	char bfs_built;
+	char runtime_loaded;
+	char by_dlopen;
+	bool is_mapped_to_shadow;
+	char buf[];
+};
+
+struct symdef {
+	Sym *sym;
+	struct dso *dso;
+};
+
 struct fdpic_loadseg {
 	uintptr_t addr, p_vaddr, p_memsz;
 };
@@ -93,11 +204,42 @@ struct fdpic_dummy_loadmap {
 #endif
 
 #define AUX_CNT 32
-#define DYN_CNT 32
+#define DYN_CNT 37
+
+#define DT_ANDROID_REL (DT_LOOS + 2)
+#define DT_ANDROID_RELSZ (DT_LOOS + 3)
+
+#define DT_ANDROID_RELA (DT_LOOS + 4)
+#define DT_ANDROID_RELASZ (DT_LOOS + 5)
+
+#define ANDROID_REL_SIGN_SIZE 4
+
+#define RELOCATION_GROUPED_BY_INFO_FLAG 1
+#define RELOCATION_GROUPED_BY_OFFSET_DELTA_FLAG 2
+#define RELOCATION_GROUPED_BY_ADDEND_FLAG 4
+#define RELOCATION_GROUP_HAS_ADDEND_FLAG 8
 
 typedef void (*stage2_func)(unsigned char *, size_t *);
 
+#if DL_FDPIC
+void *laddr(const struct dso *p, size_t v);
+#endif
+
+#ifdef UNIT_TEST_STATIC
+    #define UT_STATIC
+#else
+    #define UT_STATIC static
+#endif
+
+void *addr2dso(size_t a);
+UT_STATIC size_t count_syms(struct dso *p);
+struct sym_info_pair gnu_hash(const char *s0);
+struct symdef find_sym_impl(
+	struct dso *dso, struct verinfo *verinfo, struct sym_info_pair s_info_p, int need_def, ns_t *ns);
+
 hidden void *__dlsym(void *restrict, const char *restrict, void *restrict);
+hidden void *__dlvsym(void *restrict, const char *restrict, const char *restrict, void *restrict);
+hidden int __dlclose(void *p);
 
 hidden void __dl_seterr(const char *, ...);
 hidden int __dl_invalid_handle(void *);
diff --git a/src/internal/hilog_adapter.h b/src/internal/hilog_adapter.h
new file mode 100644
index 00000000..98d4d793
--- /dev/null
+++ b/src/internal/hilog_adapter.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef MUSL_HILOG_ADAPTER_H
+#define MUSL_HILOG_ADAPTER_H
+
+#include <features.h>
+#include <stdarg.h>
+#include <stdbool.h>
+
+#ifndef hidden
+#define hidden __attribute__((visibility("hidden")))
+#endif
+
+// Log type
+typedef enum {
+    LOG_TYPE_MIN = 0,
+    LOG_APP = 0,
+    // Log to kmsg, only used by init phase.
+    LOG_INIT = 1,
+    // Used by core service, framework.
+    LOG_CORE = 3,
+    LOG_KMSG = 4,
+    LOG_TYPE_MAX
+} LogType;
+
+// Log level
+typedef enum {
+    LOG_LEVEL_MIN = 0,
+    LOG_DEBUG = 3,
+    LOG_INFO = 4,
+    LOG_WARN = 5,
+    LOG_ERROR = 6,
+    LOG_FATAL = 7,
+    LOG_LEVEL_MAX,
+} LogLevel;
+
+hidden int HiLogAdapterPrint(LogType type, LogLevel level, unsigned int domain, const char *tag, const char *fmt, ...)
+    __attribute__((__format__(os_log, 5, 6)));
+
+hidden bool HiLogAdapterIsLoggable(unsigned int domain, const char *tag, LogLevel level);
+
+#ifdef OHOS_ENABLE_PARAMETER
+#include "sys_param.h"
+hidden bool get_bool_sysparam(CachedHandle cachedhandle);
+#endif
+
+hidden bool is_musl_log_enable();
+hidden void musl_log_reset();
+
+#endif  // MUSL_HILOG_ADAPTER_H
diff --git a/src/internal/libc.h b/src/internal/libc.h
index 619bba86..9e5a6b61 100644
--- a/src/internal/libc.h
+++ b/src/internal/libc.h
@@ -1,20 +1,35 @@
+/**
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #ifndef LIBC_H
 #define LIBC_H
 
 #include <stdlib.h>
 #include <stdio.h>
 #include <limits.h>
-
+#include <locale.h>
 struct __locale_map;
 
 struct __locale_struct {
-	const struct __locale_map *cat[6];
+    const struct __locale_map *cat[LC_ALL];
 };
 
 struct tls_module {
-	struct tls_module *next;
-	void *image;
-	size_t len, size, align, offset;
+    struct tls_module *next;
+    void *image;
+    size_t len, size, align, offset;
 };
 
 struct __libc {
diff --git a/src/internal/locale_impl.h b/src/internal/locale_impl.h
index 4431a92e..a843f0e7 100644
--- a/src/internal/locale_impl.h
+++ b/src/internal/locale_impl.h
@@ -7,12 +7,15 @@
 #include "pthread_impl.h"
 
 #define LOCALE_NAME_MAX 23
+#define VALID 2
+#define INVALID 1
 
 struct __locale_map {
 	const void *map;
 	size_t map_size;
 	char name[LOCALE_NAME_MAX+1];
 	const struct __locale_map *next;
+	char flag;
 };
 
 extern hidden volatile int __locale_lock[1];
diff --git a/src/internal/malloc_config.h b/src/internal/malloc_config.h
new file mode 100644
index 00000000..b9bcbb53
--- /dev/null
+++ b/src/internal/malloc_config.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#ifndef MALLOC_CONFIG_H
+#define MALLOC_CONFIG_H
+
+#ifdef MALLOC_SECURE_ALL
+
+#ifndef MALLOC_FREELIST_HARDENED
+#define MALLOC_FREELIST_HARDENED
+#endif
+
+#ifndef MALLOC_FREELIST_QUARANTINE
+#define MALLOC_FREELIST_QUARANTINE
+#endif
+
+#ifndef MALLOC_RED_ZONE
+#define MALLOC_RED_ZONE
+#endif
+
+#endif // MALLOC_SECURE_ALL
+
+#if defined(MALLOC_FREELIST_QUARANTINE) && !defined(MALLOC_FREELIST_HARDENED)
+#error MALLOC_FREELIST_QUARANTINE can be only applied when MALLOC_FREELIST_HARDENED is set.
+#endif
+
+#if defined(MALLOC_RED_ZONE) && !defined(MALLOC_FREELIST_QUARANTINE)
+#error MALLOC_RED_ZONE can be only applied when MALLOC_FREELIST_QUARANTINE is set.
+#endif
+
+#endif // MALLOC_CONFIG_H
diff --git a/src/internal/malloc_random.h b/src/internal/malloc_random.h
new file mode 100644
index 00000000..2edfa072
--- /dev/null
+++ b/src/internal/malloc_random.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdint.h>
+#include "malloc_config.h"
+
+void* encode_ptr(void *ptr, void *key);
+void* next_key(void);
diff --git a/src/internal/musl_log.h b/src/internal/musl_log.h
new file mode 100644
index 00000000..62e15d3f
--- /dev/null
+++ b/src/internal/musl_log.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _MUSL_LOG_H
+#define _MUSL_LOG_H
+
+#include <hilog_adapter.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MUSL_LOG_TYPE LOG_CORE
+#define MUSL_LOG_DOMAIN 0xD003F00
+#define MUSL_LOG_TAG "MUSL"
+
+#if (defined(OHOS_ENABLE_PARAMETER) || defined(ENABLE_MUSL_LOG))
+#define MUSL_LOGE(...) ((void)HiLogAdapterPrint(MUSL_LOG_TYPE, LOG_ERROR, MUSL_LOG_DOMAIN, MUSL_LOG_TAG, __VA_ARGS__))
+#define MUSL_LOGW(...) ((void)HiLogAdapterPrint(MUSL_LOG_TYPE, LOG_WARN, MUSL_LOG_DOMAIN, MUSL_LOG_TAG, __VA_ARGS__))
+#define MUSL_LOGI(...) ((void)HiLogAdapterPrint(MUSL_LOG_TYPE, LOG_INFO, MUSL_LOG_DOMAIN, MUSL_LOG_TAG, __VA_ARGS__))
+#define MUSL_LOGD(...) ((void)HiLogAdapterPrint(MUSL_LOG_TYPE, LOG_DEBUG, MUSL_LOG_DOMAIN, MUSL_LOG_TAG, __VA_ARGS__))
+#else
+#define MUSL_LOGE(...)
+#define MUSL_LOGW(...)
+#define MUSL_LOGI(...)
+#define MUSL_LOGD(...)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/src/internal/pthread_impl.h b/src/internal/pthread_impl.h
index de2b9d8b..1faf28d2 100644
--- a/src/internal/pthread_impl.h
+++ b/src/internal/pthread_impl.h
@@ -1,5 +1,20 @@
-#ifndef _PTHREAD_IMPL_H
-#define _PTHREAD_IMPL_H
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _INTERNAL_PTHREAD_IMPL_H
+#define _INTERNAL_PTHREAD_IMPL_H
 
 #include <pthread.h>
 #include <signal.h>
@@ -31,33 +46,39 @@ struct pthread {
 	uintptr_t canary;
 #endif
 
-	/* Part 2 -- implementation details, non-ABI. */
-	int tid;
-	int errno_val;
-	volatile int detach_state;
-	volatile int cancel;
-	volatile unsigned char canceldisable, cancelasync;
-	unsigned char tsd_used:1;
-	unsigned char dlerror_flag:1;
-	unsigned char *map_base;
-	size_t map_size;
-	void *stack;
-	size_t stack_size;
-	size_t guard_size;
-	void *result;
-	struct __ptcb *cancelbuf;
-	void **tsd;
-	struct {
-		volatile void *volatile head;
-		long off;
-		volatile void *volatile pending;
-	} robust_list;
+    /* Part 2 -- implementation details, non-ABI. */
+    int tid;
+    int pid;
+    int errno_val;
+    volatile int detach_state;
+#ifdef FEATURE_PTHREAD_CANCEL
+    volatile int cancel;
+    volatile unsigned char canceldisable, cancelasync;
+#endif
+    unsigned char tsd_used:1;
+    unsigned char dlerror_flag:1;
+    unsigned char *map_base;
+    size_t map_size;
+    void *stack;
+    size_t stack_size;
+    size_t guard_size;
+    void *result;
+    struct __ptcb *cancelbuf;
+    void **tsd;
+    struct {
+        volatile void *volatile head;
+        long off;
+        volatile void *volatile pending;
+    } robust_list;
 	int h_errno_val;
-	volatile int timer_id;
-	locale_t locale;
-	volatile int killlock[1];
-	char *dlerror_buf;
-	void *stdio_locks;
+    volatile int timer_id;
+    locale_t locale;
+    volatile int killlock[1];
+    char *dlerror_buf;
+    void *stdio_locks;
+#ifdef RESERVE_SIGNAL_STACK
+    void *signal_stack;
+#endif
 
 	/* Part 3 -- the positions of these fields relative to
 	 * the end of the structure is external and internal ABI. */
@@ -83,12 +104,23 @@ enum {
 #define _a_sched __u.__i[3*__SU+1]
 #define _a_policy __u.__i[3*__SU+2]
 #define _a_prio __u.__i[3*__SU+3]
+
+/* we define the original value of _m_* in include/pthread.h
+ * as macros MUTEX_* to make the user be able to
+ * access the inner attribute of the mutex struct.
+ * Then, we modify the value of _m_* macros to MUTEX_* here,
+ * so that we can immediately be aware of the changes that
+ * the open source society has made to these original macros,
+ * because patching will fail if the value of the _m_* are
+ * changed by musl society */
 #define _m_type __u.__i[0]
 #define _m_lock __u.__vi[1]
 #define _m_waiters __u.__vi[2]
 #define _m_prev __u.__p[3]
 #define _m_next __u.__p[4]
+#define _m_clock __u.__i[4]
 #define _m_count __u.__i[5]
+
 #define _c_shared __u.__p[0]
 #define _c_seq __u.__vi[2]
 #define _c_waiters __u.__vi[3]
@@ -99,6 +131,7 @@ enum {
 #define _rw_lock __u.__vi[0]
 #define _rw_waiters __u.__vi[1]
 #define _rw_shared __u.__i[2]
+#define _rw_clock __u.__i[4]
 #define _b_lock __u.__vi[0]
 #define _b_waiters __u.__vi[1]
 #define _b_limit __u.__i[2]
@@ -132,11 +165,11 @@ enum {
 
 #define SIGALL_SET ((sigset_t *)(const unsigned long long [2]){ -1,-1 })
 #define SIGPT_SET \
-	((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
-	[sizeof(long)==4] = 3UL<<(32*(sizeof(long)>4)) })
+    ((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
+    [sizeof(long)==4] = 3UL<<(32*(sizeof(long)>4)) })
 #define SIGTIMER_SET \
-	((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
-	 0x80000000 })
+    ((sigset_t *)(const unsigned long [_NSIG/8/sizeof(long)]){ \
+    0x80000000 })
 
 void *__tls_get_addr(tls_mod_off_t *);
 hidden int __init_tp(void *);
@@ -167,18 +200,50 @@ hidden int __timedwait_cp(volatile int *, int, clockid_t, const struct timespec
 hidden void __wait(volatile int *, volatile int *, int, int);
 static inline void __wake(volatile void *addr, int cnt, int priv)
 {
-	if (priv) priv = FUTEX_PRIVATE;
-	if (cnt<0) cnt = INT_MAX;
-	__syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
-	__syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
+    if (priv) priv = FUTEX_PRIVATE;
+    if (cnt<0) cnt = INT_MAX;
+    __syscall(SYS_futex, addr, FUTEX_WAKE|priv, cnt) != -ENOSYS ||
+    __syscall(SYS_futex, addr, FUTEX_WAKE, cnt);
 }
 static inline void __futexwait(volatile void *addr, int val, int priv)
 {
-	if (priv) priv = FUTEX_PRIVATE;
-	__syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
-	__syscall(SYS_futex, addr, FUTEX_WAIT, val, 0);
+    if (priv) priv = FUTEX_PRIVATE;
+    __syscall(SYS_futex, addr, FUTEX_WAIT|priv, val, 0) != -ENOSYS ||
+    __syscall(SYS_futex, addr, FUTEX_WAIT, val, 0);
+}
+
+#define MS_PER_S 1000
+#define US_PER_S 1000000
+static inline void __timespec_from_ms(struct timespec* ts, const unsigned ms)
+{
+    if (ts == NULL) {
+        return;
+    }
+    ts->tv_sec = ms / MS_PER_S;
+    ts->tv_nsec = (ms % MS_PER_S) * US_PER_S;
+}
+
+#define NS_PER_S 1000000000
+static inline void __absolute_timespec_from_timespec(struct timespec *abs_ts,
+                                                     const struct timespec *ts, clockid_t clock)
+{
+    if (abs_ts == NULL || ts == NULL) {
+        return;
+    }
+    clock_gettime(clock, abs_ts);
+    abs_ts->tv_sec += ts->tv_sec;
+    abs_ts->tv_nsec += ts->tv_nsec;
+    if (abs_ts->tv_nsec >= NS_PER_S) {
+        abs_ts->tv_nsec -= NS_PER_S;
+        abs_ts->tv_sec++;
+    }
 }
 
+#ifdef RESERVE_SIGNAL_STACK
+hidden void pthread_reserve_signal_stack();
+hidden void pthread_release_signal_stack();
+#endif
+
 hidden void __acquire_ptc(void);
 hidden void __release_ptc(void);
 hidden void __inhibit_ptc(void);
@@ -186,6 +251,7 @@ hidden void __inhibit_ptc(void);
 hidden void __tl_lock(void);
 hidden void __tl_unlock(void);
 hidden void __tl_sync(pthread_t);
+hidden struct pthread* __pthread_list_find(pthread_t, const char*);
 
 extern hidden volatile int __thread_list_lock;
 
@@ -194,8 +260,17 @@ extern hidden volatile int __abort_lock[1];
 extern hidden unsigned __default_stacksize;
 extern hidden unsigned __default_guardsize;
 
+#ifdef TARGET_STACK_SIZE
+#define DEFAULT_STACK_SIZE TARGET_STACK_SIZE
+#else
 #define DEFAULT_STACK_SIZE 131072
+#endif
+
+#ifdef TARGET_GUARD_SIZE
+#define DEFAULT_GUARD_SIZE TARGET_GUARD_SIZE
+#else
 #define DEFAULT_GUARD_SIZE 8192
+#endif
 
 #define DEFAULT_STACK_MAX (8<<20)
 #define DEFAULT_GUARD_MAX (1<<20)
diff --git a/src/internal/stdio_impl.h b/src/internal/stdio_impl.h
index 0b2438d6..055c9f57 100644
--- a/src/internal/stdio_impl.h
+++ b/src/internal/stdio_impl.h
@@ -17,6 +17,8 @@
 #define F_ERR 32
 #define F_SVB 64
 #define F_APP 128
+#define F_NOBUF 256
+#define F_PBUF 512
 
 struct _IO_FILE {
 	unsigned flags;
@@ -26,10 +28,19 @@ struct _IO_FILE {
 	unsigned char *mustbezero_1;
 	unsigned char *wbase;
 	size_t (*read)(FILE *, unsigned char *, size_t);
+	size_t (*readx)(FILE *, unsigned char *, size_t);
 	size_t (*write)(FILE *, const unsigned char *, size_t);
 	off_t (*seek)(FILE *, off_t, int);
 	unsigned char *buf;
 	size_t buf_size;
+	/* when allocating buffer dynamically, base == buf - UNGET,
+	 * free base when calling fclose.
+	 * otherwise, base == NULL, cases:
+	 * 1. in stdout, stdin, stdout, base is static array.
+	 * 2. call setvbuf to set buffer or non-buffer.
+	 * 3. call fmemopen, base == NULL && buf_size != 0.
+	 */
+	unsigned char *base;
 	FILE *prev, *next;
 	int fd;
 	int pipe_pid;
@@ -55,13 +66,18 @@ hidden int __lockfile(FILE *);
 hidden void __unlockfile(FILE *);
 
 hidden size_t __stdio_read(FILE *, unsigned char *, size_t);
+hidden size_t __stdio_readx(FILE *, unsigned char *, size_t);
 hidden size_t __stdio_write(FILE *, const unsigned char *, size_t);
 hidden size_t __stdout_write(FILE *, const unsigned char *, size_t);
 hidden off_t __stdio_seek(FILE *, off_t, int);
 hidden int __stdio_close(FILE *);
 
+hidden int __fill_buffer(FILE *f);
+hidden ssize_t __flush_buffer(FILE *f);
+
 hidden int __toread(FILE *);
 hidden int __towrite(FILE *);
+hidden int __falloc_buf(FILE *);
 
 hidden void __stdio_exit(void);
 hidden void __stdio_exit_needed(void);
@@ -79,11 +95,14 @@ hidden size_t __fwritex(const unsigned char *, size_t, FILE *);
 hidden int __putc_unlocked(int, FILE *);
 
 hidden FILE *__fdopen(int, const char *);
-hidden int __fmodeflags(const char *);
+hidden FILE *__fdopenx(int, int);
+hidden int __fmodeflags(const char *, int *);
 
 hidden FILE *__ofl_add(FILE *f);
 hidden FILE **__ofl_lock(void);
 hidden void __ofl_unlock(void);
+hidden void __ofl_free(FILE *f);
+hidden FILE *__ofl_alloc();
 
 struct __pthread;
 hidden void __register_locked_file(FILE *, struct __pthread *);
@@ -102,8 +121,8 @@ hidden void __getopt_msg(const char *, const char *, const char *, size_t);
 
 #define putc_unlocked(c, f) \
 	( (((unsigned char)(c)!=(f)->lbf && (f)->wpos!=(f)->wend)) \
-	? *(f)->wpos++ = (unsigned char)(c) \
-	: __overflow((f),(unsigned char)(c)) )
+	  ? *(f)->wpos++ = (unsigned char)(c) \
+	  : __overflow((f),(unsigned char)(c)) )
 
 /* Caller-allocated FILE * operations */
 hidden FILE *__fopen_rb_ca(const char *, FILE *, unsigned char *, size_t);
diff --git a/src/internal/syscall.h b/src/internal/syscall.h
index d5f294d4..5c6fbf83 100644
--- a/src/internal/syscall.h
+++ b/src/internal/syscall.h
@@ -55,8 +55,13 @@ hidden long __syscall_ret(unsigned long),
 #define __syscall_cp5(n,a,b,c,d,e) (__syscall_cp)(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),0)
 #define __syscall_cp6(n,a,b,c,d,e,f) (__syscall_cp)(n,__scc(a),__scc(b),__scc(c),__scc(d),__scc(e),__scc(f))
 
+#ifdef FEATURE_PTHREAD_CANCEL
 #define __syscall_cp(...) __SYSCALL_DISP(__syscall_cp,__VA_ARGS__)
 #define syscall_cp(...) __syscall_ret(__syscall_cp(__VA_ARGS__))
+#else
+#define __syscall_cp(...) __SYSCALL_DISP(__syscall,__VA_ARGS__)
+#define syscall_cp(...) __syscall_ret(__syscall(__VA_ARGS__))
+#endif
 
 static inline long __alt_socketcall(int sys, int sock, int cp, long a, long b, long c, long d, long e, long f)
 {
@@ -286,10 +291,6 @@ static inline long __alt_socketcall(int sys, int sock, int cp, long a, long b, l
 #define SYS_utimensat SYS_utimensat_time64
 #endif
 
-#ifndef SYS_pselect6
-#define SYS_pselect6 SYS_pselect6_time64
-#endif
-
 #ifndef SYS_ppoll
 #define SYS_ppoll SYS_ppoll_time64
 #endif
@@ -395,4 +396,7 @@ hidden void __procfdname(char __buf[static 15+3*sizeof(int)], unsigned);
 
 hidden void *__vdsosym(const char *, const char *);
 
+hidden void __get_vdso_info();
+hidden void *__get_vdso_addr(const char *, const char *);
+
 #endif
diff --git a/src/internal/vdso.c b/src/internal/vdso.c
index d46d3228..3cb1d25b 100644
--- a/src/internal/vdso.c
+++ b/src/internal/vdso.c
@@ -1,3 +1,18 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <elf.h>
 #include <link.h>
 #include <limits.h>
@@ -40,12 +55,24 @@ static int checkver(Verdef *def, int vsym, const char *vername, char *strings)
 #define OK_TYPES (1<<STT_NOTYPE | 1<<STT_OBJECT | 1<<STT_FUNC | 1<<STT_COMMON)
 #define OK_BINDS (1<<STB_GLOBAL | 1<<STB_WEAK | 1<<STB_GNU_UNIQUE)
 
-void *__vdsosym(const char *vername, const char *name)
+struct __vdso_info {
+	size_t base;
+	char *strings;
+	Sym *syms;
+	Elf_Symndx *hashtab;
+	uint16_t *versym;
+	Verdef *verdef;
+} vdso_info = {-1, 0, 0, 0, 0, 0};
+
+void __get_vdso_info()
 {
+	if (vdso_info.base != -1) {
+		return ;
+	}
 	size_t i;
 	for (i=0; libc.auxv[i] != AT_SYSINFO_EHDR; i+=2)
-		if (!libc.auxv[i]) return 0;
-	if (!libc.auxv[i+1]) return 0;
+		if (!libc.auxv[i]) return ;
+	if (!libc.auxv[i+1]) return ;
 	Ehdr *eh = (void *)libc.auxv[i+1];
 	Phdr *ph = (void *)((char *)eh + eh->e_phoff);
 	size_t *dynv=0, base=-1;
@@ -55,36 +82,36 @@ void *__vdsosym(const char *vername, const char *name)
 		else if (ph->p_type == PT_DYNAMIC)
 			dynv = (void *)((char *)eh + ph->p_offset);
 	}
-	if (!dynv || base==(size_t)-1) return 0;
-
-	char *strings = 0;
-	Sym *syms = 0;
-	Elf_Symndx *hashtab = 0;
-	uint16_t *versym = 0;
-	Verdef *verdef = 0;
+	if (!dynv || base==(size_t)-1) return ;
 	
 	for (i=0; dynv[i]; i+=2) {
 		void *p = (void *)(base + dynv[i+1]);
 		switch(dynv[i]) {
-		case DT_STRTAB: strings = p; break;
-		case DT_SYMTAB: syms = p; break;
-		case DT_HASH: hashtab = p; break;
-		case DT_VERSYM: versym = p; break;
-		case DT_VERDEF: verdef = p; break;
+		case DT_STRTAB: vdso_info.strings = p; break;
+		case DT_SYMTAB: vdso_info.syms = p; break;
+		case DT_HASH: vdso_info.hashtab = p; break;
+		case DT_VERSYM: vdso_info.versym = p; break;
+		case DT_VERDEF: vdso_info.verdef = p; break;
 		}
-	}	
+	}
+    vdso_info.base = base;
+    return ;
+}
 
-	if (!strings || !syms || !hashtab) return 0;
-	if (!verdef) versym = 0;
+void *__get_vdso_addr(const char *vername, const char *name)
+{
+	if (!vdso_info.strings || !vdso_info.syms || !vdso_info.hashtab) return 0;
+	if (!vdso_info.verdef) vdso_info.versym = 0;
 
-	for (i=0; i<hashtab[1]; i++) {
-		if (!(1<<(syms[i].st_info&0xf) & OK_TYPES)) continue;
-		if (!(1<<(syms[i].st_info>>4) & OK_BINDS)) continue;
-		if (!syms[i].st_shndx) continue;
-		if (strcmp(name, strings+syms[i].st_name)) continue;
-		if (versym && !checkver(verdef, versym[i], vername, strings))
+    size_t i;
+	for (i=0; i<vdso_info.hashtab[1]; i++) {
+		if (!(1<<(vdso_info.syms[i].st_info&0xf) & OK_TYPES)) continue;
+		if (!(1<<(vdso_info.syms[i].st_info>>4) & OK_BINDS)) continue;
+		if (!vdso_info.syms[i].st_shndx) continue;
+		if (strcmp(name, vdso_info.strings+vdso_info.syms[i].st_name)) continue;
+		if (vdso_info.versym && !checkver(vdso_info.verdef, vdso_info.versym[i], vername, vdso_info.strings))
 			continue;
-		return (void *)(base + syms[i].st_value);
+		return (void *)(vdso_info.base + vdso_info.syms[i].st_value);
 	}
 
 	return 0;
diff --git a/src/ldso/aarch64/dlvsym.s b/src/ldso/aarch64/dlvsym.s
new file mode 100644
index 00000000..5a785cfa
--- /dev/null
+++ b/src/ldso/aarch64/dlvsym.s
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+.global dlvsym
+.hidden __dlvsym
+.type dlvsym,%function
+dlvsym:
+	mov x3,x30
+	b __dlvsym
diff --git a/src/ldso/arm/dlvsym.s b/src/ldso/arm/dlvsym.s
new file mode 100644
index 00000000..43584942
--- /dev/null
+++ b/src/ldso/arm/dlvsym.s
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+.syntax unified
+.text
+.global dlvsym
+.hidden __dlvsym
+.type dlvsym,%function
+dlvsym:
+	mov r3,lr
+	b __dlvsym
diff --git a/src/ldso/dlclose.c b/src/ldso/dlclose.c
index e437422a..566c8c3b 100644
--- a/src/ldso/dlclose.c
+++ b/src/ldso/dlclose.c
@@ -1,7 +1,14 @@
 #include <dlfcn.h>
 #include "dynlink.h"
 
-int dlclose(void *p)
+static int dummy(void *p)
 {
 	return __dl_invalid_handle(p);
 }
+weak_alias(dummy, __dlclose);
+
+int dlclose(void *p)
+{
+	return __dlclose(p);
+}
+
diff --git a/src/ldso/dlerror.c b/src/ldso/dlerror.c
index afe59253..4ff6285d 100644
--- a/src/ldso/dlerror.c
+++ b/src/ldso/dlerror.c
@@ -48,7 +48,7 @@ hidden void __dl_vseterr(const char *fmt, va_list ap)
 
 	while (q) {
 		void **p = *q;
-		free(q);
+		__libc_free(q);
 		q = p;
 	}
 
@@ -56,11 +56,11 @@ hidden void __dl_vseterr(const char *fmt, va_list ap)
 	va_copy(ap2, ap);
 	pthread_t self = __pthread_self();
 	if (self->dlerror_buf != (void *)-1)
-		free(self->dlerror_buf);
+		__libc_free(self->dlerror_buf);
 	size_t len = vsnprintf(0, 0, fmt, ap2);
 	if (len < sizeof(void *)) len = sizeof(void *);
 	va_end(ap2);
-	char *buf = malloc(len+1);
+	char *buf = __libc_malloc(len+1);
 	if (buf) {
 		vsnprintf(buf, len+1, fmt, ap);
 	} else {
diff --git a/src/ldso/riscv64/dlvsym.s b/src/ldso/riscv64/dlvsym.s
new file mode 100644
index 00000000..29d77c7e
--- /dev/null
+++ b/src/ldso/riscv64/dlvsym.s
@@ -0,0 +1,21 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+.global dlvsym
+.hidden __dlvsym
+.type dlvsym, %function
+dlvsym:
+	mv a3, ra
+	tail __dlvsym
diff --git a/src/ldso/x86_64/dlvsym.s b/src/ldso/x86_64/dlvsym.s
new file mode 100644
index 00000000..7c6ca459
--- /dev/null
+++ b/src/ldso/x86_64/dlvsym.s
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+.text
+.global dlvsym
+.hidden __dlvsym
+.type dlvsym,@function
+dlvsym:
+	mov (%rsp),%rcx
+	jmp __dlvsym
diff --git a/src/legacy/ulimit.c b/src/legacy/ulimit.c
index 1f59e8e6..d1620e6e 100644
--- a/src/legacy/ulimit.c
+++ b/src/legacy/ulimit.c
@@ -1,6 +1,7 @@
 #include <sys/resource.h>
 #include <ulimit.h>
 #include <stdarg.h>
+#include <limits.h>
 
 long ulimit(int cmd, ...)
 {
@@ -15,5 +16,5 @@ long ulimit(int cmd, ...)
 		rl.rlim_cur = 512ULL * val;
 		if (setrlimit(RLIMIT_FSIZE, &rl)) return -1;
 	}
-	return rl.rlim_cur / 512;
+	return rl.rlim_cur == RLIM_INFINITY? LONG_MAX : rl.rlim_cur / 512;
 }
diff --git a/src/linux/cache.c b/src/linux/cache.c
index 0eb051c2..c2782025 100644
--- a/src/linux/cache.c
+++ b/src/linux/cache.c
@@ -1,3 +1,17 @@
+/* Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *	 http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <errno.h>
 #include "syscall.h"
 #include "atomic.h"
@@ -27,7 +41,8 @@ static void *volatile vdso_func;
 
 static int flush_icache_init(void *start, void *end, unsigned long int flags)
 {
-	void *p = __vdsosym(VDSO_FLUSH_ICACHE_VER, VDSO_FLUSH_ICACHE_SYM);
+        __get_vdso_info();
+	void *p = __get_vdso_addr(VDSO_FLUSH_ICACHE_VER, VDSO_FLUSH_ICACHE_SYM);
 	int (*f)(void *, void *, unsigned long int) =
 		(int (*)(void *, void *, unsigned long int))p;
 	a_cas_p(&vdso_func, (void *)flush_icache_init, p);
diff --git a/src/linux/clone.c b/src/linux/clone.c
index 8c1af7d3..25482eed 100644
--- a/src/linux/clone.c
+++ b/src/linux/clone.c
@@ -2,14 +2,46 @@
 #include <stdarg.h>
 #include <unistd.h>
 #include <sched.h>
+#include <signal.h>
 #include "pthread_impl.h"
 #include "syscall.h"
+#include "libc.h"
+
+struct __clone_args {
+	int (*func)(void *);
+	void *arg;
+};
+
+static int __start_child(void *clone_args)
+{
+	int status;
+	sigset_t set;
+	int (*func)(void *) = ((struct __clone_args *)clone_args)->func;
+	void *arg = ((struct __clone_args *)clone_args)->arg;
+	free(clone_args);
+
+	__block_all_sigs(&set);
+	pthread_t self = __pthread_self();
+	self->tid = __syscall(SYS_gettid);
+	self->robust_list.off = 0;
+	self->robust_list.pending = 0;
+	self->next = self->prev = self;
+	__thread_list_lock = 0;
+	libc.threads_minus_1 = 0;
+	__restore_sigs(&set);
+
+	status = func(arg);
+	exit(status);
+}
 
 int clone(int (*func)(void *), void *stack, int flags, void *arg, ...)
 {
+	int ret;
 	va_list ap;
 	pid_t *ptid, *ctid;
 	void  *tls;
+	int (*clone_func)(void *) = func;
+	struct __clone_args *clone_args = (struct __clone_args *)arg;
 
 	va_start(ap, arg);
 	ptid = va_arg(ap, pid_t *);
@@ -17,5 +49,35 @@ int clone(int (*func)(void *), void *stack, int flags, void *arg, ...)
 	ctid = va_arg(ap, pid_t *);
 	va_end(ap);
 
-	return __syscall_ret(__clone(func, stack, flags, arg, ptid, tls, ctid));
+	pthread_t self = __pthread_self();
+	pid_t parent_pid = self->pid;
+	self->pid = 0;
+	pid_t caller_tid = self->tid;
+
+	if (!(flags & (CLONE_VM | CLONE_VFORK))) {
+		self->tid = -1;
+		if (func) {
+			clone_args = (struct __clone_args *)malloc(sizeof(struct __clone_args));
+			if (clone_args == NULL) {
+				errno = ENOMEM;
+				return -1;
+			}
+			clone_args->func = clone_func;
+			clone_args->arg = arg;
+			clone_func = __start_child;
+		}
+	}
+	ret = __syscall_ret(__clone(clone_func, stack, flags, (void *)clone_args, ptid, tls, ctid));
+	if (!(flags & (CLONE_VM | CLONE_VFORK)) && func) {
+		free(clone_args);
+	}
+
+	if (ret != 0) {
+		self->pid = parent_pid;
+		self->tid = caller_tid;
+	} else if (self->tid == -1) {
+		self->tid = __syscall(SYS_gettid);
+		self->pid = self->tid;
+	}
+	return ret;
 }
diff --git a/src/linux/prctl.c b/src/linux/prctl.c
index 19f4267c..9da27bb4 100644
--- a/src/linux/prctl.c
+++ b/src/linux/prctl.c
@@ -2,7 +2,15 @@
 #include <stdarg.h>
 #include "syscall.h"
 
+#ifdef HOOK_ENABLE
+int __libc_prctl(int op,  ...);
+#endif
+
+#ifdef HOOK_ENABLE
+int __libc_prctl(int op,  ...)
+#else
 int prctl(int op, ...)
+#endif
 {
 	unsigned long x[4];
 	int i;
diff --git a/src/linux/reboot.c b/src/linux/reboot.c
index 7f12af79..ed8c5a73 100644
--- a/src/linux/reboot.c
+++ b/src/linux/reboot.c
@@ -1,7 +1,23 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <sys/reboot.h>
 #include "syscall.h"
 
-int reboot(int type)
+int __reboot(int type)
 {
-	return syscall(SYS_reboot, 0xfee1dead, 672274793, type);
+    return syscall(SYS_reboot, RB_MAGIC1, RB_MAGIC2, type);
 }
+weak_alias(__reboot, reboot);
\ No newline at end of file
diff --git a/src/linux/tgkill.c b/src/linux/tgkill.c
new file mode 100644
index 00000000..b20efd93
--- /dev/null
+++ b/src/linux/tgkill.c
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <sys/tgkill.h>
+#include "syscall.h"
+
+int tgkill(int tgid, int tid, int sig)
+{
+    return syscall(__NR_tgkill, tgid, tid, sig);
+}
\ No newline at end of file
diff --git a/src/locale/c_locale.c b/src/locale/c_locale.c
index 77ccf587..582d0305 100644
--- a/src/locale/c_locale.c
+++ b/src/locale/c_locale.c
@@ -6,7 +6,8 @@ static const uint32_t empty_mo[] = { 0x950412de, 0, -1, -1, -1 };
 const struct __locale_map __c_dot_utf8 = {
 	.map = empty_mo,
 	.map_size = sizeof empty_mo,
-	.name = "C.UTF-8"
+	.name = "C.UTF-8",
+	.flag = VALID
 };
 
 const struct __locale_struct __c_locale = { 0 };
diff --git a/src/locale/dcngettext.c b/src/locale/dcngettext.c
index 0b53286d..68d2f10b 100644
--- a/src/locale/dcngettext.c
+++ b/src/locale/dcngettext.c
@@ -1,3 +1,18 @@
+/**
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <libintl.h>
 #include <stdlib.h>
 #include <string.h>
@@ -17,27 +32,32 @@
 #define realloc undef
 #define free undef
 
+#define __DIGIT_SEVEN__ 7
+#define __DIGIT_NINE__ 9
+#define __DIGIT_TEN__ 10
+#define __DIGIT_THIRTEEN__ 13
+
 struct binding {
-	struct binding *next;
-	int dirlen;
-	volatile int active;
-	char *domainname;
-	char *dirname;
-	char buf[];
+    struct binding *next;
+    int dirlen;
+    volatile int active;
+    char *domainname;
+    char *dirname;
+    char buf[];
 };
 
 static void *volatile bindings;
 
 static char *gettextdir(const char *domainname, size_t *dirlen)
 {
-	struct binding *p;
-	for (p=bindings; p; p=p->next) {
-		if (!strcmp(p->domainname, domainname) && p->active) {
-			*dirlen = p->dirlen;
-			return (char *)p->dirname;
-		}
-	}
-	return 0;
+    struct binding *p;
+    for (p=bindings; p; p=p->next) {
+        if (!strcmp(p->domainname, domainname) && p->active) {
+            *dirlen = p->dirlen;
+            return (char *)p->dirname;
+        }
+    }
+    return 0;
 }
 
 static volatile int lock[1];
@@ -45,239 +65,284 @@ volatile int *const __gettext_lockptr = lock;
 
 char *bindtextdomain(const char *domainname, const char *dirname)
 {
-	struct binding *p, *q;
-
-	if (!domainname) return 0;
-	if (!dirname) return gettextdir(domainname, &(size_t){0});
-
-	size_t domlen = strnlen(domainname, NAME_MAX+1);
-	size_t dirlen = strnlen(dirname, PATH_MAX);
-	if (domlen > NAME_MAX || dirlen >= PATH_MAX) {
-		errno = EINVAL;
-		return 0;
-	}
-
-	LOCK(lock);
-
-	for (p=bindings; p; p=p->next) {
-		if (!strcmp(p->domainname, domainname) &&
-		    !strcmp(p->dirname, dirname)) {
-			break;
-		}
-	}
-
-	if (!p) {
-		p = calloc(sizeof *p + domlen + dirlen + 2, 1);
-		if (!p) {
-			UNLOCK(lock);
-			return 0;
-		}
-		p->next = bindings;
-		p->dirlen = dirlen;
-		p->domainname = p->buf;
-		p->dirname = p->buf + domlen + 1;
-		memcpy(p->domainname, domainname, domlen+1);
-		memcpy(p->dirname, dirname, dirlen+1);
-		a_cas_p(&bindings, bindings, p);
-	}
-
-	a_store(&p->active, 1);
-
-	for (q=bindings; q; q=q->next) {
-		if (!strcmp(q->domainname, domainname) && q != p)
-			a_store(&q->active, 0);
-	}
-
-	UNLOCK(lock);
-	
-	return (char *)p->dirname;
+    struct binding *p, *q;
+
+    if (!domainname) {
+        return 0;
+    }
+    if (!dirname) {
+        return gettextdir(domainname, &(size_t){0});
+    }
+
+    size_t domlen = strnlen(domainname, NAME_MAX+1);
+    size_t dirlen = strnlen(dirname, PATH_MAX);
+    if (domlen > NAME_MAX || dirlen >= PATH_MAX) {
+        errno = EINVAL;
+        return 0;
+    }
+
+    LOCK(lock);
+
+    for (p=bindings; p; p=p->next) {
+        if (!strcmp(p->domainname, domainname) &&
+            !strcmp(p->dirname, dirname)) {
+            break;
+        }
+    }
+
+    if (!p) {
+        p = calloc(sizeof *p + domlen + dirlen + 2, 1);
+        if (!p) {
+            UNLOCK(lock);
+            return 0;
+        }
+        p->next = bindings;
+        p->dirlen = dirlen;
+        p->domainname = p->buf;
+        p->dirname = p->buf + domlen + 1;
+        memcpy(p->domainname, domainname, domlen+1);
+        memcpy(p->dirname, dirname, dirlen+1);
+        a_cas_p(&bindings, bindings, p);
+    }
+
+    a_store(&p->active, 1);
+
+    for (q=bindings; q; q=q->next) {
+        if (!strcmp(q->domainname, domainname) && q != p) {
+            a_store(&q->active, 0);
+        }
+    }
+
+    UNLOCK(lock);
+    
+    return (char *)p->dirname;
 }
 
-static const char catnames[][12] = {
-	"LC_CTYPE",
-	"LC_NUMERIC",
-	"LC_TIME",
-	"LC_COLLATE",
-	"LC_MONETARY",
-	"LC_MESSAGES",
+static const char catnames[][18] = {
+    "LC_CTYPE",
+    "LC_NUMERIC",
+    "LC_TIME",
+    "LC_COLLATE",
+    "LC_MONETARY",
+    "LC_MESSAGES",
+    "LC_PAPER",
+    "LC_NAME",
+    "LC_ADDRESS",
+    "LC_TELEPHONE",
+    "LC_MEASUREMENT",
+    "LC_IDENTIFICATION",
 };
 
-static const char catlens[] = { 8, 10, 7, 10, 11, 11 };
+static const char catlens[] = { 8, 10, 7, 10, 11, 11, 8, 7, 10, 12, 14, 17 };
 
 struct msgcat {
-	struct msgcat *next;
-	const void *map;
-	size_t map_size;
-	const char *plural_rule;
-	int nplurals;
-	struct binding *binding;
-	const struct __locale_map *lm;
-	int cat;
+    struct msgcat *next;
+    const void *map;
+    size_t map_size;
+    const char *plural_rule;
+    int nplurals;
+    struct binding *binding;
+    const struct __locale_map *lm;
+    int cat;
 };
 
 static char *dummy_gettextdomain()
 {
-	return "messages";
+    return "messages";
 }
 
 weak_alias(dummy_gettextdomain, __gettextdomain);
 
 char *dcngettext(const char *domainname, const char *msgid1, const char *msgid2, unsigned long int n, int category)
 {
-	static struct msgcat *volatile cats;
-	struct msgcat *p;
-	struct __locale_struct *loc = CURRENT_LOCALE;
-	const struct __locale_map *lm;
-	size_t domlen;
-	struct binding *q;
-	int old_errno = errno;
+    static struct msgcat *volatile cats;
+    struct msgcat *p;
+    struct __locale_struct *loc = CURRENT_LOCALE;
+    const struct __locale_map *lm;
+    size_t domlen;
+    struct binding *q;
+    int old_errno = errno;
 
 	/* match gnu gettext behaviour */
-	if (!msgid1) goto notrans;
-
-	if ((unsigned)category >= LC_ALL) goto notrans;
-
-	if (!domainname) domainname = __gettextdomain();
+    if (!msgid1) {
+        goto notrans;
+    }
 
-	domlen = strnlen(domainname, NAME_MAX+1);
-	if (domlen > NAME_MAX) goto notrans;
-
-	for (q=bindings; q; q=q->next)
-		if (!strcmp(q->domainname, domainname) && q->active)
-			break;
-	if (!q) goto notrans;
-
-	lm = loc->cat[category];
-	if (!lm) {
-notrans:
-		errno = old_errno;
-		return (char *) ((n == 1) ? msgid1 : msgid2);
+	if ((unsigned)category >= LC_ALL) { 
+		goto notrans;
 	}
-
-	for (p=cats; p; p=p->next)
-		if (p->binding == q && p->lm == lm && p->cat == category)
-			break;
-
-	if (!p) {
-		const char *dirname, *locname, *catname, *modname, *locp;
-		size_t dirlen, loclen, catlen, modlen, alt_modlen;
-		void *old_cats;
-		size_t map_size;
-
-		dirname = q->dirname;
-		locname = lm->name;
-		catname = catnames[category];
-
-		dirlen = q->dirlen;
-		loclen = strlen(locname);
-		catlen = catlens[category];
-
-		/* Logically split @mod suffix from locale name. */
-		modname = memchr(locname, '@', loclen);
-		if (!modname) modname = locname + loclen;
-		alt_modlen = modlen = loclen - (modname-locname);
-		loclen = modname-locname;
-
-		/* Drop .charset identifier; it is not used. */
-		const char *csp = memchr(locname, '.', loclen);
-		if (csp) loclen = csp-locname;
-
-		char name[dirlen+1 + loclen+modlen+1 + catlen+1 + domlen+3 + 1];
-		const void *map;
-
-		for (;;) {
-			snprintf(name, sizeof name, "%s/%.*s%.*s/%s/%s.mo\0",
-				dirname, (int)loclen, locname,
-				(int)alt_modlen, modname, catname, domainname);
-			if (map = __map_file(name, &map_size)) break;
-
-			/* Try dropping @mod, _YY, then both. */
-			if (alt_modlen) {
-				alt_modlen = 0;
-			} else if ((locp = memchr(locname, '_', loclen))) {
-				loclen = locp-locname;
-				alt_modlen = modlen;
-			} else {
-				break;
-			}
-		}
-		if (!map) goto notrans;
-
-		p = calloc(sizeof *p, 1);
-		if (!p) {
-			__munmap((void *)map, map_size);
-			goto notrans;
-		}
-		p->cat = category;
-		p->binding = q;
-		p->lm = lm;
-		p->map = map;
-		p->map_size = map_size;
-
-		const char *rule = "n!=1;";
-		unsigned long np = 2;
-		const char *r = __mo_lookup(p->map, p->map_size, "");
-		char *z;
-		while (r && strncmp(r, "Plural-Forms:", 13)) {
-			z = strchr(r, '\n');
-			r = z ? z+1 : 0;
-		}
-		if (r) {
-			r += 13;
-			while (isspace(*r)) r++;
-			if (!strncmp(r, "nplurals=", 9)) {
-				np = strtoul(r+9, &z, 10);
-				r = z;
-			}
-			while (*r && *r != ';') r++;
-			if (*r) {
-				r++;
-				while (isspace(*r)) r++;
-				if (!strncmp(r, "plural=", 7))
-					rule = r+7;
-			}
-		}
-		p->nplurals = np;
-		p->plural_rule = rule;
-
-		do {
-			old_cats = cats;
-			p->next = old_cats;
-		} while (a_cas_p(&cats, old_cats, p) != old_cats);
-	}
-
-	const char *trans = __mo_lookup(p->map, p->map_size, msgid1);
-	if (!trans) goto notrans;
-
-	/* Non-plural-processing gettext forms pass a null pointer as
-	 * msgid2 to request that dcngettext suppress plural processing. */
-
-	if (msgid2 && p->nplurals) {
-		unsigned long plural = __pleval(p->plural_rule, n);
-		if (plural > p->nplurals) goto notrans;
-		while (plural--) {
-			size_t rem = p->map_size - (trans - (char *)p->map);
-			size_t l = strnlen(trans, rem);
-			if (l+1 >= rem)
-				goto notrans;
-			trans += l+1;
-		}
-	}
-	errno = old_errno;
-	return (char *)trans;
+	
+    if (!domainname) {
+        domainname = __gettextdomain();
+    }
+
+    domlen = strnlen(domainname, NAME_MAX+1);
+    if (domlen > NAME_MAX) {
+        goto notrans;
+    }
+
+    for (q=bindings; q; q=q->next) {
+        if (!strcmp(q->domainname, domainname) && q->active) {
+            break;
+        }
+    }
+    if (!q) {
+        goto notrans;
+    }
+
+    lm = loc->cat[category];
+    if (!lm) {
+notrans:
+        errno = old_errno;
+        return (char *) ((n == 1) ? msgid1 : msgid2);
+    }
+
+    for (p=cats; p; p=p->next) {
+        if (p->binding == q && p->lm == lm && p->cat == category) {
+            break;
+        }
+    }
+
+    if (!p) {
+        const char *dirname, *locname, *catname, *modname, *locp;
+        size_t dirlen, loclen, catlen, modlen, alt_modlen;
+        void *old_cats;
+        size_t map_size;
+
+        dirname = q->dirname;
+        locname = lm->name;
+        catname = catnames[category];
+
+        dirlen = q->dirlen;
+        loclen = strlen(locname);
+        catlen = catlens[category];
+
+        /* Logically split @mod suffix from locale name. */
+        modname = memchr(locname, '@', loclen);
+        if (!modname) {
+            modname = locname + loclen;
+        }
+        alt_modlen = modlen = loclen - (modname-locname);
+        loclen = modname-locname;
+
+        /* Drop .charset identifier; it is not used. */
+        const char *csp = memchr(locname, '.', loclen);
+        if (csp) {
+            loclen = csp-locname;
+        }
+
+        char name[dirlen+1 + loclen+modlen+1 + catlen+1 + domlen+3 + 1];
+        const void *map;
+
+        for (;;) {
+            snprintf(name, sizeof name, "%s/%.*s%.*s/%s/%s.mo\0",
+                dirname, (int)loclen, locname,
+                (int)alt_modlen, modname, catname, domainname);
+            if (map = __map_file(name, &map_size)) {
+                break;
+            }
+
+            /* Try dropping @mod, _YY, then both. */
+            if (alt_modlen) {
+                alt_modlen = 0;
+            } else if ((locp = memchr(locname, '_', loclen))) {
+                loclen = locp-locname;
+                alt_modlen = modlen;
+            } else {
+                break;
+            }
+        }
+        if (!map) {
+            goto notrans;
+        }
+
+        p = calloc(sizeof *p, 1);
+        if (!p) {
+            __munmap((void *)map, map_size);
+            goto notrans;
+        }
+        p->cat = category;
+        p->binding = q;
+        p->lm = lm;
+        p->map = map;
+        p->map_size = map_size;
+
+        const char *rule = "n!=1;";
+        unsigned long np = 2;
+        const char *r = __mo_lookup(p->map, p->map_size, "");
+        char *z;
+        while (r && strncmp(r, "Plural-Forms:", __DIGIT_THIRTEEN__)) {
+            z = strchr(r, '\n');
+            r = z ? z+1 : 0;
+        }
+        if (r) {
+            r += __DIGIT_THIRTEEN__;
+            while (isspace(*r)) {
+                r++;
+            }
+            if (!strncmp(r, "nplurals=", __DIGIT_NINE__)) {
+                np = strtoul(r+__DIGIT_NINE__, &z, __DIGIT_TEN__);
+                r = z;
+            }
+            while (*r && *r != ';') {
+                r++;
+            }
+            if (*r) {
+                r++;
+                while (isspace(*r)) {
+                    r++;
+                }
+                if (!strncmp(r, "plural=", __DIGIT_SEVEN__)) {
+                    rule = r+__DIGIT_SEVEN__;
+                }
+            }
+        }
+        p->nplurals = np;
+        p->plural_rule = rule;
+
+        do {
+            old_cats = cats;
+            p->next = old_cats;
+        } while (a_cas_p(&cats, old_cats, p) != old_cats);
+    }
+
+    const char *trans = __mo_lookup(p->map, p->map_size, msgid1);
+    if (!trans) {
+        goto notrans;
+    }
+
+    /* Non-plural-processing gettext forms pass a null pointer as
+     * msgid2 to request that dcngettext suppress plural processing. */
+
+    if (msgid2 && p->nplurals) {
+        unsigned long plural = __pleval(p->plural_rule, n);
+        if (plural > p->nplurals) {
+            goto notrans;
+        }
+        while (plural--) {
+            size_t rem = p->map_size - (trans - (char *)p->map);
+            size_t l = strnlen(trans, rem);
+            if (l+1 >= rem) {
+                goto notrans;
+            }
+            trans += l+1;
+        }
+    }
+    errno = old_errno;
+    return (char *)trans;
 }
 
 char *dcgettext(const char *domainname, const char *msgid, int category)
 {
-	return dcngettext(domainname, msgid, 0, 1, category);
+    return dcngettext(domainname, msgid, 0, 1, category);
 }
 
 char *dngettext(const char *domainname, const char *msgid1, const char *msgid2, unsigned long int n)
 {
-	return dcngettext(domainname, msgid1, msgid2, n, LC_MESSAGES);
+    return dcngettext(domainname, msgid1, msgid2, n, LC_MESSAGES);
 }
 
 char *dgettext(const char *domainname, const char *msgid)
 {
-	return dcngettext(domainname, msgid, 0, 1, LC_MESSAGES);
+    return dcngettext(domainname, msgid, 0, 1, LC_MESSAGES);
 }
diff --git a/src/locale/langinfo.c b/src/locale/langinfo.c
index 14773093..71711492 100644
--- a/src/locale/langinfo.c
+++ b/src/locale/langinfo.c
@@ -1,72 +1,102 @@
+/**
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <locale.h>
 #include <langinfo.h>
 #include "locale_impl.h"
 
+#define __INDEX_THREE__ 3
+
 static const char c_time[] =
-	"Sun\0" "Mon\0" "Tue\0" "Wed\0" "Thu\0" "Fri\0" "Sat\0"
-	"Sunday\0" "Monday\0" "Tuesday\0" "Wednesday\0"
-	"Thursday\0" "Friday\0" "Saturday\0"
-	"Jan\0" "Feb\0" "Mar\0" "Apr\0" "May\0" "Jun\0"
-	"Jul\0" "Aug\0" "Sep\0" "Oct\0" "Nov\0" "Dec\0"
-	"January\0"   "February\0" "March\0"    "April\0"
-	"May\0"       "June\0"     "July\0"     "August\0"
-	"September\0" "October\0"  "November\0" "December\0"
-	"AM\0" "PM\0"
-	"%a %b %e %T %Y\0"
-	"%m/%d/%y\0"
-	"%H:%M:%S\0"
-	"%I:%M:%S %p\0"
-	"\0"
-	"\0"
-	"%m/%d/%y\0"
-	"0123456789\0"
-	"%a %b %e %T %Y\0"
-	"%H:%M:%S";
+    "Sun\0" "Mon\0" "Tue\0" "Wed\0" "Thu\0" "Fri\0" "Sat\0"
+    "Sunday\0" "Monday\0" "Tuesday\0" "Wednesday\0"
+    "Thursday\0" "Friday\0" "Saturday\0"
+    "Jan\0" "Feb\0" "Mar\0" "Apr\0" "May\0" "Jun\0"
+    "Jul\0" "Aug\0" "Sep\0" "Oct\0" "Nov\0" "Dec\0"
+    "January\0"   "February\0" "March\0"    "April\0"
+    "May\0"       "June\0"     "July\0"     "August\0"
+    "September\0" "October\0"  "November\0" "December\0"
+    "AM\0" "PM\0"
+    "%a %b %e %T %Y\0"
+    "%m/%d/%y\0"
+    "%H:%M:%S\0"
+    "%I:%M:%S %p\0"
+    "\0"
+    "\0"
+    "%m/%d/%y\0"
+    "0123456789\0"
+    "%a %b %e %T %Y\0"
+    "%H:%M:%S\0"
+    "am\0" "pm";
 
 static const char c_messages[] = "^[yY]\0" "^[nN]\0" "yes\0" "no";
 static const char c_numeric[] = ".\0" "";
 
 char *__nl_langinfo_l(nl_item item, locale_t loc)
 {
-	int cat = item >> 16;
-	int idx = item & 65535;
-	const char *str;
+    int cat = item >> 16;
+    int idx = item & 65535;
+    const char *str;
 
-	if (item == CODESET) return loc->cat[LC_CTYPE] ? "UTF-8" : "ASCII";
+    if (item == CODESET) return loc->cat[LC_CTYPE] ? "UTF-8" : "ASCII";
 
-	/* _NL_LOCALE_NAME extension */
-	if (idx == 65535 && cat < LC_ALL)
-		return loc->cat[cat] ? (char *)loc->cat[cat]->name : "C";
-	
-	switch (cat) {
-	case LC_NUMERIC:
-		if (idx > 1) return "";
-		str = c_numeric;
-		break;
-	case LC_TIME:
-		if (idx > 0x31) return "";
-		str = c_time;
-		break;
-	case LC_MONETARY:
-		if (idx > 0) return "";
-		str = "";
-		break;
-	case LC_MESSAGES:
-		if (idx > 3) return "";
-		str = c_messages;
-		break;
-	default:
-		return "";
-	}
+    /* _NL_LOCALE_NAME extension */
+    if (idx == 65535 && cat < LC_ALL)
+        return loc->cat[cat] ? (char *)loc->cat[cat]->name : "C";
+    
+    switch (cat) {
+        case LC_NUMERIC:
+            if (idx > 1) {
+                return "";
+            }
+            str = c_numeric;
+            break;
+        case LC_TIME:
+            if (idx > 0x33) {
+                return "";
+            }
+            str = c_time;
+            break;
+        case LC_MONETARY:
+            if (idx > 0) {
+                return "";
+            }
+            str = "";
+            break;
+        case LC_MESSAGES:
+            if (idx > __INDEX_THREE__) {
+                return "";
+            }
+            str = c_messages;
+            break;
+        default:
+            return "";
+    }
 
-	for (; idx; idx--, str++) for (; *str; str++);
-	if (cat != LC_NUMERIC && *str) str = LCTRANS(str, cat, loc);
-	return (char *)str;
+    for (; idx; idx--, str++) {
+        for (; *str; str++);
+    }
+    if (cat != LC_NUMERIC && *str) {
+        str = LCTRANS(str, cat, loc);
+    }
+    return (char *)str;
 }
 
 char *__nl_langinfo(nl_item item)
 {
-	return __nl_langinfo_l(item, CURRENT_LOCALE);
+    return __nl_langinfo_l(item, CURRENT_LOCALE);
 }
 
 weak_alias(__nl_langinfo, nl_langinfo);
diff --git a/src/locale/locale_map.c b/src/locale/locale_map.c
index da61f7fc..b2f9fc28 100644
--- a/src/locale/locale_map.c
+++ b/src/locale/locale_map.c
@@ -1,3 +1,18 @@
+/**
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <locale.h>
 #include <string.h>
 #include <sys/mman.h>
@@ -19,13 +34,19 @@ const char *__lctrans_impl(const char *msg, const struct __locale_map *lm)
 	return trans ? trans : msg;
 }
 
-static const char envvars[][12] = {
+static const char envvars[][18] = {
 	"LC_CTYPE",
 	"LC_NUMERIC",
 	"LC_TIME",
 	"LC_COLLATE",
 	"LC_MONETARY",
 	"LC_MESSAGES",
+	"LC_PAPER",
+	"LC_NAME",
+	"LC_ADDRESS",
+	"LC_TELEPHONE",
+	"LC_MEASUREMENT",
+	"LC_IDENTIFICATION",
 };
 
 volatile int __locale_lock[1];
@@ -49,27 +70,51 @@ const struct __locale_map *__get_locale(int cat, const char *val)
 
 	/* Limit name length and forbid leading dot or any slashes. */
 	for (n=0; n<LOCALE_NAME_MAX && val[n] && val[n]!='/'; n++);
-	if (val[0]=='.' || val[n]) val = "C.UTF-8";
+	if (val[0]=='.' || val[n]) {
+		val = "C.UTF-8";
+	}
 	int builtin = (val[0]=='C' && !val[1])
-		|| !strcmp(val, "C.UTF-8")
-		|| !strcmp(val, "POSIX");
+		|| !strcmp(val, "POSIX")
+		|| !strcmp(val, "en_US");
 
 	if (builtin) {
-		if (cat == LC_CTYPE && val[1]=='.')
+		if (cat == LC_CTYPE && val[1] == '.')
 			return (void *)&__c_dot_utf8;
 		return 0;
 	}
 
-	for (p=loc_head; p; p=p->next)
-		if (!strcmp(val, p->name)) return p;
+	for (p=loc_head; p; p=p->next) {
+		if (!strcmp(val, p->name)) {
+			return p;
+		}
+	}
+
+	if (!strcmp(val, "en_US.UTF-8") || !strcmp(val, "C.UTF-8")) {
+		/* If no locale definition was found, make a locale map
+		* object anyway to store the name, which is kept for the
+		* sake of being able to do message translations at the
+		* application level. */
+		if (!new && (new = malloc(sizeof *new))) {
+			new->map = __c_dot_utf8.map;
+			new->map_size = __c_dot_utf8.map_size;
+			memcpy(new->name, val, n);
+			new->name[n] = 0;
+			new->next = loc_head;
+			new->flag = VALID;
+			loc_head = new;
+		}
+	}
 
-	if (!libc.secure) path = getenv("MUSL_LOCPATH");
-	/* FIXME: add a default path? */
+	if (!libc.secure) {
+		path = getenv("MUSL_LOCPATH");
+	}
 
 	if (path) for (; *path; path=z+!!*z) {
 		z = __strchrnul(path, ':');
 		l = z - path;
-		if (l >= sizeof buf - n - 2) continue;
+		if (l >= sizeof buf - n - 2) {
+			continue;
+		}
 		memcpy(buf, path, l);
 		buf[l] = '/';
 		memcpy(buf+l+1, val, n);
@@ -87,10 +132,12 @@ const struct __locale_map *__get_locale(int cat, const char *val)
 			memcpy(new->name, val, n);
 			new->name[n] = 0;
 			new->next = loc_head;
+			new->flag = VALID;
 			loc_head = new;
 			break;
 		}
 	}
+	
 
 	/* If no locale definition was found, make a locale map
 	 * object anyway to store the name, which is kept for the
@@ -102,6 +149,7 @@ const struct __locale_map *__get_locale(int cat, const char *val)
 		memcpy(new->name, val, n);
 		new->name[n] = 0;
 		new->next = loc_head;
+		new->flag = INVALID;
 		loc_head = new;
 	}
 
@@ -111,3 +159,4 @@ const struct __locale_map *__get_locale(int cat, const char *val)
 
 	return new;
 }
+
diff --git a/src/locale/newlocale.c b/src/locale/newlocale.c
index 9ac3cd38..451e593f 100644
--- a/src/locale/newlocale.c
+++ b/src/locale/newlocale.c
@@ -25,7 +25,7 @@ static locale_t do_newlocale(int mask, const char *name, locale_t loc)
 	for (int i=0; i<LC_ALL; i++) {
 		tmp.cat[i] = (!(mask & (1<<i)) && loc) ? loc->cat[i] :
 			__get_locale(i, (mask & (1<<i)) ? name : "");
-		if (tmp.cat[i] == LOC_MAP_FAILED)
+		if (tmp.cat[i] == LOC_MAP_FAILED || tmp.cat[i] && tmp.cat[i]->flag == INVALID)
 			return 0;
 	}
 
diff --git a/src/locale/setlocale.c b/src/locale/setlocale.c
index 360c4437..04a22d83 100644
--- a/src/locale/setlocale.c
+++ b/src/locale/setlocale.c
@@ -7,10 +7,18 @@
 
 static char buf[LC_ALL*(LOCALE_NAME_MAX+1)];
 
+static inline int Fresh(struct __locale_map *lm)
+{
+	if (lm != NULL) {
+		return lm->flag;
+	}
+	return VALID;
+}
+
 char *setlocale(int cat, const char *name)
 {
 	const struct __locale_map *lm;
-
+	char flag = VALID;
 	if ((unsigned)cat > LC_ALL) return 0;
 
 	LOCK(__locale_lock);
@@ -38,6 +46,9 @@ char *setlocale(int cat, const char *name)
 					UNLOCK(__locale_lock);
 					return 0;
 				}
+				if(Fresh(lm) == INVALID) {
+					flag = INVALID;
+				}
 				tmp_locale.cat[i] = lm;
 			}
 			libc.global_locale = tmp_locale;
@@ -57,6 +68,9 @@ char *setlocale(int cat, const char *name)
 		}
 		*--s = 0;
 		UNLOCK(__locale_lock);
+		if (flag == INVALID) {
+			return 0;
+		}
 		return same==LC_ALL ? (char *)part : buf;
 	}
 
@@ -66,6 +80,7 @@ char *setlocale(int cat, const char *name)
 			UNLOCK(__locale_lock);
 			return 0;
 		}
+		flag = Fresh(lm);
 		libc.global_locale.cat[cat] = lm;
 	} else {
 		lm = libc.global_locale.cat[cat];
@@ -73,6 +88,8 @@ char *setlocale(int cat, const char *name)
 	char *ret = lm ? (char *)lm->name : "C";
 
 	UNLOCK(__locale_lock);
-
+	if (flag == INVALID) {
+		return 0;
+	}
 	return ret;
 }
diff --git a/src/malloc/calloc.c b/src/malloc/calloc.c
index bf6bddca..67fceb91 100644
--- a/src/malloc/calloc.c
+++ b/src/malloc/calloc.c
@@ -1,45 +1,14 @@
+#ifndef HOOK_ENABLE
 #include <stdlib.h>
-#include <stdint.h>
-#include <string.h>
-#include <errno.h>
-#include "dynlink.h"
-
-static size_t mal0_clear(char *p, size_t n)
-{
-	const size_t pagesz = 4096; /* arbitrary */
-	if (n < pagesz) return n;
-#ifdef __GNUC__
-	typedef uint64_t __attribute__((__may_alias__)) T;
-#else
-	typedef unsigned char T;
+#ifdef USE_JEMALLOC
+extern void* je_calloc(void* p, size_t newsize);
 #endif
-	char *pp = p + n;
-	size_t i = (uintptr_t)pp & (pagesz - 1);
-	for (;;) {
-		pp = memset(pp - i, 0, i);
-		if (pp - p < pagesz) return pp - p;
-		for (i = pagesz; i; i -= 2*sizeof(T), pp -= 2*sizeof(T))
-		        if (((T *)pp)[-1] | ((T *)pp)[-2])
-				break;
-	}
-}
-
-static int allzerop(void *p)
-{
-	return 0;
-}
-weak_alias(allzerop, __malloc_allzerop);
 
 void *calloc(size_t m, size_t n)
 {
-	if (n && m > (size_t)-1/n) {
-		errno = ENOMEM;
-		return 0;
-	}
-	n *= m;
-	void *p = malloc(n);
-	if (!p || (!__malloc_replaced && __malloc_allzerop(p)))
-		return p;
-	n = mal0_clear(p, n);
-	return memset(p, 0, n);
+#ifdef USE_JEMALLOC
+	return je_calloc(m, n);
+#endif
+    return __libc_calloc(m, n);
 }
+#endif
\ No newline at end of file
diff --git a/src/malloc/free.c b/src/malloc/free.c
index 3944f7b2..18ba5ad5 100644
--- a/src/malloc/free.c
+++ b/src/malloc/free.c
@@ -1,6 +1,15 @@
+#ifndef HOOK_ENABLE
 #include <stdlib.h>
 
+#ifdef USE_JEMALLOC
+extern void je_free(void* p);
+#endif
+
 void free(void *p)
 {
+#ifdef USE_JEMALLOC
+	return je_free(p);
+#endif
 	__libc_free(p);
 }
+#endif
\ No newline at end of file
diff --git a/src/malloc/jemalloc/jemalloc.c b/src/malloc/jemalloc/jemalloc.c
new file mode 100644
index 00000000..2bcee879
--- /dev/null
+++ b/src/malloc/jemalloc/jemalloc.c
@@ -0,0 +1 @@
+#include "jemalloc/src/static.c"
diff --git a/src/malloc/libc_calloc.c b/src/malloc/libc_calloc.c
index d25eabea..1d07bd34 100644
--- a/src/malloc/libc_calloc.c
+++ b/src/malloc/libc_calloc.c
@@ -1,4 +1,61 @@
-#define calloc __libc_calloc
-#define malloc __libc_malloc
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <errno.h>
+#include "dynlink.h"
 
-#include "calloc.c"
+static size_t mal0_clear(char *p, size_t n)
+{
+	const size_t pagesz = 4096; /* arbitrary */
+	if (n < pagesz) return n;
+#ifdef __GNUC__
+	typedef uint64_t __attribute__((__may_alias__)) T;
+#else
+	typedef unsigned char T;
+#endif
+	char *pp = p + n;
+	size_t i = (uintptr_t)pp & (pagesz - 1);
+	for (;;) {
+		pp = memset(pp - i, 0, i);
+		if (pp - p < pagesz) return pp - p;
+		for (i = pagesz; i; i -= 2*sizeof(T), pp -= 2*sizeof(T))
+		        if (((T *)pp)[-1] | ((T *)pp)[-2])
+				break;
+	}
+}
+
+static int allzerop(void *p)
+{
+	return 0;
+}
+weak_alias(allzerop, __malloc_allzerop);
+
+void *__libc_calloc(size_t m, size_t n)
+{
+	if (n && m > (size_t)-1/n) {
+		errno = ENOMEM;
+		return 0;
+	}
+	n *= m;
+	void *p = __libc_malloc(n);
+	if (!p || (!__malloc_replaced && __malloc_allzerop(p)))
+		return p;
+	n = mal0_clear(p, n);
+	return memset(p, 0, n);
+}
+
+#ifdef HOOK_ENABLE
+void *hook_calloc(size_t m, size_t n)
+{
+	if (n && m > (size_t)-1/n) {
+		errno = ENOMEM;
+		return 0;
+	}
+	n *= m;
+	void *p = malloc(n);
+	if (!p || (!__malloc_replaced && __malloc_allzerop(p)))
+		return p;
+	n = mal0_clear(p, n);
+	return memset(p, 0, n);
+}
+#endif
\ No newline at end of file
diff --git a/src/malloc/lite_malloc.c b/src/malloc/lite_malloc.c
index 43a988fb..fcb5b643 100644
--- a/src/malloc/lite_malloc.c
+++ b/src/malloc/lite_malloc.c
@@ -8,6 +8,10 @@
 #include "syscall.h"
 #include "fork_impl.h"
 
+#ifdef USE_JEMALLOC
+extern void* je_malloc(size_t size);
+#endif
+
 #define ALIGN 16
 
 /* This function returns true if the interval [old,new]
@@ -112,6 +116,9 @@ void *__libc_malloc(size_t n)
 
 static void *default_malloc(size_t n)
 {
+#ifdef USE_JEMALLOC
+	return je_malloc(n);
+#endif
 	return __libc_malloc_impl(n);
 }
 
diff --git a/src/malloc/mallocng/aligned_alloc.c b/src/malloc/mallocng/aligned_alloc.c
index e0862a83..ac5847e1 100644
--- a/src/malloc/mallocng/aligned_alloc.c
+++ b/src/malloc/mallocng/aligned_alloc.c
@@ -2,8 +2,15 @@
 #include <errno.h>
 #include "meta.h"
 
+#ifdef USE_JEMALLOC
+extern void* je_memalign(size_t align, size_t len);
+#endif
+
 void *aligned_alloc(size_t align, size_t len)
 {
+#ifdef USE_JEMALLOC
+	return je_memalign(align, len);
+#endif
 	if ((align & -align) != align) {
 		errno = EINVAL;
 		return 0;
diff --git a/src/malloc/mallocng/donate.c b/src/malloc/mallocng/donate.c
index 41d850f3..7c5a2847 100644
--- a/src/malloc/mallocng/donate.c
+++ b/src/malloc/mallocng/donate.c
@@ -20,7 +20,7 @@ static void donate(unsigned char *base, size_t len)
 		m->avail_mask = 0;
 		m->freed_mask = 1;
 		m->mem = (void *)a;
-		m->mem->meta = m;
+		m->mem->meta = encode_ptr(m, ctx.secret);
 		m->last_idx = 0;
 		m->freeable = 0;
 		m->sizeclass = sc;
diff --git a/src/malloc/mallocng/malloc.c b/src/malloc/mallocng/malloc.c
index d695ab8e..e79e3cbd 100644
--- a/src/malloc/mallocng/malloc.c
+++ b/src/malloc/mallocng/malloc.c
@@ -3,10 +3,67 @@
 #include <limits.h>
 #include <string.h>
 #include <sys/mman.h>
+#include <sys/prctl.h>
 #include <errno.h>
 
 #include "meta.h"
 
+#ifdef USE_JEMALLOC
+#ifdef USE_JEMALLOC_DFX_INTF
+extern void je_malloc_disable();
+extern void je_malloc_enable();
+extern int je_iterate(uintptr_t base, size_t size,
+	void (*callback)(uintptr_t ptr, size_t size, void* arg), void* arg);
+extern int je_mallopt(int param, int value);
+#endif
+#endif
+
+#ifdef MALLOC_SECURE_ALL
+#include <fcntl.h>
+#define RANDOM_BUFFER_LEN 512
+static uint8_t buffer[RANDOM_BUFFER_LEN] = { 0 };
+static size_t ri = RANDOM_BUFFER_LEN;
+
+static uint8_t get_random8()
+{
+	uint8_t num;
+	if ((ri >= RANDOM_BUFFER_LEN) || (buffer[0] == 0)) {
+		int fd = open("/dev/urandom", O_RDONLY);
+		if (fd < 0) {
+			num = (uint8_t)get_random_secret();
+			return num;
+		}
+
+		read(fd, buffer, RANDOM_BUFFER_LEN);
+		close(fd);
+		ri = 0;
+	}
+	num = buffer[ri];
+	ri++;
+	return num;
+}
+
+static int get_randomIdx(int avail_mask, int last_idx)
+{
+	uint32_t mask;
+	uint32_t r;
+	uint32_t cmask;
+	int idx;
+
+	mask = avail_mask;
+	r = get_random8() % last_idx;
+	cmask = ~((2u << (last_idx - r)) - 1);
+
+	if (mask & cmask) {
+		idx = 31 - a_clz_32(mask & cmask);
+	} else {
+		idx = a_ctz_32(mask);
+	}
+
+	return idx;
+}
+#endif
+
 LOCK_OBJ_DEF;
 
 const uint16_t size_classes[] = {
@@ -69,6 +126,7 @@ struct meta *alloc_meta(void)
 			if (brk(new) != new) {
 				ctx.brk = -1;
 			} else {
+				prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, ctx.brk, new - ctx.brk, "native_heap:meta");
 				if (need_guard) mmap((void *)ctx.brk, pagesize,
 					PROT_NONE, MAP_ANON|MAP_PRIVATE|MAP_FIXED, -1, 0);
 				ctx.brk = new;
@@ -164,7 +222,13 @@ static uint32_t try_avail(struct meta **pm)
 		assert(mask);
 		decay_bounces(m->sizeclass);
 	}
+
+#ifdef MALLOC_SECURE_ALL
+	int idx = get_randomIdx(mask, m->last_idx);
+	first = 1 << idx;
+#else
 	first = mask&-mask;
+#endif
 	m->avail_mask = mask-first;
 	return first;
 }
@@ -251,6 +315,7 @@ static struct meta *alloc_group(int sc, size_t req)
 			free_meta(m);
 			return 0;
 		}
+		prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, p, needed, "native_heap:brk");
 		m->maplen = needed>>12;
 		ctx.mmap_counter++;
 		active_idx = (4096-UNIT)/size-1;
@@ -275,7 +340,7 @@ static struct meta *alloc_group(int sc, size_t req)
 	m->avail_mask = (2u<<active_idx)-1;
 	m->freed_mask = (2u<<(cnt-1))-1 - m->avail_mask;
 	m->mem = (void *)p;
-	m->mem->meta = m;
+	m->mem->meta = encode_ptr(m, ctx.secret);
 	m->mem->active_idx = active_idx;
 	m->last_idx = cnt-1;
 	m->freeable = 1;
@@ -311,6 +376,7 @@ void *malloc(size_t n)
 			MAP_PRIVATE|MAP_ANON, -1, 0);
 		if (p==MAP_FAILED) return 0;
 		wrlock();
+		prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, p, needed, "native_heap:mmap");
 		step_seq();
 		g = alloc_meta();
 		if (!g) {
@@ -319,7 +385,7 @@ void *malloc(size_t n)
 			return 0;
 		}
 		g->mem = p;
-		g->mem->meta = g;
+		g->mem->meta = encode_ptr(g, ctx.secret);
 		g->last_idx = 0;
 		g->freeable = 1;
 		g->sizeclass = 63;
@@ -355,6 +421,16 @@ void *malloc(size_t n)
 
 	for (;;) {
 		mask = g ? g->avail_mask : 0;
+#ifdef MALLOC_SECURE_ALL
+		if (!mask) break;
+		idx = get_randomIdx(mask, g->last_idx);
+		first = 1u << idx;
+
+		if (RDLOCK_IS_EXCLUSIVE || !MT)
+			g->avail_mask = mask-first;
+		else if (a_cas(&g->avail_mask, mask, mask-first)!=mask)
+			continue;
+#else
 		first = mask&-mask;
 		if (!first) break;
 		if (RDLOCK_IS_EXCLUSIVE || !MT)
@@ -362,6 +438,7 @@ void *malloc(size_t n)
 		else if (a_cas(&g->avail_mask, mask, mask-first)!=mask)
 			continue;
 		idx = a_ctz_32(first);
+#endif
 		goto success;
 	}
 	upgradelock();
@@ -385,3 +462,38 @@ int is_allzero(void *p)
 	return g->sizeclass >= 48 ||
 		get_stride(g) < UNIT*size_classes[g->sizeclass];
 }
+
+int mallopt(int param, int value)
+{
+#ifdef USE_JEMALLOC_DFX_INTF
+	return je_mallopt(param, value);
+#endif
+	return 0;
+}
+
+void malloc_disable(void)
+{
+#ifdef USE_JEMALLOC_DFX_INTF
+	je_malloc_disable();
+#endif
+}
+
+void malloc_enable(void)
+{
+#ifdef USE_JEMALLOC_DFX_INTF
+	je_malloc_enable();
+#endif
+}
+
+int malloc_iterate(void* base, size_t size, void (*callback)(void* base, size_t size, void* arg), void* arg)
+{
+#ifdef USE_JEMALLOC_DFX_INTF
+	return je_iterate(base, size, callback, arg);
+#endif
+	return 0;
+}
+
+ssize_t malloc_backtrace(void* pointer, uintptr_t* frames, size_t frame_count)
+{
+	return 0;
+}
diff --git a/src/malloc/mallocng/malloc_usable_size.c b/src/malloc/mallocng/malloc_usable_size.c
index ce6a960c..04ba9790 100644
--- a/src/malloc/mallocng/malloc_usable_size.c
+++ b/src/malloc/mallocng/malloc_usable_size.c
@@ -1,8 +1,18 @@
 #include <stdlib.h>
 #include "meta.h"
 
+#ifdef USE_JEMALLOC
+extern size_t je_malloc_usable_size(void *p);
+#endif
+#ifndef HOOK_ENABLE
 size_t malloc_usable_size(void *p)
+#else
+size_t __libc_malloc_usable_size(void *p)
+#endif
 {
+#ifdef USE_JEMALLOC
+	return je_malloc_usable_size(p);
+#endif
 	if (!p) return 0;
 	struct meta *g = get_meta(p);
 	int idx = get_slot_index(p);
diff --git a/src/malloc/mallocng/meta.h b/src/malloc/mallocng/meta.h
index 61ec53f9..1eb0e320 100644
--- a/src/malloc/mallocng/meta.h
+++ b/src/malloc/mallocng/meta.h
@@ -72,12 +72,27 @@ struct meta *alloc_meta(void);
 __attribute__((__visibility__("hidden")))
 int is_allzero(void *);
 
+static inline void *encode_ptr(void *ptr, uint64_t key)
+{
+#ifdef MALLOC_FREELIST_HARDENED
+	return (void *)((uintptr_t)ptr ^ key);
+#else
+	(void)key;
+	return ptr;
+#endif
+}
+
 static inline void queue(struct meta **phead, struct meta *m)
 {
 	assert(!m->next);
 	assert(!m->prev);
 	if (*phead) {
 		struct meta *head = *phead;
+#ifdef MALLOC_FREELIST_HARDENED
+		if (head->next->prev != head || head->prev->next != head) {
+			a_crash();
+		}
+#endif
 		m->next = head;
 		m->prev = head->prev;
 		m->next->prev = m->prev->next = m;
@@ -137,7 +152,7 @@ static inline struct meta *get_meta(const unsigned char *p)
 		assert(offset > 0xffff);
 	}
 	const struct group *base = (const void *)(p - UNIT*offset - UNIT);
-	const struct meta *meta = base->meta;
+	const struct meta *meta = encode_ptr(base->meta, ctx.secret);
 	assert(meta->mem == base);
 	assert(index <= meta->last_idx);
 	assert(!(meta->avail_mask & (1u<<index)));
diff --git a/src/malloc/realloc.c b/src/malloc/realloc.c
index fb0e8b7c..74b32be8 100644
--- a/src/malloc/realloc.c
+++ b/src/malloc/realloc.c
@@ -1,6 +1,15 @@
+#ifndef HOOK_ENABLE
 #include <stdlib.h>
 
+#ifdef USE_JEMALLOC
+extern void* je_realloc(void* p, size_t newsize);
+#endif
+
 void *realloc(void *p, size_t n)
 {
+#ifdef USE_JEMALLOC
+	return je_realloc(p, n);
+#endif
 	return __libc_realloc(p, n);
 }
+#endif
diff --git a/src/malloc/stats.c b/src/malloc/stats.c
new file mode 100644
index 00000000..03519710
--- /dev/null
+++ b/src/malloc/stats.c
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdarg.h>
+#include <malloc.h>
+#include <errno.h>
+#include <string.h>
+#include "pthread_impl.h"
+
+int malloc_info(int options, FILE* fp)
+{
+	return 0;
+}
+
+#ifdef USE_JEMALLOC_DFX_INTF
+extern struct mallinfo je_mallinfo();
+extern void je_malloc_stats_print(void (*write_cb)(void *, const char *), void *cbopaque,
+	const char *opts);
+#endif
+
+void malloc_stats_print(void (*write_cb) (void *, const char *), void *cbopaque, const char *opts)
+{
+#ifdef USE_JEMALLOC_DFX_INTF
+	je_malloc_stats_print(write_cb, cbopaque, opts);
+#endif
+}
+
+struct mallinfo2 mallinfo2(void)
+{
+#ifdef USE_JEMALLOC_DFX_INTF
+	struct mallinfo info = je_mallinfo();
+	struct mallinfo2 res = {
+		.hblks = info.hblks,
+		.hblkhd = info.hblkhd,
+		.usmblks = info.usmblks,
+		.uordblks = info.uordblks,
+		.fordblks = info.fordblks,
+	};
+	return res;
+#endif
+	return (struct mallinfo2){};
+}
+
+struct mallinfo mallinfo(void)
+{
+	struct mallinfo2 mallinfo2_res = mallinfo2();
+	return (struct mallinfo) {
+		.hblks = mallinfo2_res.hblks,
+		.hblkhd = mallinfo2_res.hblkhd,
+		.uordblks = mallinfo2_res.uordblks,
+		.fordblks = mallinfo2_res.fordblks,
+	};
+}
\ No newline at end of file
diff --git a/src/misc/aarch64/syscall.s b/src/misc/aarch64/syscall.s
new file mode 100644
index 00000000..b612ce54
--- /dev/null
+++ b/src/misc/aarch64/syscall.s
@@ -0,0 +1,13 @@
+.hidden __syscall_ret
+.global syscall
+.type syscall,%function
+syscall:
+	mov x8,x0
+	mov x0,x1
+	mov x1,x2
+	mov x2,x3
+	mov x3,x4
+	mov x4,x5
+	mov x5,x6
+	svc #0
+	b __syscall_ret
\ No newline at end of file
diff --git a/src/mq/mq_notify.c b/src/mq/mq_notify.c
index 221591c7..aca2f9ce 100644
--- a/src/mq/mq_notify.c
+++ b/src/mq/mq_notify.c
@@ -5,6 +5,7 @@
 #include <signal.h>
 #include <unistd.h>
 #include "syscall.h"
+#include "pthread_impl.h"
 
 struct args {
 	pthread_barrier_t barrier;
@@ -64,7 +65,11 @@ int mq_notify(mqd_t mqd, const struct sigevent *sev)
 	sev2.sigev_value.sival_ptr = (void *)&zeros;
 
 	if (syscall(SYS_mq_notify, mqd, &sev2) < 0) {
+#ifdef FEATURE_PTHREAD_CANCEL
 		pthread_cancel(td);
+#else
+		__syscall(SYS_tkill, td->tid, SIGCANCEL);
+#endif
 		__syscall(SYS_close, s);
 		return -1;
 	}
diff --git a/src/network/getnameinfo.c b/src/network/getnameinfo.c
index 949e1811..fe32156b 100644
--- a/src/network/getnameinfo.c
+++ b/src/network/getnameinfo.c
@@ -14,6 +14,12 @@
 
 #define PTR_MAX (64 + sizeof ".in-addr.arpa")
 #define RR_PTR 12
+#define BREAK 0
+#define CONTINUE 1
+#define FIXED_HOSTS_MAX_LENGTH 2
+#define FIXED_HOSTS_STR_MAX_LENGTH 23
+
+extern char fixed_hosts[FIXED_HOSTS_MAX_LENGTH][FIXED_HOSTS_STR_MAX_LENGTH];
 
 static char *itoa(char *p, unsigned x) {
 	p += 3*sizeof(int);
@@ -42,19 +48,32 @@ static void mkptr6(char *s, const unsigned char *ip)
 	strcpy(s, "ip6.arpa");
 }
 
+static inline int get_hosts_str(char *line, int length, FILE *f, int *i)
+{
+	if (f) {
+		return fgets(line, sizeof line, f);
+	}
+	if (*i < FIXED_HOSTS_MAX_LENGTH) {
+		memcpy(line, fixed_hosts[*i], strlen(fixed_hosts[*i]));
+		(*i)++;
+		return 1;
+	}
+	return NULL;
+}
+
 static void reverse_hosts(char *buf, const unsigned char *a, unsigned scopeid, int family)
 {
 	char line[512], *p, *z;
 	unsigned char _buf[1032], atmp[16];
 	struct address iplit;
 	FILE _f, *f = __fopen_rb_ca("/etc/hosts", &_f, _buf, sizeof _buf);
-	if (!f) return;
 	if (family == AF_INET) {
 		memcpy(atmp+12, a, 4);
 		memcpy(atmp, "\0\0\0\0\0\0\0\0\0\0\xff\xff", 12);
 		a = atmp;
 	}
-	while (fgets(line, sizeof line, f)) {
+	int i = 0;
+	while (i < FIXED_HOSTS_MAX_LENGTH && get_hosts_str(line, sizeof line, f, &i)) {
 		if ((p=strchr(line, '#'))) *p++='\n', *p=0;
 
 		for (p=line; *p && !isspace(*p); p++);
@@ -79,7 +98,9 @@ static void reverse_hosts(char *buf, const unsigned char *a, unsigned scopeid, i
 			break;
 		}
 	}
-	__fclose_ca(f);
+	if (f) {
+		__fclose_ca(f);
+	}
 }
 
 static void reverse_services(char *buf, int port, int dgram)
diff --git a/src/network/inet_legacy.c b/src/network/inet_legacy.c
index 621b47b0..6d91b6e1 100644
--- a/src/network/inet_legacy.c
+++ b/src/network/inet_legacy.c
@@ -12,12 +12,12 @@ struct in_addr inet_makeaddr(in_addr_t n, in_addr_t h)
 	if (n < 256) h |= n<<24;
 	else if (n < 65536) h |= n<<16;
 	else h |= n<<8;
-	return (struct in_addr){ h };
+	return (struct in_addr){ htonl(h) };
 }
 
 in_addr_t inet_lnaof(struct in_addr in)
 {
-	uint32_t h = in.s_addr;
+	uint32_t h = ntohl(in.s_addr);
 	if (h>>24 < 128) return h & 0xffffff;
 	if (h>>24 < 192) return h & 0xffff;
 	return h & 0xff;
@@ -25,7 +25,7 @@ in_addr_t inet_lnaof(struct in_addr in)
 
 in_addr_t inet_netof(struct in_addr in)
 {
-	uint32_t h = in.s_addr;
+	uint32_t h = ntohl(in.s_addr);
 	if (h>>24 < 128) return h >> 24;
 	if (h>>24 < 192) return h >> 16;
 	return h >> 8;
diff --git a/src/network/lookup_name.c b/src/network/lookup_name.c
index 3f00d7c6..2a8cd5d0 100644
--- a/src/network/lookup_name.c
+++ b/src/network/lookup_name.c
@@ -14,10 +14,18 @@
 #include "lookup.h"
 #include "stdio_impl.h"
 #include "syscall.h"
-
+#define BREAK 0
+#define CONTINUE 1
 #if OHOS_PERMISSION_INTERNET
 uint8_t is_allow_internet(void);
 #endif
+#define FIXED_HOSTS_MAX_LENGTH 2
+#define FIXED_HOSTS_STR_MAX_LENGTH 23
+
+char fixed_hosts[][FIXED_HOSTS_STR_MAX_LENGTH] = {
+	"127.0.0.1  localhost\r\n\0",
+	"::1  ip6-localhost\r\n\0"
+};
 
 static int is_valid_hostname(const char *host)
 {
@@ -50,6 +58,19 @@ static int name_from_numeric(struct address buf[static 1], const char *name, int
 	return __lookup_ipliteral(buf, name, family);
 }
 
+static inline int get_hosts_str(char *line, int length, FILE *f, int *i)
+{
+	if (f) {
+		return fgets(line, sizeof line, f);
+	}
+	if (*i < FIXED_HOSTS_MAX_LENGTH) {
+		memcpy(line, fixed_hosts[*i], strlen(fixed_hosts[*i]));
+		(*i)++;
+		return 1;
+	}
+	return NULL;
+}
+
 static int name_from_hosts(struct address buf[static MAXADDRS], char canon[static 256], const char *name, int family)
 {
 	char line[512];
@@ -57,15 +78,8 @@ static int name_from_hosts(struct address buf[static MAXADDRS], char canon[stati
 	int cnt = 0, badfam = 0, have_canon = 0;
 	unsigned char _buf[1032];
 	FILE _f, *f = __fopen_rb_ca("/etc/hosts", &_f, _buf, sizeof _buf);
-	if (!f) switch (errno) {
-	case ENOENT:
-	case ENOTDIR:
-	case EACCES:
-		return 0;
-	default:
-		return EAI_SYSTEM;
-	}
-	while (fgets(line, sizeof line, f) && cnt < MAXADDRS) {
+	int i = 0;
+	while (i < FIXED_HOSTS_MAX_LENGTH && get_hosts_str(line, sizeof line, f, &i) && cnt < MAXADDRS) {
 		char *p, *z;
 
 		if ((p=strchr(line, '#'))) *p++='\n', *p=0;
@@ -98,7 +112,9 @@ static int name_from_hosts(struct address buf[static MAXADDRS], char canon[stati
 			memcpy(canon, p, z-p+1);
 		}
 	}
-	__fclose_ca(f);
+	if (f) {
+		__fclose_ca(f);
+	}
 	return cnt ? cnt : badfam;
 }
 
@@ -152,7 +168,11 @@ static int name_from_dns(struct address buf[static MAXADDRS], char canon[static
 		{ .af = AF_INET, .rr = RR_AAAA },
 	};
 
-	for (i=0; i<2; i++) {
+#if OHOS_DISABLE_IPV6
+    for (i = 0; i < 1; i++) {
+#else
+	for (i = 0; i < 2; i++) {
+#endif
 		if (family != afrr[i].af) {
 			qlens[nq] = __res_mkquery(0, name, 1, afrr[i].rr,
 				0, 0, 0, qbuf[nq], sizeof *qbuf);
@@ -193,7 +213,8 @@ static int name_from_dns_search(struct address buf[static MAXADDRS], char canon[
 	size_t l, dots;
 	char *p, *z;
 
-	if (__get_resolv_conf(&conf, search, sizeof search) < 0) return -1;
+	int res = __get_resolv_conf(&conf, search, sizeof search);
+	if (res < 0) return res;
 
 	/* Count dots, suppress search when >=ndots or name ends in
 	 * a dot, which is an explicit request for global scope. */
diff --git a/src/network/resolvconf.c b/src/network/resolvconf.c
index 73de25fa..eccf8d85 100644
--- a/src/network/resolvconf.c
+++ b/src/network/resolvconf.c
@@ -1,3 +1,18 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *	 http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include "lookup.h"
 #include "stdio_impl.h"
 #include <ctype.h>
@@ -5,8 +20,89 @@
 #include <string.h>
 #include <stdlib.h>
 #include <netinet/in.h>
+
+#define DNS_RESOLV_CONF_PATH "/etc/resolv.conf"
+
 #if OHOS_DNS_PROXY_BY_NETSYS
+#include "atomic.h"
+
 #include <dlfcn.h>
+
+static void *open_dns_lib(void)
+{
+	static void *dns_lib_handle = NULL;
+	if (dns_lib_handle != NULL) {
+		a_barrier();
+		return dns_lib_handle;
+	}
+
+	void *lib = dlopen(DNS_SO_PATH, RTLD_LAZY);
+	if (lib == NULL) {
+		DNS_CONFIG_PRINT("%s: dlopen %s failed: %s",
+			__func__, DNS_SO_PATH, dlerror());
+		return NULL;
+	}
+
+	void *old_lib = a_cas_p(&dns_lib_handle, NULL, lib);
+	if (old_lib == NULL) {
+		DNS_CONFIG_PRINT("%s: %s loaded", __func__, DNS_SO_PATH);
+		return lib;
+	} else {
+		/* Another thread has already loaded the library,
+		 * dlclose is invoked to make refcount correct */
+		DNS_CONFIG_PRINT("%s: %s has been loaded by another thread",
+			__func__, DNS_SO_PATH);
+		if (dlclose(lib)) {
+			DNS_CONFIG_PRINT("%s: dlclose %s failed: %s",
+				__func__, DNS_SO_PATH, dlerror());
+		}
+		return old_lib;
+	}
+}
+
+static void *load_from_dns_lib(const char *symbol)
+{
+	void *lib_handle = open_dns_lib();
+	if (lib_handle == NULL) {
+		return NULL;
+	}
+
+	void *sym_addr = dlsym(lib_handle, symbol);
+	if (sym_addr == NULL) {
+		DNS_CONFIG_PRINT("%s: loading symbol %s with dlsym failed: %s",
+			__func__, symbol, dlerror());
+	}
+	return sym_addr;
+}
+
+void resolve_dns_sym(void **holder, const char *symbol)
+{
+	if (*holder != NULL) {
+		a_barrier();
+		return;
+	}
+
+	void *ptr = load_from_dns_lib(symbol);
+	if (ptr == NULL) {
+		return;
+	}
+
+	void *old_ptr = a_cas_p(holder, NULL, ptr);
+	if (old_ptr != NULL) {
+		DNS_CONFIG_PRINT("%s: %s has been found by another thread",
+			__func__, symbol);
+	} else {
+		DNS_CONFIG_PRINT("%s: %s found", __func__, symbol);
+	}
+}
+
+static GetConfig load_config_getter(void)
+{
+	static GetConfig config_getter = NULL;
+	resolve_dns_sym((void **) &config_getter, OHOS_GET_CONFIG_FUNC_NAME);
+	return config_getter;
+}
+
 #endif
 
 int __get_resolv_conf(struct resolvconf *conf, char *search, size_t search_sz)
@@ -22,30 +118,21 @@ int __get_resolv_conf(struct resolvconf *conf, char *search, size_t search_sz)
 	if (search) *search = 0;
 
 #if OHOS_DNS_PROXY_BY_NETSYS
-	void *handle = dlopen(DNS_SO_PATH, RTLD_LAZY);
-	if (handle == NULL) {
-		DNS_CONFIG_PRINT("__get_resolv_conf dlopen err %s\n", dlerror());
-		goto etc_resolv_conf;
-	}
-
-	GetConfig func = dlsym(handle, OHOS_GET_CONFIG_FUNC_NAME);
-	if (func == NULL) {
-		DNS_CONFIG_PRINT("__get_resolv_conf dlsym err %s\n", dlerror());
-		dlclose(handle);
+	GetConfig func = load_config_getter();
+	if (!func) {
+		DNS_CONFIG_PRINT("%s: loading %s failed, use %s as a fallback",
+			__func__, OHOS_GET_CONFIG_FUNC_NAME, DNS_RESOLV_CONF_PATH);
 		goto etc_resolv_conf;
 	}
 
 	struct resolv_config config = {0};
 	int ret = func(0, &config);
-	dlclose(handle);
 	if (ret < 0) {
 		DNS_CONFIG_PRINT("__get_resolv_conf OHOS_GET_CONFIG_FUNC_NAME err %d\n", ret);
-		goto etc_resolv_conf;
+		return EAI_NONAME;
 	}
 	int32_t timeout_second = config.timeout_ms / 1000;
-#endif
 
-#if OHOS_DNS_PROXY_BY_NETSYS
 netsys_conf:
 	if (timeout_second > 0) {
 		if (timeout_second >= 60) {
@@ -70,9 +157,13 @@ netsys_conf:
 		}
 	}
 
+        if (nns != 0) {
+            goto get_conf_ok;
+        }
+
 etc_resolv_conf:
 #endif
-	f = __fopen_rb_ca("/etc/resolv.conf", &_f, _buf, sizeof _buf);
+	f = __fopen_rb_ca(DNS_RESOLV_CONF_PATH, &_f, _buf, sizeof _buf);
 	if (!f) switch (errno) {
 	case ENOENT:
 	case ENOTDIR:
@@ -142,6 +233,7 @@ no_resolv_conf:
 		nns = 1;
 	}
 
+get_conf_ok:
 	conf->nns = nns;
 
 	return 0;
diff --git a/src/network/socket.c b/src/network/socket.c
index b857dbe7..21dd8fed 100644
--- a/src/network/socket.c
+++ b/src/network/socket.c
@@ -37,7 +37,11 @@ uint8_t is_allow_internet(void)
 }
 #endif
 
+#ifdef OHOS_SOCKET_HOOK_ENABLE
+int __libc_socket(int domain, int type, int protocol)
+#else
 int socket(int domain, int type, int protocol)
+#endif
 {
 #if OHOS_PERMISSION_INTERNET
 	if ((domain == AF_INET || domain == AF_INET6) && is_allow_internet() == 0) {
@@ -45,18 +49,21 @@ int socket(int domain, int type, int protocol)
 		return -1;
 	}
 #endif
-
 	int s = __socketcall(socket, domain, type, protocol, 0, 0, 0);
 	if ((s==-EINVAL || s==-EPROTONOSUPPORT)
-	    && (type&(SOCK_CLOEXEC|SOCK_NONBLOCK))) {
+		&& (type & (SOCK_CLOEXEC | SOCK_NONBLOCK))) {
 		s = __socketcall(socket, domain,
-			type & ~(SOCK_CLOEXEC|SOCK_NONBLOCK),
+			type & ~(SOCK_CLOEXEC | SOCK_NONBLOCK),
 			protocol, 0, 0, 0);
-		if (s < 0) return __syscall_ret(s);
-		if (type & SOCK_CLOEXEC)
+		if (s < 0) {
+			return __syscall_ret(s);
+		}
+		if (type & SOCK_CLOEXEC) {
 			__syscall(SYS_fcntl, s, F_SETFD, FD_CLOEXEC);
-		if (type & SOCK_NONBLOCK)
+		}
+		if (type & SOCK_NONBLOCK) {
 			__syscall(SYS_fcntl, s, F_SETFL, O_NONBLOCK);
+		}
 	}
 	return __syscall_ret(s);
-}
+}
\ No newline at end of file
diff --git a/src/passwd/getspnam_r.c b/src/passwd/getspnam_r.c
index 541e8531..e738d656 100644
--- a/src/passwd/getspnam_r.c
+++ b/src/passwd/getspnam_r.c
@@ -15,8 +15,15 @@
 static long xatol(char **s)
 {
 	long x;
+	int sign;
 	if (**s == ':' || **s == '\n') return -1;
+
+	sign = (int)(unsigned char)**s;
+	if (sign == '-' || sign == '+') ++*s;
+
 	for (x=0; **s-'0'<10U; ++*s) x=10*x+(**s-'0');
+
+	if (sign == '-') return -x;
 	return x;
 }
 
diff --git a/src/process/_Fork.c b/src/process/_Fork.c
index da063868..2b73ced3 100644
--- a/src/process/_Fork.c
+++ b/src/process/_Fork.c
@@ -24,6 +24,7 @@ pid_t _Fork(void)
 	if (!ret) {
 		pthread_t self = __pthread_self();
 		self->tid = __syscall(SYS_gettid);
+		self->pid = self->tid;
 		self->robust_list.off = 0;
 		self->robust_list.pending = 0;
 		self->next = self->prev = self;
@@ -35,4 +36,4 @@ pid_t _Fork(void)
 	__aio_atfork(!ret);
 	__restore_sigs(&set);
 	return __syscall_ret(ret);
-}
+}
\ No newline at end of file
diff --git a/src/process/arm/__vfork.s b/src/process/arm/__vfork.s
new file mode 100644
index 00000000..5774d7dd
--- /dev/null
+++ b/src/process/arm/__vfork.s
@@ -0,0 +1,10 @@
+.syntax unified
+.hidden __vfork
+.type __vfork,%function
+__vfork:
+	mov ip, r7
+	mov r7, 190
+	svc 0
+	mov r7, ip
+	.hidden __syscall_ret
+	b __syscall_ret
diff --git a/src/process/vfork.c b/src/process/vfork.c
index d430c13f..eaee72d0 100644
--- a/src/process/vfork.c
+++ b/src/process/vfork.c
@@ -2,8 +2,9 @@
 #include <unistd.h>
 #include <signal.h>
 #include "syscall.h"
+#include "pthread_impl.h"
 
-pid_t vfork(void)
+hidden pid_t __vfork(void)
 {
 	/* vfork syscall cannot be made from C code */
 #ifdef SYS_fork
@@ -12,3 +13,15 @@ pid_t vfork(void)
 	return syscall(SYS_clone, SIGCHLD, 0);
 #endif
 }
+
+pid_t vfork(void)
+{
+	pthread_t self = __pthread_self();
+	pid_t parent_pid = self->pid;
+	self->pid = 0;
+	pid_t ret = __vfork();
+	if (ret != 0) {
+		self->pid = parent_pid;
+	}
+	return ret;
+}
diff --git a/src/process/x86_64/__vfork.s b/src/process/x86_64/__vfork.s
new file mode 100644
index 00000000..684dd315
--- /dev/null
+++ b/src/process/x86_64/__vfork.s
@@ -0,0 +1,10 @@
+.hidden __vfork
+.type __vfork,@function
+__vfork:
+	pop %rdx
+	mov $58,%eax
+	syscall
+	push %rdx
+	mov %rax,%rdi
+	.hidden __syscall_ret
+	jmp __syscall_ret
diff --git a/src/sched/sched_cpualloc.c b/src/sched/sched_cpualloc.c
new file mode 100644
index 00000000..e21827ca
--- /dev/null
+++ b/src/sched/sched_cpualloc.c
@@ -0,0 +1,11 @@
+#define _GNU_SOURCE 1
+#include <sched.h>
+#include <malloc.h>
+
+cpu_set_t* __sched_cpualloc(size_t count)
+{
+    // The static analyzer complains that CPU_ALLOC_SIZE eventually expands to
+    // N * sizeof(unsigned long), which is incompatible with cpu_set_t. This is
+    // on purpose.
+    return (cpu_set_t*) malloc(CPU_ALLOC_SIZE(count)); // NOLINT
+}
diff --git a/src/sched/sched_getcpu.c b/src/sched/sched_getcpu.c
index 4ec5eaf6..72597b2d 100644
--- a/src/sched/sched_getcpu.c
+++ b/src/sched/sched_getcpu.c
@@ -1,3 +1,17 @@
+/* Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *	 http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #define _GNU_SOURCE
 #include <errno.h>
 #include <sched.h>
@@ -12,7 +26,8 @@ typedef long (*getcpu_f)(unsigned *, unsigned *, void *);
 
 static long getcpu_init(unsigned *cpu, unsigned *node, void *unused)
 {
-	void *p = __vdsosym(VDSO_GETCPU_VER, VDSO_GETCPU_SYM);
+        __get_vdso_info();
+	void *p = __get_vdso_addr(VDSO_GETCPU_VER, VDSO_GETCPU_SYM);
 	getcpu_f f = (getcpu_f)p;
 	a_cas_p(&vdso_func, (void *)getcpu_init, p);
 	return f ? f(cpu, node, unused) : -ENOSYS;
diff --git a/src/sched/sched_getparam.c b/src/sched/sched_getparam.c
index 76f10e49..b31f0089 100644
--- a/src/sched/sched_getparam.c
+++ b/src/sched/sched_getparam.c
@@ -1,8 +1,20 @@
-#include <sched.h>
-#include <errno.h>
-#include "syscall.h"
-
-int sched_getparam(pid_t pid, struct sched_param *param)
-{
-	return __syscall_ret(-ENOSYS);
-}
+#include <sched.h>
+#include <errno.h>
+#include "syscall.h"
+#include <string.h>
+
+int sched_getparam(pid_t pid, struct sched_param *param)
+{
+	int r;
+	if (!param) {
+		r = -EINVAL;
+		goto exit;
+	}
+	memset(param, 0, sizeof(struct sched_param));
+	r = __syscall(SYS_sched_getparam, pid , param);
+	if (r >= 0) {
+		r = 0;
+	}
+exit:
+	return __syscall_ret(r);
+}
diff --git a/src/sched/sched_getscheduler.c b/src/sched/sched_getscheduler.c
index 394e508b..454ac8bc 100644
--- a/src/sched/sched_getscheduler.c
+++ b/src/sched/sched_getscheduler.c
@@ -1,8 +1,9 @@
-#include <sched.h>
-#include <errno.h>
-#include "syscall.h"
-
-int sched_getscheduler(pid_t pid)
-{
-	return __syscall_ret(-ENOSYS);
-}
+#include <sched.h>
+#include <errno.h>
+#include "syscall.h"
+
+int sched_getscheduler(pid_t pid)
+{
+	int r = __syscall(SYS_sched_getscheduler, pid);
+	return  __syscall_ret(r);
+}
\ No newline at end of file
diff --git a/src/sched/sched_setparam.c b/src/sched/sched_setparam.c
index 18623ee4..2e0f79bf 100644
--- a/src/sched/sched_setparam.c
+++ b/src/sched/sched_setparam.c
@@ -1,8 +1,15 @@
-#include <sched.h>
-#include <errno.h>
-#include "syscall.h"
-
-int sched_setparam(pid_t pid, const struct sched_param *param)
-{
-	return __syscall_ret(-ENOSYS);
-}
+#include <sched.h>
+#include <errno.h>
+#include "syscall.h"
+
+int sched_setparam(pid_t pid, const struct sched_param *param)
+{
+	int r;
+	if (!param) {
+		r = -EINVAL;
+		goto exit;
+	}
+	r = __syscall(SYS_sched_setparam, pid, param);
+exit:
+	return __syscall_ret(r);
+}
\ No newline at end of file
diff --git a/src/sched/sched_setscheduler.c b/src/sched/sched_setscheduler.c
index 4435f216..fcb5873f 100644
--- a/src/sched/sched_setscheduler.c
+++ b/src/sched/sched_setscheduler.c
@@ -4,5 +4,12 @@
 
 int sched_setscheduler(pid_t pid, int sched, const struct sched_param *param)
 {
-	return __syscall_ret(-ENOSYS);
-}
+	int r;
+	if (!param) {
+		r = -EINVAL;
+		goto exit;
+	}
+	r = __syscall(SYS_sched_setscheduler, pid , sched , param);
+exit:
+	return __syscall_ret(r);
+}
\ No newline at end of file
diff --git a/src/sigchain/sigchain.c b/src/sigchain/sigchain.c
new file mode 100644
index 00000000..9176a729
--- /dev/null
+++ b/src/sigchain/sigchain.c
@@ -0,0 +1,478 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <sigchain.h>
+#include <locale.h>
+#include <pthread.h>
+#include <errno.h>
+#include <threads.h>
+#include <hilog_adapter.h>
+#include <stdlib.h>
+#include <errno.h>
+#include "syscall.h"
+
+extern int __libc_sigaction(int sig, const struct sigaction *restrict sa,
+                            struct sigaction *restrict old);
+
+#define SIG_CHAIN_KEY_VALUE_1 1
+#define SIGNAL_CHAIN_SPECIAL_ACTION_MAX 2
+
+#define SIGCHAIN_LOG_DOMAIN 0xD003F00
+#define SIGCHAIN_LOG_TAG "SIGCHAIN"
+
+#if (defined(OHOS_ENABLE_PARAMETER) || defined(ENABLE_MUSL_LOG))
+#define SIGCHAIN_PRINT_ERROR(...) ((void)HiLogAdapterPrint(LOG_CORE, LOG_ERROR, \
+    SIGCHAIN_LOG_DOMAIN, SIGCHAIN_LOG_TAG, __VA_ARGS__))
+#define SIGCHAIN_PRINT_INFO(...) ((void)HiLogAdapterPrint(LOG_CORE, LOG_INFO, \
+    SIGCHAIN_LOG_DOMAIN, SIGCHAIN_LOG_TAG, __VA_ARGS__))
+#define SIGCHAIN_PRINT_DEBUG(...) ((void)HiLogAdapterPrint(LOG_CORE, LOG_DEBUG, \
+    SIGCHAIN_LOG_DOMAIN, SIGCHAIN_LOG_TAG, __VA_ARGS__))
+#define SIGCHAIN_LOG_FATAL(...) ((void)HiLogAdapterPrint(LOG_CORE, LOG_FATAL, \
+    SIGCHAIN_LOG_DOMAIN, SIGCHAIN_LOG_TAG, __VA_ARGS__))
+#else
+#define SIGCHAIN_PRINT_ERROR(...)
+#define SIGCHAIN_PRINT_INFO(...)
+#define SIGCHAIN_PRINT_DEBUG(...)
+#define SIGCHAIN_LOG_FATAL(...)
+#endif
+
+#define SIGCHAIN_PRINT_FATAL(...)  do {                    \
+    SIGCHAIN_LOG_FATAL(__VA_ARGS__);                      \
+    abort();                                               \
+} while(0)
+
+struct sc_signal_chain {
+    bool marked;
+    struct sigaction sig_action;
+    struct signal_chain_action sca_special_actions[SIGNAL_CHAIN_SPECIAL_ACTION_MAX];
+};
+
+/* Signal chain set, from 0 to 63. */
+static struct sc_signal_chain sig_chains[_NSIG - 1];
+/* static thread Keyword */
+static pthread_key_t g_sigchain_key;
+/* This is once flag! */
+static once_flag g_flag = ONCE_FLAG_INIT;
+
+/**
+  * @brief Create the thread key
+  * @retval void
+  */
+static void create_pthread_key(void)
+{
+    SIGCHAIN_PRINT_INFO("%{public}s create the thread key!", __func__);
+    int rc = pthread_key_create(&g_sigchain_key, NULL);
+    if (rc != 0) {
+        SIGCHAIN_PRINT_FATAL("%{public}s failed to create sigchain pthread key, rc:%{public}d",
+                __func__,  rc);
+    }
+}
+
+/**
+  * @brief Get the key of the signal thread.
+  * @retval int32_t, the value of the sigchain key.
+  */
+static pthread_key_t get_handling_signal_key()
+{
+    call_once(&g_flag, create_pthread_key);
+    return g_sigchain_key;
+}
+
+/**
+  * @brief Get the value of the sigchain key
+  * @retval bool, true if set the value of the key，or false.
+  */
+static bool get_handling_signal()
+{
+    void *result = pthread_getspecific(get_handling_signal_key());
+    return result == NULL ? false : true;
+}
+
+/**
+  * @brief Set the value of the sigchain key
+  * @param[in] value, the value of the sigchain key
+  * @retval void.
+  */
+static void set_handling_signal(bool value)
+{
+    pthread_setspecific(get_handling_signal_key(),
+                        (void *)((uintptr_t)(value)));
+}
+
+/**
+  * @brief Set the mask of the system. Its prototype comes from pthread_sigmask.
+  * @param[in] how, the value of the mask operation .
+  * @param[in] set, the new value of the sigset.
+  * @param[in] old, the old value of the sigset.
+  */
+static int sigchain_sigmask(int how, const sigset_t *restrict set, sigset_t *restrict old)
+{
+    int ret;
+    if (set && (unsigned)how - SIG_BLOCK > 2U) return EINVAL;
+    ret = -__syscall(SYS_rt_sigprocmask, how, set, old, _NSIG/8);
+    if (!ret && old) {
+        if (sizeof old->__bits[0] == 8) {
+            old->__bits[0] &= ~0x380000000ULL;
+        } else {
+            old->__bits[0] &= ~0x80000000UL;
+            old->__bits[1] &= ~0x3UL;
+        }
+    }
+    return ret;
+}
+
+/**
+  * @brief Judge whether the signal is marked
+  * @param[in] signo, the value of the signal.
+  * @retval true if the signal is marked, or false.
+  */
+static bool ismarked(int signo)
+{
+    return sig_chains[signo - 1].marked;
+}
+
+/**
+  * @brief This is a callback function, which is registered to the kernel
+  * @param[in] signo, the value of the signal.
+  * @param[in] siginfo, the information of the signal.
+  * @param[in] ucontext_raw, the context of the signal.
+  * @retval void
+  */
+static void signal_chain_handler(int signo, siginfo_t* siginfo, void* ucontext_raw)
+{
+    SIGCHAIN_PRINT_DEBUG("%{public}s signo: %{public}d", __func__, signo);
+    /* First call special handler. */
+    /* If a process crashes, the sigchain'll call the corresponding  handler */
+    if (!get_handling_signal()) {
+        for (int i = 0; i < SIGNAL_CHAIN_SPECIAL_ACTION_MAX; i++) {
+            if (sig_chains[signo - 1].sca_special_actions[i].sca_sigaction == NULL) {
+                continue;
+            }
+            /* The special handler might not return. */
+            bool noreturn = (sig_chains[signo - 1].sca_special_actions[i].sca_flags &
+                             SIGCHAIN_ALLOW_NORETURN);
+            sigset_t previous_mask;
+            sigchain_sigmask(SIG_SETMASK, &sig_chains[signo - 1].sca_special_actions[i].sca_mask,
+                            &previous_mask);
+
+            bool previous_value = get_handling_signal();
+            if (!noreturn) {
+                set_handling_signal(true);
+            }
+
+            if (sig_chains[signo - 1].sca_special_actions[i].sca_sigaction(signo,
+                                                            siginfo, ucontext_raw)) {
+                set_handling_signal(previous_value);
+                return;
+            }
+
+            sigchain_sigmask(SIG_SETMASK, &previous_mask, NULL);
+            set_handling_signal(previous_value);
+        }
+    }
+    /* Then Call the user's signal handler */
+    int sa_flags = sig_chains[signo - 1].sig_action.sa_flags;
+    ucontext_t* ucontext = (ucontext_t*)(ucontext_raw);
+
+    sigset_t mask;
+    sigorset(&mask, &ucontext->uc_sigmask, &sig_chains[signo - 1].sig_action.sa_mask);
+
+    if (!(sa_flags & SA_NODEFER)) {
+        sigaddset(&mask, signo);
+    }
+
+    sigchain_sigmask(SIG_SETMASK, &mask, NULL);
+
+    if ((sa_flags & SA_SIGINFO)) {
+        sig_chains[signo - 1].sig_action.sa_sigaction(signo, siginfo, ucontext_raw);
+    } else {
+        if (sig_chains[signo - 1].sig_action.sa_handler == SIG_IGN) {
+            return;
+        } else if (sig_chains[signo - 1].sig_action.sa_handler == SIG_DFL) {
+            SIGCHAIN_PRINT_DEBUG("%{public}s SIG_DFL handler for signal: %{public}d", __func__, signo);
+            remove_all_special_handler(signo);
+            if (__syscall(SYS_rt_tgsigqueueinfo, __syscall(SYS_getpid), __syscall(SYS_gettid), signo, siginfo) != 0) {
+                SIGCHAIN_PRINT_ERROR("Failed to rethrow sig(%{public}d), errno(%{public}d).", signo, errno);
+            } else {
+                SIGCHAIN_PRINT_INFO("pid(%{public}d) rethrow sig(%{public}d).", __syscall(SYS_getpid), signo);
+            }
+        } else {
+            sig_chains[signo - 1].sig_action.sa_handler(signo);
+        }
+    }
+
+    return;
+}
+
+/**
+  * @brief Register the signal chain with the kernel if needed
+  * @param[in] signo, the value of the signal.
+  * @retval void
+  */
+static void sigchain_register(int signo)
+{
+    SIGCHAIN_PRINT_INFO("%{public}s signo: %{public}d", __func__, signo);
+    struct sigaction signal_action = {};
+    sigfillset(&signal_action.sa_mask);
+
+    signal_action.sa_sigaction = signal_chain_handler;
+    signal_action.sa_flags = SA_RESTART | SA_SIGINFO | SA_ONSTACK;
+    __libc_sigaction(signo, &signal_action, &sig_chains[signo - 1].sig_action);
+}
+
+/**
+  * @brief Unregister the signal from sigchain, register the signal's user handler with the kernel if needed
+  * @param[in] signo, the value of the signal.
+  * @retval void
+  */
+static void unregister_sigchain(int signo)
+{
+    SIGCHAIN_PRINT_INFO("%{public}s signo: %{public}d", __func__, signo);
+    __libc_sigaction(signo, &sig_chains[signo - 1].sig_action, NULL);
+    sig_chains[signo - 1].marked = false;
+}
+
+/**
+  * @brief Mark the signal to the sigchain.
+  * @param[in] signo, the value of the signal.
+  * @retval void
+  */
+static void mark_signal_to_sigchain(int signo)
+{
+    SIGCHAIN_PRINT_INFO("%{public}s signo: %{public}d", __func__, signo);
+    if (!sig_chains[signo - 1].marked) {
+        sigchain_register(signo);
+        sig_chains[signo - 1].marked = true;
+    }
+}
+
+/**
+  * @brief Set the action of the signal.
+  * @param[in] signo, the value of the signal.
+  * @param[in] new_sa, the new action of the signal.
+  * @retval void
+  */
+static void setaction(int signo, const struct sigaction *restrict new_sa)
+{
+    SIGCHAIN_PRINT_DEBUG("%{public}s signo: %{public}d", __func__, signo);
+    sig_chains[signo - 1].sig_action = *new_sa;
+}
+
+/**
+  * @brief Get the action of the signal.
+  * @param[in] signo, the value of the signal.
+  * @retval The current action of the signal
+  */
+static struct sigaction getaction(int signo)
+{
+    SIGCHAIN_PRINT_DEBUG("%{public}s signo: %{public}d", __func__, signo);
+    return sig_chains[signo - 1].sig_action;
+}
+
+/**
+  * @brief Add the special handler to the sigchain.
+  * @param[in] signo, the value of the signal.
+  * @param[in] sa, the action with special handler.
+  * @retval void
+  */
+static void add_special_handler(int signo, struct signal_chain_action* sa)
+{
+    SIGCHAIN_PRINT_INFO("%{public}s signo: %{public}d", __func__, signo);
+    for (int i = 0; i < SIGNAL_CHAIN_SPECIAL_ACTION_MAX; i++) {
+        if (sig_chains[signo - 1].sca_special_actions[i].sca_sigaction == NULL) {
+            sig_chains[signo - 1].sca_special_actions[i] = *sa;
+            SIGCHAIN_PRINT_INFO("%{public}s signo %{public}d is registered with special handler!", __func__, signo);
+            return;
+        }
+    }
+
+    SIGCHAIN_PRINT_FATAL("Add too many the special handlers!");
+}
+
+/**
+  * @brief Remove the special handler from the sigchain.
+  * @param[in] signo, the value of the signal.
+  * @param[in] fn, the special handler of the signal.
+  * @retval void
+  */
+static void rm_special_handler(int signo, bool (*fn)(int, siginfo_t*, void*))
+{
+    SIGCHAIN_PRINT_INFO("%{public}s signo: %{public}d", __func__, signo);
+    int len = SIGNAL_CHAIN_SPECIAL_ACTION_MAX;
+    for (int i = 0; i < len; i++) {
+        if (sig_chains[signo - 1].sca_special_actions[i].sca_sigaction == fn) {
+            sig_chains[signo - 1].sca_special_actions[i].sca_sigaction = NULL;
+            int count = 0;
+            for (int k = 0; k < len; k++) {
+                if (sig_chains[signo - 1].sca_special_actions[k].sca_sigaction == NULL) {
+                    count++;
+                }
+            }
+            if (count == len) {
+                unregister_sigchain(signo);
+            }
+            return;
+        }
+    }
+
+    SIGCHAIN_PRINT_FATAL("%{public}s failed to remove the special handler!. signo: %{public}d",
+            __func__, signo);
+}
+
+/**
+  * @brief This is an external interface, 
+  *        Mark the signal to sigchain ,add the special handler to the sigchain.
+  * @param[in] signo, the value of the signal.
+  * @param[in] sa, the action with special handler.
+  * @retval void
+  */
+void add_special_signal_handler(int signo, struct signal_chain_action* sa)
+{
+    SIGCHAIN_PRINT_INFO("%{public}s signo: %{public}d", __func__, signo);
+    if (signo <= 0 || signo >= _NSIG) {
+        SIGCHAIN_PRINT_FATAL("%{public}s Invalid signal %{public}d", __func__, signo);
+        return;
+    }
+
+    // Add the special hander to the sigchain
+    add_special_handler(signo, sa);
+    mark_signal_to_sigchain(signo);
+}
+
+/**
+  * @brief This is an external interface, remove the special handler from the sigchain.
+  * @param[in] signo, the value of the signal.
+  * @param[in] fn, the special handler of the signal.
+  * @retval void
+  */
+void remove_special_signal_handler(int signo, bool (*fn)(int, siginfo_t*, void*))
+{
+    SIGCHAIN_PRINT_INFO("%{public}s signo: %{public}d", __func__, signo);
+    if (signo <= 0 || signo >= _NSIG) {
+        SIGCHAIN_PRINT_FATAL("%{public}s Invalid signal %{public}d", __func__, signo);
+        return;
+    }
+
+    if (ismarked(signo)) {
+        // remove the special handler from the sigchain.
+        rm_special_handler(signo, fn);
+    }
+}
+
+/**
+  * @brief This is an external interface, remove all special handler from the sigchain.
+  * @param[in] signo, the value of the signal.
+  * @retval void
+  */
+void remove_all_special_handler(int signo)
+{
+    SIGCHAIN_PRINT_INFO("%{public}s signo: %{public}d", __func__, signo);
+    if (signo <= 0 || signo >= _NSIG) {
+        SIGCHAIN_PRINT_FATAL("%{public}s Invalid signal %{public}d", __func__, signo);
+        return;
+    }
+
+    if (ismarked(signo)) {
+        // remove all special handler from the sigchain.
+        for (int i = 0; i < SIGNAL_CHAIN_SPECIAL_ACTION_MAX; i++) {
+            sig_chains[signo - 1].sca_special_actions[i].sca_sigaction = NULL;
+        }
+        unregister_sigchain(signo);
+    }
+}
+
+/**
+  * @brief This is an external interface, add the special handler at the last of sigchain chains.
+  * @param[in] signo, the value of the signal.
+  * @param[in] sa, the action with special handler.
+  * @retval void
+  */
+void add_special_handler_at_last(int signo, struct signal_chain_action* sa)
+{
+    SIGCHAIN_PRINT_INFO("%{public}s signo: %{public}d", __func__, signo);
+    if (signo <= 0 || signo >= _NSIG) {
+        SIGCHAIN_PRINT_FATAL("%{public}s Invalid signal %{public}d", __func__, signo);
+        return;
+    }
+
+    if (sig_chains[signo - 1].sca_special_actions[SIGNAL_CHAIN_SPECIAL_ACTION_MAX - 1].sca_sigaction == NULL) {
+        sig_chains[signo - 1].sca_special_actions[SIGNAL_CHAIN_SPECIAL_ACTION_MAX - 1] = *sa;
+        mark_signal_to_sigchain(signo);
+        return;
+    }
+
+    SIGCHAIN_PRINT_FATAL("Add too many the special handlers at last!");
+}
+
+/**
+  * @brief Intercept the signal and sigaction.
+  * @param[in] signo, the value of the signal.
+  * @param[in] sa, the new action with the signal handler.
+  * @param[out] old, the old action with the signal handler.
+  * @retval true if the signal if intercepted, or false.
+  */
+bool intercept_sigaction(int signo, const struct sigaction *restrict sa,
+                         struct sigaction *restrict old)
+{
+    SIGCHAIN_PRINT_DEBUG("%{public}s signo: %{public}d", __func__, signo);
+    if (signo <= 0 || signo >= _NSIG) {
+        SIGCHAIN_PRINT_ERROR("%{public}s Invalid signal %{public}d", __func__, signo);
+        return false;
+    }
+
+    if (ismarked(signo)) {
+        struct sigaction saved_action = getaction(signo);
+
+        if (sa != NULL) {
+            setaction(signo, sa);
+        }
+        if (old != NULL) {
+            *old = saved_action;
+        }
+        return true;
+    }
+
+    return false;
+}
+
+/**
+  * @brief Intercept the pthread_sigmask.
+  * @param[in] how, the value of the mask operation .
+  * @param[out] set, the value of the sigset.
+  * @retval void.
+  */
+void intercept_pthread_sigmask(int how, sigset_t *restrict set)
+{
+    SIGCHAIN_PRINT_DEBUG("%{public}s how: %{public}d", __func__, how);
+    // Forward directly to the system mask When this sigchain is handling a signal.
+    if (get_handling_signal()) {
+        return;
+    }
+
+    sigset_t tmpset;
+    if (set != NULL) {
+        tmpset = *set;
+        if (how == SIG_BLOCK || how == SIG_SETMASK) {
+            for (int i = 1; i < _NSIG; ++i) {
+                if (ismarked(i) && sigismember(&tmpset, i)) {
+                    sigdelset(&tmpset, i);
+                }
+            }
+        }
+        *set = tmpset;
+    }
+
+    return;
+}
diff --git a/src/signal/sigaction.c b/src/signal/sigaction.c
index 2203471b..3f0dc522 100644
--- a/src/signal/sigaction.c
+++ b/src/signal/sigaction.c
@@ -1,12 +1,36 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <signal.h>
 #include <errno.h>
 #include <string.h>
+#include <stdbool.h>
 #include "syscall.h"
 #include "pthread_impl.h"
 #include "libc.h"
 #include "lock.h"
 #include "ksigaction.h"
 
+extern bool intercept_sigaction(int signo, const struct sigaction *restrict sa, struct sigaction *restrict old);
+
+static volatile int dummy_lock[1] = { 0 };
+
+extern hidden volatile int __abort_lock[1];
+
+weak_alias(dummy_lock, __abort_lock);
+
 static int unmask_done;
 static unsigned long handler_set[_NSIG/(8*sizeof(long))];
 
@@ -20,6 +44,7 @@ volatile int __eintr_valid_flag;
 int __libc_sigaction(int sig, const struct sigaction *restrict sa, struct sigaction *restrict old)
 {
 	struct k_sigaction ksa, ksa_old;
+	unsigned long set[_NSIG/(8*sizeof(long))];
 	if (sa) {
 		if ((uintptr_t)sa->sa_handler > 1UL) {
 			a_or_l(handler_set+(sig-1)/(8*sizeof(long)),
@@ -43,12 +68,24 @@ int __libc_sigaction(int sig, const struct sigaction *restrict sa, struct sigact
 				a_store(&__eintr_valid_flag, 1);
 			}
 		}
+		/* Changing the disposition of SIGABRT to anything but
+		 * SIG_DFL requires a lock, so that it cannot be changed
+		 * while abort is terminating the process after simply
+		 * calling raise(SIGABRT) failed to do so. */
+		if (sa->sa_handler != SIG_DFL && sig == SIGABRT) {
+			__block_all_sigs(&set);
+			LOCK(__abort_lock);
+		}
 		ksa.handler = sa->sa_handler;
 		ksa.flags = sa->sa_flags | SA_RESTORER;
 		ksa.restorer = (sa->sa_flags & SA_SIGINFO) ? __restore_rt : __restore;
 		memcpy(&ksa.mask, &sa->sa_mask, _NSIG/8);
 	}
 	int r = __syscall(SYS_rt_sigaction, sig, sa?&ksa:0, old?&ksa_old:0, _NSIG/8);
+	if (sig == SIGABRT && sa && sa->sa_handler != SIG_DFL) {
+		UNLOCK(__abort_lock);
+		__restore_sigs(&set);
+	}
 	if (old && !r) {
 		old->sa_handler = ksa_old.handler;
 		old->sa_flags = ksa_old.flags;
@@ -59,26 +96,16 @@ int __libc_sigaction(int sig, const struct sigaction *restrict sa, struct sigact
 
 int __sigaction(int sig, const struct sigaction *restrict sa, struct sigaction *restrict old)
 {
-	unsigned long set[_NSIG/(8*sizeof(long))];
-
 	if (sig-32U < 3 || sig-1U >= _NSIG-1) {
 		errno = EINVAL;
 		return -1;
 	}
-
-	/* Doing anything with the disposition of SIGABRT requires a lock,
-	 * so that it cannot be changed while abort is terminating the
-	 * process and so any change made by abort can't be observed. */
-	if (sig == SIGABRT) {
-		__block_all_sigs(&set);
-		LOCK(__abort_lock);
-	}
-	int r = __libc_sigaction(sig, sa, old);
-	if (sig == SIGABRT) {
-		UNLOCK(__abort_lock);
-		__restore_sigs(&set);
+	/* sigchain intercepts sigaction */
+	if (intercept_sigaction(sig, sa, old)) {
+		return 0;
 	}
-	return r;
+
+	return __libc_sigaction(sig, sa, old);
 }
 
 weak_alias(__sigaction, sigaction);
diff --git a/src/signal/siginterrupt.c b/src/signal/siginterrupt.c
index 70063400..d1acd0a9 100644
--- a/src/signal/siginterrupt.c
+++ b/src/signal/siginterrupt.c
@@ -1,12 +1,34 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <signal.h>
+#include <errno.h>
+
+extern int __libc_sigaction(int sig, const struct sigaction *restrict sa, struct sigaction *restrict old);
 
 int siginterrupt(int sig, int flag)
 {
+	if (sig-32U < 3 || sig-1U >= _NSIG-1) {
+		errno = EINVAL;
+		return -1;
+	}
 	struct sigaction sa;
 
-	sigaction(sig, 0, &sa);
+	__libc_sigaction(sig, 0, &sa);
 	if (flag) sa.sa_flags &= ~SA_RESTART;
 	else sa.sa_flags |= SA_RESTART;
 
-	return sigaction(sig, &sa, 0);
+	return __libc_sigaction(sig, &sa, 0);
 }
diff --git a/src/signal/signal.c b/src/signal/signal.c
index 7a6dd172..0dbd3f6a 100644
--- a/src/signal/signal.c
+++ b/src/signal/signal.c
@@ -1,13 +1,12 @@
-#include <signal.h>
-#include "syscall.h"
-
-void (*signal(int sig, void (*func)(int)))(int)
-{
-	struct sigaction sa_old, sa = { .sa_handler = func, .sa_flags = SA_RESTART };
-	if (__sigaction(sig, &sa, &sa_old) < 0)
-		return SIG_ERR;
-	return sa_old.sa_handler;
-}
-
-weak_alias(signal, bsd_signal);
-weak_alias(signal, __sysv_signal);
+#include <signal.h>
+
+void (*signal(int sig, void (*func)(int)))(int)
+{
+	struct sigaction sa_old, sa = { .sa_handler = func, .sa_flags = SA_RESTART };
+	if (__sigaction(sig, &sa, &sa_old) < 0)
+		return SIG_ERR;
+	return sa_old.sa_handler;
+}
+
+weak_alias(signal, bsd_signal);
+weak_alias(signal, __sysv_signal);
diff --git a/src/stdio/__fdopen.c b/src/stdio/__fdopen.c
index 116e78e5..416f7c02 100644
--- a/src/stdio/__fdopen.c
+++ b/src/stdio/__fdopen.c
@@ -1,61 +1,134 @@
+/* Copyright (c) 2021-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *	 http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include "stdio_impl.h"
 #include <stdlib.h>
 #include <sys/ioctl.h>
+#include <sys/stat.h>
 #include <fcntl.h>
 #include <errno.h>
 #include <string.h>
 #include "libc.h"
 
-FILE *__fdopen(int fd, const char *mode)
+static size_t __get_bufsize(int fd)
 {
-	FILE *f;
-	struct winsize wsz;
+	struct stat st;
+	size_t buf_size = 0;
+
+	if (fstat(fd, &st) < 0) {
+		buf_size = BUFSIZ;
+	} else if (st.st_blksize == 0) {
+		buf_size = BUFSIZ;
+	} else {
+		buf_size = st.st_blksize;
+	}
 
-	/* Check for valid initial mode character */
-	if (!strchr("rwa", *mode)) {
-		errno = EINVAL;
+	return buf_size;
+}
+
+int __falloc_buf(FILE *f)
+{
+	/* return if already allocated, or F_NOBUF set */
+	if (f->buf != NULL || f->buf_size != 0 || f->flags & F_NOBUF) {
 		return 0;
 	}
 
-	/* Allocate FILE+buffer or fail */
-	if (!(f=malloc(sizeof *f + UNGET + BUFSIZ))) return 0;
+	/* Default,  base and buf are NULL,and buf_size = 0 */
+	size_t buf_size = 0;
 
-	/* Zero-fill only the struct, not the buffer */
-	memset(f, 0, sizeof *f);
+	/* get buffer size via file stat */
+	buf_size = __get_bufsize(f->fd);
+
+	/* alloc R/W buffer */
+	f->base = (unsigned char *)malloc(UNGET + buf_size * sizeof(unsigned char));
+	if (!f->base) {
+		errno = -ENOMEM;
+		return errno;
+	}
+
+	/* reserve UNGET buffer */
+	f->buf = f->base + UNGET;
+	f->buf_size = buf_size;
+
+	return 0;
+}
+
+FILE *__fdopen(int fd, const char *mode)
+{
+	FILE *f = NULL;
+	int file_flags = 0;
+	int mode_flags = 0;
 
-	/* Impose mode restrictions */
-	if (!strchr(mode, '+')) f->flags = (*mode == 'r') ? F_NOWR : F_NORD;
+	/* Compute the flags to pass to open() */
+	mode_flags = __fmodeflags(mode, &file_flags);
+	if (mode_flags < 0) {
+		return NULL;
+	}
 
-	/* Apply close-on-exec flag */
-	if (strchr(mode, 'e')) __syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);
+	if (mode_flags & O_CLOEXEC) {
+		__syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);
+	}
 
-	/* Set append mode on fd if opened for append */
-	if (*mode == 'a') {
+	if (mode_flags & O_APPEND) {
 		int flags = __syscall(SYS_fcntl, fd, F_GETFL);
 		if (!(flags & O_APPEND))
 			__syscall(SYS_fcntl, fd, F_SETFL, flags | O_APPEND);
-		f->flags |= F_APP;
 	}
 
+	f = __fdopenx(fd, file_flags);
+	if (f) {
+		return f;
+	}
+
+	return NULL;
+}
+weak_alias(__fdopen, fdopen);
+
+FILE *__fdopenx(int fd, int flags)
+{
+	FILE *f = 0;
+	struct winsize wsz;
+
+	/* Allocate FILE or fail */
+	if (!(f = __ofl_alloc())) {
+		return NULL;
+	}
+
+	/* Zero-fill only the struct, not the buffer */
+	memset(f, 0, sizeof *f);
+
+	f->flags = flags;
 	f->fd = fd;
-	f->buf = (unsigned char *)f + sizeof *f + UNGET;
-	f->buf_size = BUFSIZ;
 
 	/* Activate line buffered mode for terminals */
 	f->lbf = EOF;
-	if (!(f->flags & F_NOWR) && !__syscall(SYS_ioctl, fd, TIOCGWINSZ, &wsz))
+	if (!(f->flags & F_NOWR) && !__syscall(SYS_ioctl, fd, TIOCGWINSZ, &wsz)) {
 		f->lbf = '\n';
+	}
 
 	/* Initialize op ptrs. No problem if some are unneeded. */
 	f->read = __stdio_read;
 	f->write = __stdio_write;
 	f->seek = __stdio_seek;
 	f->close = __stdio_close;
+	f->readx = __stdio_readx;
 
-	if (!libc.threaded) f->lock = -1;
+	if (!libc.threaded) {
+		f->lock = -1;
+	}
 
 	/* Add new FILE to open file list */
 	return __ofl_add(f);
 }
 
-weak_alias(__fdopen, fdopen);
diff --git a/src/stdio/__fmodeflags.c b/src/stdio/__fmodeflags.c
index da9f23b6..f738b270 100644
--- a/src/stdio/__fmodeflags.c
+++ b/src/stdio/__fmodeflags.c
@@ -1,16 +1,55 @@
+#include "stdio_impl.h"
 #include <fcntl.h>
 #include <string.h>
+#include <errno.h>
 
-int __fmodeflags(const char *mode)
+int __fmodeflags(const char *mode, int *flags)
 {
-	int flags;
-	if (strchr(mode, '+')) flags = O_RDWR;
-	else if (*mode == 'r') flags = O_RDONLY;
-	else flags = O_WRONLY;
-	if (strchr(mode, 'x')) flags |= O_EXCL;
-	if (strchr(mode, 'e')) flags |= O_CLOEXEC;
-	if (*mode != 'r') flags |= O_CREAT;
-	if (*mode == 'w') flags |= O_TRUNC;
-	if (*mode == 'a') flags |= O_APPEND;
-	return flags;
+	int mode_flags = 0;
+	int options = 0;
+
+	switch (*mode) {
+		case 'r':
+			mode_flags = O_RDONLY;
+			*flags = F_NOWR;
+			break;
+		case 'w':
+			mode_flags = O_WRONLY;
+			options = O_TRUNC | O_CREAT;
+			*flags = F_NORD;
+			break;
+		case 'a':
+			mode_flags = O_WRONLY;
+			options = O_APPEND | O_CREAT;
+			*flags = F_NORD | F_APP;
+			break;
+		default:
+			errno = EINVAL;
+			return -EINVAL;
+	}
+
+	mode++;
+	while (*mode != '\0') {
+		switch (*mode) {
+			case '+':
+				mode_flags = O_RDWR;
+				*flags &= ~(F_NORD | F_NOWR);
+				break;
+			case 'x':
+				/* need O_CREAT check */
+				options |= O_EXCL;
+				break;
+			case 'e':
+				options |= O_CLOEXEC;
+				break;
+			case 'b':
+				break;
+			default:
+				/* only accept "+xeb" */
+				break;
+		}
+		mode++;
+	}
+
+	return mode_flags | options;
 }
diff --git a/src/stdio/__stdio_read.c b/src/stdio/__stdio_read.c
index ea675da3..dd681e0b 100644
--- a/src/stdio/__stdio_read.c
+++ b/src/stdio/__stdio_read.c
@@ -1,22 +1,34 @@
 #include "stdio_impl.h"
 #include <sys/uio.h>
 
+size_t __stdio_readx(FILE *f, unsigned char *buf, size_t len)
+{
+	ssize_t cnt = syscall(SYS_read, f->fd, buf, len);
+	if (cnt <= 0) {
+		f->flags |= cnt ? F_ERR : F_EOF;
+		return 0;
+	}
+	return cnt;
+}
+
 size_t __stdio_read(FILE *f, unsigned char *buf, size_t len)
 {
-	struct iovec iov[2] = {
+	struct iovec iov_buf[2] = {
 		{ .iov_base = buf, .iov_len = len - !!f->buf_size },
 		{ .iov_base = f->buf, .iov_len = f->buf_size }
 	};
 	ssize_t cnt;
 
-	cnt = iov[0].iov_len ? syscall(SYS_readv, f->fd, iov, 2)
-		: syscall(SYS_read, f->fd, iov[1].iov_base, iov[1].iov_len);
+	cnt = iov_buf[0].iov_len ? syscall(SYS_readv, f->fd, iov_buf, 2)
+		: syscall(SYS_read, f->fd, iov_buf[1].iov_base, iov_buf[1].iov_len);
 	if (cnt <= 0) {
 		f->flags |= cnt ? F_ERR : F_EOF;
 		return 0;
 	}
-	if (cnt <= iov[0].iov_len) return cnt;
-	cnt -= iov[0].iov_len;
+	if (cnt <= iov_buf[0].iov_len) {
+		return cnt;
+	}
+	cnt -= iov_buf[0].iov_len;
 	f->rpos = f->buf;
 	f->rend = f->buf + cnt;
 	if (f->buf_size) buf[len-1] = *f->rpos++;
diff --git a/src/stdio/__stdio_write.c b/src/stdio/__stdio_write.c
index d2d89475..6774a294 100644
--- a/src/stdio/__stdio_write.c
+++ b/src/stdio/__stdio_write.c
@@ -1,34 +1,64 @@
 #include "stdio_impl.h"
 #include <sys/uio.h>
+#include <string.h>
+
+ssize_t __flush_buffer(FILE *f)
+{
+	ssize_t cnt = 0;
+	char *wbase = (char *)f->wbase;
+	size_t rem = f->wpos - f->wbase;
+	while (rem > 0) {
+		cnt = syscall(SYS_write, f->fd, wbase, rem);
+		if (cnt < 0) {
+			f->wpos = f->wbase = f->wend = 0;
+			f->flags |= F_ERR;
+			return cnt;
+		}
+		wbase += cnt;
+		rem -= cnt;
+	}
+
+	/* reset file buffer */
+	f->wend = f->buf + f->buf_size;
+	f->wpos = f->wbase = f->buf;
+	return cnt;
+}
 
 size_t __stdio_write(FILE *f, const unsigned char *buf, size_t len)
 {
-	struct iovec iovs[2] = {
-		{ .iov_base = f->wbase, .iov_len = f->wpos-f->wbase },
-		{ .iov_base = (void *)buf, .iov_len = len }
-	};
-	struct iovec *iov = iovs;
-	size_t rem = iov[0].iov_len + iov[1].iov_len;
-	int iovcnt = 2;
-	ssize_t cnt;
+	size_t rem = len;
+	unsigned char *wbuf = (unsigned char *)buf;
+
+	/* flush buffer first */
+	ssize_t cnt = __flush_buffer(f);
+	if (cnt < 0) {
+		return 0;
+	}
+
 	for (;;) {
-		cnt = syscall(SYS_writev, f->fd, iov, iovcnt);
-		if (cnt == rem) {
-			f->wend = f->buf + f->buf_size;
-			f->wpos = f->wbase = f->buf;
+		if (f->lbf < 0 && rem <= f->wend - f->wpos) {
+			memcpy(f->wpos, wbuf, rem);
+			f->wpos += rem;
 			return len;
 		}
+
+		/* write directly if
+		 * 1. file buffer < rem
+		 * 2. line buffer mode
+		 */
+		cnt = syscall(SYS_write, f->fd, wbuf, rem);
 		if (cnt < 0) {
 			f->wpos = f->wbase = f->wend = 0;
 			f->flags |= F_ERR;
-			return iovcnt == 2 ? 0 : len-iov[0].iov_len;
+			return len - rem;
 		}
+
 		rem -= cnt;
-		if (cnt > iov[0].iov_len) {
-			cnt -= iov[0].iov_len;
-			iov++; iovcnt--;
+		wbuf += cnt;
+		if (rem == 0) {
+			break;
 		}
-		iov[0].iov_base = (char *)iov[0].iov_base + cnt;
-		iov[0].iov_len -= cnt;
 	}
+
+	return len;
 }
diff --git a/src/stdio/__stdout_write.c b/src/stdio/__stdout_write.c
index dd1ec60f..cd78374d 100644
--- a/src/stdio/__stdout_write.c
+++ b/src/stdio/__stdout_write.c
@@ -5,7 +5,14 @@ size_t __stdout_write(FILE *f, const unsigned char *buf, size_t len)
 {
 	struct winsize wsz;
 	f->write = __stdio_write;
+	/*
+	 * write directly at first time.
+	 * check f->flags & tty, and take effect later.
+	 */
+	size_t cnt = __stdio_write(f, buf, len);
+
 	if (!(f->flags & F_SVB) && __syscall(SYS_ioctl, f->fd, TIOCGWINSZ, &wsz))
 		f->lbf = -1;
-	return __stdio_write(f, buf, len);
+
+	return cnt;
 }
diff --git a/src/stdio/__toread.c b/src/stdio/__toread.c
index f142ff09..b03f878d 100644
--- a/src/stdio/__toread.c
+++ b/src/stdio/__toread.c
@@ -9,7 +9,15 @@ int __toread(FILE *f)
 		f->flags |= F_ERR;
 		return EOF;
 	}
+
+	/* Alloc file buffer if needed */
+	if (__falloc_buf(f) < 0) {
+		f->flags |= F_ERR;
+		return EOF;
+	}
+
 	f->rpos = f->rend = f->buf + f->buf_size;
+
 	return (f->flags & F_EOF) ? EOF : 0;
 }
 
diff --git a/src/stdio/__towrite.c b/src/stdio/__towrite.c
index 4c9c66ae..382a3abd 100644
--- a/src/stdio/__towrite.c
+++ b/src/stdio/__towrite.c
@@ -10,10 +10,15 @@ int __towrite(FILE *f)
 	/* Clear read buffer (easier than summoning nasal demons) */
 	f->rpos = f->rend = 0;
 
+	/* Alloc file buffer if needed */
+	if (__falloc_buf(f) < 0) {
+		f->flags |= F_ERR;
+		return EOF;
+	}
+
 	/* Activate write through the buffer. */
 	f->wpos = f->wbase = f->buf;
 	f->wend = f->buf + f->buf_size;
-
 	return 0;
 }
 
diff --git a/src/stdio/fclose.c b/src/stdio/fclose.c
index d594532b..38e1273f 100644
--- a/src/stdio/fclose.c
+++ b/src/stdio/fclose.c
@@ -25,14 +25,11 @@ int fclose(FILE *f)
 
 	__unlist_locked_file(f);
 
-	FILE **head = __ofl_lock();
-	if (f->prev) f->prev->next = f->next;
-	if (f->next) f->next->prev = f->prev;
-	if (*head == f) *head = f->next;
-	__ofl_unlock();
-
 	free(f->getln_buf);
-	free(f);
+	/* release base instead of buf which may be modified by setvbuf
+	 * or iniitalize by local variable */
+	free(f->base);
+	__ofl_free(f);
 
 	return r;
 }
diff --git a/src/stdio/fgets.c b/src/stdio/fgets.c
index 6171f398..4a2e81fd 100644
--- a/src/stdio/fgets.c
+++ b/src/stdio/fgets.c
@@ -2,7 +2,6 @@
 #include <string.h>
 
 #define MIN(a,b) ((a)<(b) ? (a) : (b))
-
 char *fgets(char *restrict s, int n, FILE *restrict f)
 {
 	char *p = s;
@@ -22,7 +21,7 @@ char *fgets(char *restrict s, int n, FILE *restrict f)
 
 	while (n) {
 		if (f->rpos != f->rend) {
-			z = memchr(f->rpos, '\n', f->rend - f->rpos);
+			z = memchr(f->rpos, '\n', MIN(f->rend - f->rpos, n));
 			k = z ? z - f->rpos + 1 : f->rend - f->rpos;
 			k = MIN(k, n);
 			memcpy(p, f->rpos, k);
@@ -45,4 +44,5 @@ char *fgets(char *restrict s, int n, FILE *restrict f)
 	return s;
 }
 
+
 weak_alias(fgets, fgets_unlocked);
diff --git a/src/stdio/fileno.c b/src/stdio/fileno.c
index 0bd0e988..1eea733c 100644
--- a/src/stdio/fileno.c
+++ b/src/stdio/fileno.c
@@ -1,11 +1,9 @@
 #include "stdio_impl.h"
 #include <errno.h>
 
-int fileno(FILE *f)
+int fileno_unlocked(FILE *f)
 {
-	FLOCK(f);
 	int fd = f->fd;
-	FUNLOCK(f);
 	if (fd < 0) {
 		errno = EBADF;
 		return -1;
@@ -13,4 +11,10 @@ int fileno(FILE *f)
 	return fd;
 }
 
-weak_alias(fileno, fileno_unlocked);
+int fileno(FILE *f)
+{
+	FLOCK(f);
+	int fd = fileno_unlocked(f);
+	FUNLOCK(f);
+	return fd;
+}
diff --git a/src/stdio/fmemopen.c b/src/stdio/fmemopen.c
index 343e3e3f..bb857e5a 100644
--- a/src/stdio/fmemopen.c
+++ b/src/stdio/fmemopen.c
@@ -117,6 +117,7 @@ FILE *fmemopen(void *restrict buf, size_t size, const char *restrict mode)
 	else if (plus) *f->c.buf = 0;
 
 	f->f.read = mread;
+	f->f.readx = mread;
 	f->f.write = mwrite;
 	f->f.seek = mseek;
 	f->f.close = mclose;
diff --git a/src/stdio/fopen.c b/src/stdio/fopen.c
index e1b91e12..b0e66aef 100644
--- a/src/stdio/fopen.c
+++ b/src/stdio/fopen.c
@@ -5,26 +5,26 @@
 
 FILE *fopen(const char *restrict filename, const char *restrict mode)
 {
-	FILE *f;
-	int fd;
-	int flags;
-
-	/* Check for valid initial mode character */
-	if (!strchr("rwa", *mode)) {
-		errno = EINVAL;
-		return 0;
-	}
+	FILE *f = NULL;
+	int fd = -1;
+	int file_flags = 0;
+	int mode_flags = 0;
 
 	/* Compute the flags to pass to open() */
-	flags = __fmodeflags(mode);
+	mode_flags = __fmodeflags(mode, &file_flags);
+	if (mode_flags < 0) {
+		return NULL;
+	}
 
-	fd = sys_open(filename, flags, 0666);
+	fd = sys_open(filename, mode_flags, 0666);
 	if (fd < 0) return 0;
-	if (flags & O_CLOEXEC)
+	if (mode_flags & O_CLOEXEC)
 		__syscall(SYS_fcntl, fd, F_SETFD, FD_CLOEXEC);
 
-	f = __fdopen(fd, mode);
-	if (f) return f;
+	f = __fdopenx(fd, file_flags);
+	if (f) {
+		return f;
+	}
 
 	__syscall(SYS_close, fd);
 	return 0;
diff --git a/src/stdio/fread.c b/src/stdio/fread.c
index a2116da6..38b685c1 100644
--- a/src/stdio/fread.c
+++ b/src/stdio/fread.c
@@ -3,36 +3,80 @@
 
 #define MIN(a,b) ((a)<(b) ? (a) : (b))
 
+int __fill_buffer(FILE *f)
+{
+	int r = __toread(f);
+	if (r != 0) {
+		return r;
+	}
+
+	int k = f->readx(f, f->buf, f->buf_size);
+	if (k <= 0) {
+		f->flags |= (k == 0) ? F_EOF : F_ERR;
+		f->rpos = f->rend;
+		return k;
+	}
+
+	f->rpos = f->buf;
+	f->rend = f->rpos + k;
+
+	return 0;
+}
+
 size_t fread(void *restrict destv, size_t size, size_t nmemb, FILE *restrict f)
 {
 	unsigned char *dest = destv;
-	size_t len = size*nmemb, l = len, k;
-	if (!size) nmemb = 0;
+	size_t len = size * nmemb, l = len, k;
+	if (!size) {
+		nmemb = 0;
+	}
 
 	FLOCK(f);
 
+	/* allocate file buffer if needed */
+	if (__falloc_buf(f) < 0) {
+		f->flags |= F_ERR;
+		goto exit;
+	}
+
 	f->mode |= f->mode-1;
 
-	if (f->rpos != f->rend) {
-		/* First exhaust the buffer. */
-		k = MIN(f->rend - f->rpos, l);
-		memcpy(dest, f->rpos, k);
-		f->rpos += k;
-		dest += k;
-		l -= k;
+	while (l > 0) {
+		if (f->rpos != f->rend) {
+			/* First exhaust the buffer. */
+			k = MIN(f->rend - f->rpos, l);
+			memcpy(dest, f->rpos, k);
+			f->rpos += k;
+			dest += k;
+			l -= k;
+		}
+		/* done */
+		if (l == 0) {
+			goto exit;
+		}
+		/* if user buffer is longer than file buffer,
+		 * maybe buffer size is 0, non-buffer mode,
+		 * read directly */
+		if (l > f->buf_size) {
+			break;
+		}
+
+		if (__fill_buffer(f)) {
+			goto exit;
+		}
 	}
-	
+
 	/* Read the remainder directly */
 	for (; l; l-=k, dest+=k) {
-		k = __toread(f) ? 0 : f->read(f, dest, l);
+		k = f->readx(f, dest, l);
 		if (!k) {
-			FUNLOCK(f);
-			return (len-l)/size;
+			break;
 		}
 	}
 
+exit:
 	FUNLOCK(f);
-	return nmemb;
+	return (len - l) / size;
 }
 
 weak_alias(fread, fread_unlocked);
diff --git a/src/stdio/freopen.c b/src/stdio/freopen.c
index 615d4b47..0f4ea987 100644
--- a/src/stdio/freopen.c
+++ b/src/stdio/freopen.c
@@ -12,7 +12,8 @@
 
 FILE *freopen(const char *restrict filename, const char *restrict mode, FILE *restrict f)
 {
-	int fl = __fmodeflags(mode);
+	int file_flags = 0;
+	int fl = __fmodeflags(mode, &file_flags);
 	FILE *f2;
 
 	FLOCK(f);
@@ -23,16 +24,22 @@ FILE *freopen(const char *restrict filename, const char *restrict mode, FILE *re
 		if (fl&O_CLOEXEC)
 			__syscall(SYS_fcntl, f->fd, F_SETFD, FD_CLOEXEC);
 		fl &= ~(O_CREAT|O_EXCL|O_CLOEXEC);
-		if (syscall(SYS_fcntl, f->fd, F_SETFL, fl) < 0)
+		if (syscall(SYS_fcntl, f->fd, F_SETFL, fl) < 0) {
 			goto fail;
+		}
 	} else {
 		f2 = fopen(filename, mode);
 		if (!f2) goto fail;
-		if (f2->fd == f->fd) f2->fd = -1; /* avoid closing in fclose */
-		else if (__dup3(f2->fd, f->fd, fl&O_CLOEXEC)<0) goto fail2;
+		if (f2->fd == f->fd) {
+			f2->fd = -1; /* avoid closing in fclose */
+		}
+		else if (__dup3(f2->fd, f->fd, fl&O_CLOEXEC)<0) {
+			goto fail2;
+		}
 
 		f->flags = (f->flags & F_PERM) | f2->flags;
 		f->read = f2->read;
+		f->readx = f2->readx;
 		f->write = f2->write;
 		f->seek = f2->seek;
 		f->close = f2->close;
diff --git a/src/stdio/ofl.c b/src/stdio/ofl.c
index aad3d171..adcd8989 100644
--- a/src/stdio/ofl.c
+++ b/src/stdio/ofl.c
@@ -1,8 +1,13 @@
 #include "stdio_impl.h"
 #include "lock.h"
 #include "fork_impl.h"
+#include <stdlib.h>
+
+#define DEFAULT_ALLOC_FILE (8)
+
+static FILE *ofl_head = NULL;
+static FILE *ofl_free = NULL;
 
-static FILE *ofl_head;
 static volatile int ofl_lock[1];
 volatile int *const __stdio_ofl_lockptr = ofl_lock;
 
@@ -16,3 +21,77 @@ void __ofl_unlock()
 {
 	UNLOCK(ofl_lock);
 }
+
+FILE *__ofl_alloc()
+{
+	unsigned char *fsb = NULL;
+	size_t cnt = 0;
+	FILE *f = NULL;
+
+	LOCK(ofl_lock);
+	if (ofl_free) {
+		f = ofl_free;
+		ofl_free = ofl_free->next;
+		UNLOCK(ofl_lock);
+
+		return f;
+	}
+	UNLOCK(ofl_lock);
+
+	/* alloc new FILEs(8) */
+	fsb = (unsigned char *)malloc(DEFAULT_ALLOC_FILE * sizeof(FILE));
+	if (!fsb) {
+		return NULL;
+	}
+
+	LOCK(ofl_lock);
+	ofl_free = (FILE*)fsb;
+	ofl_free->prev = NULL;
+	f = ofl_free;
+
+	for (cnt = 1; cnt < DEFAULT_ALLOC_FILE; cnt++) {
+		FILE *tmp = (FILE*)(fsb + cnt * sizeof(FILE));
+		tmp->next = NULL;
+		f->next = tmp;
+		tmp->prev = f;
+		f = f->next;
+	}
+
+	/* reset and move to next free FILE */
+	f = ofl_free;
+	ofl_free = ofl_free->next;
+	if (ofl_free) {
+		ofl_free->prev = NULL;
+	}
+
+	UNLOCK(ofl_lock);
+	return f;
+}
+
+void __ofl_free(FILE *f)
+{
+	LOCK(ofl_lock);
+	if (!f) {
+		return;
+	}
+
+	/* remove from head list */
+	if (f->prev) {
+		f->prev->next = f->next;
+	}
+	if (f->next) {
+		f->next->prev = f->prev;
+	}
+	if (f == ofl_head) {
+		ofl_head = f->next;
+	}
+
+	/* push to free list */
+	f->next = ofl_free;
+	if (ofl_free) {
+		ofl_free->prev = f;
+	}
+	ofl_free = f;
+
+	UNLOCK(ofl_lock);
+}
diff --git a/src/stdio/setvbuf.c b/src/stdio/setvbuf.c
index 523dddc8..2fcd41db 100644
--- a/src/stdio/setvbuf.c
+++ b/src/stdio/setvbuf.c
@@ -12,6 +12,7 @@ int setvbuf(FILE *restrict f, char *restrict buf, int type, size_t size)
 
 	if (type == _IONBF) {
 		f->buf_size = 0;
+		f->flags |= F_NOBUF;
 	} else if (type == _IOLBF || type == _IOFBF) {
 		if (buf && size >= UNGET) {
 			f->buf = (void *)(buf + UNGET);
@@ -19,6 +20,7 @@ int setvbuf(FILE *restrict f, char *restrict buf, int type, size_t size)
 		}
 		if (type == _IOLBF && f->buf_size)
 			f->lbf = '\n';
+		f->flags &= ~F_NOBUF;
 	} else {
 		return -1;
 	}
diff --git a/src/stdio/stderr.c b/src/stdio/stderr.c
index f2bc4648..4dd73a5b 100644
--- a/src/stdio/stderr.c
+++ b/src/stdio/stderr.c
@@ -7,7 +7,7 @@ hidden FILE __stderr_FILE = {
 	.buf = buf+UNGET,
 	.buf_size = 0,
 	.fd = 2,
-	.flags = F_PERM | F_NORD,
+	.flags = F_PERM | F_NORD | F_NOBUF,
 	.lbf = -1,
 	.write = __stdio_write,
 	.seek = __stdio_seek,
diff --git a/src/stdio/stdin.c b/src/stdio/stdin.c
index 5aa5262c..ca7b27c3 100644
--- a/src/stdio/stdin.c
+++ b/src/stdio/stdin.c
@@ -9,6 +9,7 @@ hidden FILE __stdin_FILE = {
 	.fd = 0,
 	.flags = F_PERM | F_NOWR,
 	.read = __stdio_read,
+	.readx = __stdio_readx,
 	.seek = __stdio_seek,
 	.close = __stdio_close,
 	.lock = -1,
diff --git a/src/stdio/vfprintf.c b/src/stdio/vfprintf.c
index 9b961e7f..45ac0fab 100644
--- a/src/stdio/vfprintf.c
+++ b/src/stdio/vfprintf.c
@@ -132,7 +132,14 @@ static void pop_arg(union arg *arg, int type, va_list *ap)
 
 static void out(FILE *f, const char *s, size_t l)
 {
-	if (!(f->flags & F_ERR)) __fwritex((void *)s, l, f);
+	/* write to file buffer if flag F_PBUF is available */
+	if (!(f->flags & F_ERR) && !(f->flags & F_PBUF)) {
+		__fwritex((void *)s, l, f);
+		return;
+	}
+
+	/* otherwise, copy to buffer directly */
+	f->write(f, (void *)s, l);
 }
 
 static void pad(FILE *f, char c, int w, int l, int fl)
@@ -427,7 +434,7 @@ static int getint(char **s) {
 	return i;
 }
 
-static int printf_core(FILE *f, const char *fmt, va_list *ap, union arg *nl_arg, int *nl_type)
+static int printf_core(FILE *f, const char *fmt, va_list *ap, union arg *nl_arg, int *nl_type, char nl_arg_filled)
 {
 	char *a, *z, *s=(char *)fmt;
 	unsigned l10n=0, fl;
@@ -437,7 +444,6 @@ static int printf_core(FILE *f, const char *fmt, va_list *ap, union arg *nl_arg,
 	unsigned st, ps;
 	int cnt=0, l=0;
 	size_t i;
-	char buf[sizeof(uintmax_t)*3+3+LDBL_MANT_DIG/4];
 	const char *prefix;
 	int t, pl;
 	wchar_t wc[2], *ws;
@@ -462,6 +468,14 @@ static int printf_core(FILE *f, const char *fmt, va_list *ap, union arg *nl_arg,
 		if (l) continue;
 
 		if (isdigit(s[1]) && s[2]=='$') {
+			if (!nl_arg_filled) {
+				va_list ap_copy;
+				va_copy(ap_copy, *ap);
+				if (printf_core(0, fmt, &ap_copy, nl_arg, nl_type, 1) < 0) {
+					return -1;
+				}
+				va_end(ap_copy);
+			}
 			l10n=1;
 			argpos = s[1]-'0';
 			s+=3;
@@ -528,6 +542,7 @@ static int printf_core(FILE *f, const char *fmt, va_list *ap, union arg *nl_arg,
 
 		if (!f) continue;
 
+		char buf[sizeof(uintmax_t)*3+3+LDBL_MANT_DIG/4];
 		z = buf + sizeof(buf);
 		prefix = "-+   0X0x";
 		pl = 0;
@@ -665,24 +680,23 @@ int vfprintf(FILE *restrict f, const char *restrict fmt, va_list ap)
 
 	/* the copy allows passing va_list* even if va_list is an array */
 	va_copy(ap2, ap);
-	if (printf_core(0, fmt, &ap2, nl_arg, nl_type) < 0) {
-		va_end(ap2);
-		return -1;
-	}
 
 	FLOCK(f);
 	olderr = f->flags & F_ERR;
 	if (f->mode < 1) f->flags &= ~F_ERR;
-	if (!f->buf_size) {
+
+	if (!f->buf_size && f->buf != NULL) {
 		saved_buf = f->buf;
 		f->buf = internal_buf;
 		f->buf_size = sizeof internal_buf;
 		f->wpos = f->wbase = f->wend = 0;
 	}
 	if (!f->wend && __towrite(f)) ret = -1;
-	else ret = printf_core(f, fmt, &ap2, nl_arg, nl_type);
+	else ret = printf_core(f, fmt, &ap2, nl_arg, nl_type, 0);
 	if (saved_buf) {
-		f->write(f, 0, 0);
+		if (!(f->flags & F_PBUF)) {
+			f->write(f, 0, 0);
+		}
 		if (!f->wpos) ret = -1;
 		f->buf = saved_buf;
 		f->buf_size = 0;
diff --git a/src/stdio/vfscanf.c b/src/stdio/vfscanf.c
index b78a374d..67b48eea 100644
--- a/src/stdio/vfscanf.c
+++ b/src/stdio/vfscanf.c
@@ -18,6 +18,11 @@
 #define SIZE_l   1
 #define SIZE_L   2
 #define SIZE_ll  3
+#define BUF_LEN 513
+
+#if (defined(MUSL_AARCH64_ARCH)) || (defined(MUSL_ARM_ARCH))
+extern int parsefloat(FILE *f, char *buf, char *end);
+#endif
 
 static void store_int(void *dest, int size, unsigned long long i)
 {
@@ -55,6 +60,10 @@ static void *arg_n(va_list ap, unsigned int n)
 
 int vfscanf(FILE *restrict f, const char *restrict fmt, va_list ap)
 {
+#if (defined(MUSL_AARCH64_ARCH)) || (defined(MUSL_ARM_ARCH))
+	char buf[BUF_LEN];
+	char *endptr;
+#endif
 	int width;
 	int size;
 	int alloc = 0;
@@ -302,6 +311,29 @@ int vfscanf(FILE *restrict f, const char *restrict fmt, va_list ap)
 		case 'e': case 'E':
 		case 'f': case 'F':
 		case 'g': case 'G':
+#if (defined(MUSL_AARCH64_ARCH)) || (defined(MUSL_ARM_ARCH))
+			if (width == 0 || width > sizeof(buf) - 1)
+				width = sizeof(buf) - 1;
+			int count = parsefloat(f, buf, buf + width);
+			if (count == 0)
+				goto match_fail;
+			if (dest) switch (size) {
+			case SIZE_def:
+				y = strtof(buf, &endptr);
+				*(float *)dest = y;
+				break;
+			case SIZE_l:
+				y = strtod(buf, &endptr);
+				*(double *)dest = y;
+				break;
+			case SIZE_L:
+				y = strtold(buf, &endptr);
+				*(long double *)dest = y;
+				break;
+			}
+			break;
+		}
+#else
 			y = __floatscan(f, size, 0);
 			if (!shcnt(f)) goto match_fail;
 			if (dest) switch (size) {
@@ -317,7 +349,7 @@ int vfscanf(FILE *restrict f, const char *restrict fmt, va_list ap)
 			}
 			break;
 		}
-
+#endif
 		pos += shcnt(f);
 		if (dest) matches++;
 	}
diff --git a/src/stdio/vsnprintf.c b/src/stdio/vsnprintf.c
index b3510a63..65cb0f7b 100644
--- a/src/stdio/vsnprintf.c
+++ b/src/stdio/vsnprintf.c
@@ -14,35 +14,29 @@ struct cookie {
 static size_t sn_write(FILE *f, const unsigned char *s, size_t l)
 {
 	struct cookie *c = f->cookie;
-	size_t k = MIN(c->n, f->wpos - f->wbase);
-	if (k) {
-		memcpy(c->s, f->wbase, k);
-		c->s += k;
-		c->n -= k;
+	size_t already_size = f->wpos - f->wbase;
+	if (already_size <= c->n) {
+		size_t k = MIN(l, c->n - already_size);
+		memcpy(f->wpos, s, k);
+		f->wpos += k;
+		*f->wpos = '\0';
 	}
-	k = MIN(c->n, l);
-	if (k) {
-		memcpy(c->s, s, k);
-		c->s += k;
-		c->n -= k;
-	}
-	*c->s = 0;
-	f->wpos = f->wbase = f->buf;
 	/* pretend to succeed, even if we discarded extra data */
 	return l;
 }
 
 int vsnprintf(char *restrict s, size_t n, const char *restrict fmt, va_list ap)
 {
-	unsigned char buf[1];
-	char dummy[1];
+	unsigned char dummy[1];
 	struct cookie c = { .s = n ? s : dummy, .n = n ? n-1 : 0 };
 	FILE f = {
 		.lbf = EOF,
-		.write = sn_write,
 		.lock = -1,
-		.buf = buf,
+		.buf = (unsigned char *)(n ? s: dummy),
+		.buf_size = n ? n - 1 : 0,
+		.flags = F_PBUF,
 		.cookie = &c,
+		.write = sn_write,
 	};
 
 	if (n > INT_MAX) {
@@ -50,6 +44,5 @@ int vsnprintf(char *restrict s, size_t n, const char *restrict fmt, va_list ap)
 		return -1;
 	}
 
-	*c.s = 0;
 	return vfprintf(&f, fmt, ap);
 }
diff --git a/src/stdio/vsscanf.c b/src/stdio/vsscanf.c
index 4d6d259b..f0c4a7d0 100644
--- a/src/stdio/vsscanf.c
+++ b/src/stdio/vsscanf.c
@@ -1,25 +1,19 @@
 #include "stdio_impl.h"
 #include <string.h>
 
+// Empty implementation because vfscanf operates rpos directly.
 static size_t string_read(FILE *f, unsigned char *buf, size_t len)
 {
-	char *src = f->cookie;
-	size_t k = len+256;
-	char *end = memchr(src, 0, k);
-	if (end) k = end-src;
-	if (k < len) len = k;
-	memcpy(buf, src, len);
-	f->rpos = (void *)(src+len);
-	f->rend = (void *)(src+k);
-	f->cookie = src+k;
-	return len;
+	return 0;
 }
 
 int vsscanf(const char *restrict s, const char *restrict fmt, va_list ap)
 {
+	size_t s_len = strlen(s);
 	FILE f = {
 		.buf = (void *)s, .cookie = (void *)s,
-		.read = string_read, .lock = -1
+		.read = string_read, .lock = -1,
+		.buf_size = s_len, .rpos = s, .rend = s + s_len,
 	};
 	return vfscanf(&f, fmt, ap);
 }
diff --git a/src/stdlib/strtod.c b/src/stdlib/strtod.c
index 39b9daad..b4af2335 100644
--- a/src/stdlib/strtod.c
+++ b/src/stdlib/strtod.c
@@ -3,6 +3,7 @@
 #include "floatscan.h"
 #include "stdio_impl.h"
 
+
 static long double strtox(const char *s, char **p, int prec)
 {
 	FILE f;
@@ -13,7 +14,7 @@ static long double strtox(const char *s, char **p, int prec)
 	if (p) *p = cnt ? (char *)s + cnt : (char *)s;
 	return y;
 }
-
+#if (!defined(MUSL_AARCH64_ARCH)) && (!defined(MUSL_ARM_ARCH))
 float strtof(const char *restrict s, char **restrict p)
 {
 	return strtox(s, p, 0);
@@ -23,6 +24,7 @@ double strtod(const char *restrict s, char **restrict p)
 {
 	return strtox(s, p, 1);
 }
+#endif
 
 long double strtold(const char *restrict s, char **restrict p)
 {
diff --git a/src/string/stpncpy.c b/src/string/stpncpy.c
index f57fa6b7..63dcfd9b 100644
--- a/src/string/stpncpy.c
+++ b/src/string/stpncpy.c
@@ -1,32 +1,20 @@
-#include <string.h>
-#include <stdint.h>
-#include <limits.h>
-
-#define ALIGN (sizeof(size_t)-1)
-#define ONES ((size_t)-1/UCHAR_MAX)
-#define HIGHS (ONES * (UCHAR_MAX/2+1))
-#define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)
-
-char *__stpncpy(char *restrict d, const char *restrict s, size_t n)
-{
-#ifdef __GNUC__
-	typedef size_t __attribute__((__may_alias__)) word;
-	word *wd;
-	const word *ws;
-	if (((uintptr_t)s & ALIGN) == ((uintptr_t)d & ALIGN)) {
-		for (; ((uintptr_t)s & ALIGN) && n && (*d=*s); n--, s++, d++);
-		if (!n || !*s) goto tail;
-		wd=(void *)d; ws=(const void *)s;
-		for (; n>=sizeof(size_t) && !HASZERO(*ws);
-		       n-=sizeof(size_t), ws++, wd++) *wd = *ws;
-		d=(void *)wd; s=(const void *)ws;
-	}
-#endif
-	for (; n && (*d=*s); n--, s++, d++);
-tail:
-	memset(d, 0, n);
-	return d;
-}
-
-weak_alias(__stpncpy, stpncpy);
-
+#include <string.h>
+
+char *__stpncpy(char *dst, const char *src, size_t n)
+{
+	char *d = dst, *s = src;
+	dst = &dst[n];
+	while (n > 0){
+		if((*d++ = *src++) == 0){
+			dst = d - 1;
+			while(--n > 0){
+				*d++ = 0;
+			}
+			break;
+		}
+		n--;
+	}
+	return (dst);
+}
+
+weak_alias(__stpncpy, stpncpy);
diff --git a/src/string/strcasecmp.c b/src/string/strcasecmp.c
index 002c6aa1..92c2c89f 100644
--- a/src/string/strcasecmp.c
+++ b/src/string/strcasecmp.c
@@ -1,16 +1,17 @@
 #include <strings.h>
 #include <ctype.h>
 
-int strcasecmp(const char *_l, const char *_r)
+int __strcasecmp(const char *_l, const char *_r)
 {
-	const unsigned char *l=(void *)_l, *r=(void *)_r;
-	for (; *l && *r && (*l == *r || tolower(*l) == tolower(*r)); l++, r++);
-	return tolower(*l) - tolower(*r);
+    const unsigned char *l=(void *)_l, *r=(void *)_r;
+    for (; *l && *r && (*l == *r || tolower(*l) == tolower(*r)); l++, r++);
+    return tolower(*l) - tolower(*r);
 }
+weak_alias(__strcasecmp, strcasecmp);
 
 int __strcasecmp_l(const char *l, const char *r, locale_t loc)
 {
 	return strcasecmp(l, r);
 }
 
-weak_alias(__strcasecmp_l, strcasecmp_l);
+weak_alias(__strcasecmp_l, strcasecmp_l);
\ No newline at end of file
diff --git a/src/string/strcspn.c b/src/string/strcspn.c
index a0c617bd..23b84cdf 100644
--- a/src/string/strcspn.c
+++ b/src/string/strcspn.c
@@ -1,17 +1,20 @@
-#include <string.h>
-
-#define BITOP(a,b,op) \
- ((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))
-
-size_t strcspn(const char *s, const char *c)
-{
-	const char *a = s;
-	size_t byteset[32/sizeof(size_t)];
-
-	if (!c[0] || !c[1]) return __strchrnul(s, *c)-a;
-
-	memset(byteset, 0, sizeof byteset);
-	for (; *c && BITOP(byteset, *(unsigned char *)c, |=); c++);
-	for (; *s && !BITOP(byteset, *(unsigned char *)s, &); s++);
-	return s-a;
-}
+// from openbsd, will be rectified later
+
+#include <string.h>
+
+size_t strcspn(const char *string1, const char *string2)
+{
+	const char *a, *p;
+	char sc, c;
+    
+	for (a = string1;;) {
+		sc = *a++;
+		p = string2;
+		do {
+			if ((c = *p++) == sc) {
+				return (a - 1 - string1);
+                        }
+		} while (c != 0);
+	}
+	/* NOTREACHED */
+}
\ No newline at end of file
diff --git a/src/string/strncasecmp.c b/src/string/strncasecmp.c
index e0ef93c2..03d13a97 100644
--- a/src/string/strncasecmp.c
+++ b/src/string/strncasecmp.c
@@ -1,17 +1,18 @@
 #include <strings.h>
 #include <ctype.h>
 
-int strncasecmp(const char *_l, const char *_r, size_t n)
+int __strncasecmp(const char *_l, const char *_r, size_t n)
 {
-	const unsigned char *l=(void *)_l, *r=(void *)_r;
-	if (!n--) return 0;
-	for (; *l && *r && n && (*l == *r || tolower(*l) == tolower(*r)); l++, r++, n--);
-	return tolower(*l) - tolower(*r);
+    const unsigned char *l=(void *)_l, *r=(void *)_r;
+    if (!n--) return 0;
+    for (; *l && *r && n && (*l == *r || tolower(*l) == tolower(*r)); l++, r++, n--);
+    return tolower(*l) - tolower(*r);
 }
+weak_alias(__strncasecmp, strncasecmp);
 
 int __strncasecmp_l(const char *l, const char *r, size_t n, locale_t loc)
 {
 	return strncasecmp(l, r, n);
 }
 
-weak_alias(__strncasecmp_l, strncasecmp_l);
+weak_alias(__strncasecmp_l, strncasecmp_l);
\ No newline at end of file
diff --git a/src/string/strncat.c b/src/string/strncat.c
index 01ca2a23..01fc0a02 100644
--- a/src/string/strncat.c
+++ b/src/string/strncat.c
@@ -3,7 +3,7 @@
 char *strncat(char *restrict d, const char *restrict s, size_t n)
 {
 	char *a = d;
-	d += strlen(d);
+	while (*d != 0) d++;
 	while (n && *s) n--, *d++ = *s++;
 	*d++ = 0;
 	return a;
diff --git a/src/string/strncpy.c b/src/string/strncpy.c
index 545892e6..54838a6e 100644
--- a/src/string/strncpy.c
+++ b/src/string/strncpy.c
@@ -1,7 +1,14 @@
-#include <string.h>
-
-char *strncpy(char *restrict d, const char *restrict s, size_t n)
-{
-	__stpncpy(d, s, n);
-	return d;
-}
+#include <string.h>
+
+char *strncpy(char *dst, const char *src, size_t n)
+{
+	char *d = dst, *s = src;
+	while (n > 0){
+		if((*d = *s) != 0){
+			s++;
+		}
+		d++;
+		n--;
+	}
+	return (dst);
+}
\ No newline at end of file
diff --git a/src/thread/arm/clone.s b/src/thread/arm/clone.s
index bb0965da..2070dd51 100644
--- a/src/thread/arm/clone.s
+++ b/src/thread/arm/clone.s
@@ -3,8 +3,14 @@
 .global __clone
 .hidden __clone
 .type   __clone,%function
+.cfi_startproc
 __clone:
 	stmfd sp!,{r4,r5,r6,r7}
+	.cfi_def_cfa_offset 16
+	.cfi_rel_offset r4, 0
+	.cfi_rel_offset r5, 4
+	.cfi_rel_offset r6, 8
+	.cfi_rel_offset r7, 12
 	mov r7,#120
 	mov r6,r3
 	mov r5,r0
@@ -17,6 +23,7 @@ __clone:
 	tst r0,r0
 	beq 1f
 	ldmfd sp!,{r4,r5,r6,r7}
+	.cfi_def_cfa_offset 0
 	bx lr
 
 1:	mov r0,r6
@@ -26,3 +33,4 @@ __clone:
 	b 2b
 
 3:	bx r5
+.cfi_endproc
\ No newline at end of file
diff --git a/src/thread/arm/syscall_cp.s b/src/thread/arm/syscall_cp.s
index e607dd42..03a83dc9 100644
--- a/src/thread/arm/syscall_cp.s
+++ b/src/thread/arm/syscall_cp.s
@@ -7,11 +7,16 @@
 .hidden __cp_cancel
 .hidden __cancel
 .global __syscall_cp_asm
-.hidden __syscall_cp_asm
 .type __syscall_cp_asm,%function
+.cfi_startproc
 __syscall_cp_asm:
 	mov ip,sp
 	stmfd sp!,{r4,r5,r6,r7}
+	.cfi_def_cfa_offset 16
+	.cfi_rel_offset r4, 0
+	.cfi_rel_offset r5, 4
+	.cfi_rel_offset r6, 8
+	.cfi_rel_offset r7, 12
 __cp_begin:
 	ldr r0,[r0]
 	cmp r0,#0
@@ -23,7 +28,10 @@ __cp_begin:
 	svc 0
 __cp_end:
 	ldmfd sp!,{r4,r5,r6,r7}
+	.cfi_def_cfa_offset 0
 	bx lr
 __cp_cancel:
 	ldmfd sp!,{r4,r5,r6,r7}
+	.cfi_def_cfa_offset 0
 	b __cancel
+.cfi_endproc	
diff --git a/src/thread/pthread_cancel.c b/src/thread/pthread_cancel.c
index 2f9d5e97..f9e5c611 100644
--- a/src/thread/pthread_cancel.c
+++ b/src/thread/pthread_cancel.c
@@ -3,6 +3,7 @@
 #include "pthread_impl.h"
 #include "syscall.h"
 
+#ifdef FEATURE_PTHREAD_CANCEL
 hidden long __cancel(), __syscall_cp_asm(), __syscall_cp_c();
 
 long __cancel()
@@ -99,3 +100,12 @@ int pthread_cancel(pthread_t t)
 	}
 	return pthread_kill(t, SIGCANCEL);
 }
+#else
+hidden long __cancel()
+{
+}
+
+int pthread_cancel(pthread_t t)
+{
+}
+#endif
diff --git a/src/thread/pthread_cond_clockwait.c b/src/thread/pthread_cond_clockwait.c
new file mode 100644
index 00000000..ae0d04d2
--- /dev/null
+++ b/src/thread/pthread_cond_clockwait.c
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "pthread_impl.h"
+
+int pthread_cond_clockwait(pthread_cond_t *cond, pthread_mutex_t *mutex,
+                           clockid_t clock_id, const struct timespec *abs_timeout)
+{
+    if (cond == NULL) {
+        return EINVAL;
+    }
+    switch (clock_id) {
+        case CLOCK_MONOTONIC:
+            cond->_c_clock = CLOCK_MONOTONIC;
+            return __pthread_cond_timedwait(cond, mutex, abs_timeout);
+        case CLOCK_REALTIME:
+            cond->_c_clock = CLOCK_REALTIME;
+            return __pthread_cond_timedwait(cond, mutex, abs_timeout);
+        default:
+            return EINVAL;
+    }
+}
\ No newline at end of file
diff --git a/src/thread/pthread_cond_init.c b/src/thread/pthread_cond_init.c
index 8c484ddc..bd2fc6a1 100644
--- a/src/thread/pthread_cond_init.c
+++ b/src/thread/pthread_cond_init.c
@@ -2,7 +2,7 @@
 
 int pthread_cond_init(pthread_cond_t *restrict c, const pthread_condattr_t *restrict a)
 {
-	*c = (pthread_cond_t){0};
+	__builtin_memset(c, 0, sizeof(pthread_cond_t));
 	if (a) {
 		c->_c_clock = a->__attr & 0x7fffffff;
 		if (a->__attr>>31) c->_c_shared = (void *)-1;
diff --git a/src/thread/pthread_cond_timedwait_monotonic_np.c b/src/thread/pthread_cond_timedwait_monotonic_np.c
new file mode 100644
index 00000000..bdeca2a8
--- /dev/null
+++ b/src/thread/pthread_cond_timedwait_monotonic_np.c
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "pthread_impl.h"
+
+int pthread_cond_timedwait_monotonic_np(pthread_cond_t *cond, pthread_mutex_t *mutex,
+                                        const struct timespec *abs_timeout)
+{
+    if (cond == NULL) {
+        return EINVAL;
+    }
+    cond->_c_clock = CLOCK_MONOTONIC;
+    return __pthread_cond_timedwait(cond, mutex, abs_timeout);
+}
\ No newline at end of file
diff --git a/src/thread/pthread_cond_timeout_np.c b/src/thread/pthread_cond_timeout_np.c
new file mode 100644
index 00000000..37c4423e
--- /dev/null
+++ b/src/thread/pthread_cond_timeout_np.c
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "pthread_impl.h"
+
+int pthread_cond_timeout_np(pthread_cond_t *cond, pthread_mutex_t *mutex, unsigned int ms)
+{
+    struct timespec ts;
+    __timespec_from_ms(&ts, ms);
+    struct timespec abs_timeout;
+    __absolute_timespec_from_timespec(&abs_timeout, &ts, CLOCK_MONOTONIC);
+    return pthread_cond_timedwait_monotonic_np(cond, mutex, &abs_timeout);
+}
diff --git a/src/thread/pthread_create.c b/src/thread/pthread_create.c
index d539880e..1ef15f1e 100644
--- a/src/thread/pthread_create.c
+++ b/src/thread/pthread_create.c
@@ -1,13 +1,18 @@
 #define _GNU_SOURCE
+#define ANON_STACK_NAME_SIZE 50
+#include "musl_log.h"
 #include "pthread_impl.h"
 #include "stdio_impl.h"
 #include "libc.h"
 #include "lock.h"
 #include <sys/mman.h>
+#include <sys/prctl.h>
 #include <string.h>
 #include <stddef.h>
 #include <stdarg.h>
 
+pid_t getpid(void);
+
 void log_print(const char* info,...)
 {
     va_list ap;
@@ -16,6 +21,76 @@ void log_print(const char* info,...)
     va_end(ap);
 }
 
+void stack_naming(struct pthread *new){
+	size_t size_len;
+	unsigned char *start_addr;
+	char name[ANON_STACK_NAME_SIZE];
+	if (new->guard_size) {
+		snprintf(name, ANON_STACK_NAME_SIZE, "guard:%d", new->tid);
+		prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, new->map_base, new->guard_size, name);
+		start_addr = new->map_base + new->guard_size;
+		size_len = new->map_size - new->guard_size;
+		memset(name, 0, ANON_STACK_NAME_SIZE);
+	} else {
+		start_addr = new->map_base;
+		size_len = new->map_size;
+	}
+	snprintf(name, ANON_STACK_NAME_SIZE, "stack:%d", new->tid);
+	prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, start_addr, size_len, name);
+};
+
+#ifdef RESERVE_SIGNAL_STACK
+#if defined (__LP64__)
+#define RESERVE_SIGNAL_STACK_SIZE (32 * 1024)
+#else
+#define RESERVE_SIGNAL_STACK_SIZE (20 * 1024)
+#endif
+void __pthread_reserve_signal_stack()
+{
+	void* stack = mmap(NULL, RESERVE_SIGNAL_STACK_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1 , 0);
+	if (stack != MAP_FAILED) {
+		if (mprotect(stack, __default_guardsize, PROT_NONE) == -1) {
+			munmap(stack, RESERVE_SIGNAL_STACK_SIZE);
+			return;
+		}
+	}
+
+	stack_t signal_stack;
+	signal_stack.ss_sp = (uint8_t*)stack + __default_guardsize;
+	signal_stack.ss_size = RESERVE_SIGNAL_STACK_SIZE - __default_guardsize;
+	signal_stack.ss_flags = 0;
+	sigaltstack(&signal_stack, NULL);
+
+	pthread_t self = __pthread_self();
+	self->signal_stack = stack;
+	char name[ANON_STACK_NAME_SIZE];
+	snprintf(name, ANON_STACK_NAME_SIZE, "signal_stack:%d", __pthread_self()->tid);
+	prctl(PR_SET_VMA, PR_SET_VMA_ANON_NAME, signal_stack.ss_sp, signal_stack.ss_size, name);
+	return;
+}
+
+void __pthread_release_signal_stack()
+{
+	pthread_t self = __pthread_self();
+	if (self->signal_stack == NULL) {
+		return;
+	}
+
+	stack_t signal_stack, old_stack;
+	memset(&signal_stack, 0, sizeof(signal_stack));
+	signal_stack.ss_flags = SS_DISABLE;
+	sigaltstack(&signal_stack, &old_stack);
+	munmap(self->signal_stack, __default_guardsize);
+	if (old_stack.ss_flags != SS_DISABLE) {
+		munmap(old_stack.ss_sp, old_stack.ss_size);
+	}
+	self->signal_stack = NULL;
+}
+
+weak_alias(__pthread_reserve_signal_stack, pthread_reserve_signal_stack);
+weak_alias(__pthread_release_signal_stack, pthread_release_signal_stack);
+#endif
+
 static void dummy_0()
 {
 }
@@ -65,8 +140,10 @@ _Noreturn void __pthread_exit(void *result)
 	pthread_t self = __pthread_self();
 	sigset_t set;
 
+#ifdef FEATURE_PTHREAD_CANCEL
 	self->canceldisable = 1;
 	self->cancelasync = 0;
+#endif
 	self->result = result;
 
 	while (self->cancelbuf) {
@@ -103,6 +180,9 @@ _Noreturn void __pthread_exit(void *result)
 	 * application signals being blocked above. */
 	__tl_lock();
 
+#ifdef RESERVE_SIGNAL_STACK
+	__pthread_release_signal_stack();
+#endif
 	/* If this is the only thread in the list, don't proceed with
 	 * termination of the thread, but restore the previous lock and
 	 * signal state to prepare for exit to call atexit handlers. */
@@ -209,12 +289,18 @@ static int start(void *p)
 		}
 	}
 	__syscall(SYS_rt_sigprocmask, SIG_SETMASK, &args->sig_mask, 0, _NSIG/8);
+#ifdef RESERVE_SIGNAL_STACK
+	__pthread_reserve_signal_stack();
+#endif
 	__pthread_exit(args->start_func(args->start_arg));
 	return 0;
 }
 
 static int start_c11(void *p)
 {
+#ifdef RESERVE_SIGNAL_STACK
+	__pthread_reserve_signal_stack();
+#endif
 	struct start_args *args = p;
 	int (*start)(void*) = (int(*)(void*)) args->start_func;
 	__pthread_exit((void *)(uintptr_t)start(args->start_arg));
@@ -242,16 +328,19 @@ static void init_file_lock(FILE *f)
 int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict attrp, void *(*entry)(void *), void *restrict arg)
 {
 	int ret, c11 = (attrp == __ATTRP_C11_THREAD);
-	size_t size, guard;
+	size_t size, guard, size_len;
 	struct pthread *self, *new;
-	unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit;
+	unsigned char *map = 0, *stack = 0, *tsd = 0, *stack_limit, *start_addr;
 	unsigned flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND
 		| CLONE_THREAD | CLONE_SYSVSEM | CLONE_SETTLS
 		| CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_DETACHED;
 	pthread_attr_t attr = { 0 };
 	sigset_t set;
 
-	if (!libc.can_do_threads) return ENOSYS;
+	if (!libc.can_do_threads) {
+		MUSL_LOGE("pthread_create: can't do threads, err: %{public}s", strerror(errno));
+		return ENOSYS;
+	}
 	self = __pthread_self();
 	if (!libc.threaded) {
 		for (FILE *f=*__ofl_lock(); f; f=f->next)
@@ -298,15 +387,22 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 	if (!tsd) {
 		if (guard) {
 			map = __mmap(0, size, PROT_NONE, MAP_PRIVATE|MAP_ANON, -1, 0);
-			if (map == MAP_FAILED) goto fail;
+			if (map == MAP_FAILED) {
+				MUSL_LOGE("pthread_create: mmap PROT_NONE failed, err:%{public}s", strerror(errno));
+				goto fail;
+			}
 			if (__mprotect(map+guard, size-guard, PROT_READ|PROT_WRITE)
 			    && errno != ENOSYS) {
+				MUSL_LOGE("pthread_create: mprotect failed, err:%{public}s", strerror(errno));
 				__munmap(map, size);
 				goto fail;
 			}
 		} else {
 			map = __mmap(0, size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);
-			if (map == MAP_FAILED) goto fail;
+			if (map == MAP_FAILED) {
+				MUSL_LOGE("pthread_create: mmap PROT_READ|PROT_WRITE failed, err:%{public}s", strerror(errno));
+				goto fail;
+			}
 		}
 		tsd = map + size - __pthread_tsd_size;
 		if (!stack) {
@@ -322,6 +418,7 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 	new->stack_size = stack - stack_limit;
 	new->guard_size = guard;
 	new->self = new;
+	new->pid = getpid();
 	new->tsd = (void *)tsd;
 	new->locale = &libc.global_locale;
 	if (attr._a_detach) {
@@ -375,6 +472,8 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 	}
 
 	if (ret >= 0) {
+		stack_naming(new);
+
 		new->next = self->next;
 		new->prev = self;
 		new->next->prev = new;
@@ -388,6 +487,7 @@ int __pthread_create(pthread_t *restrict res, const pthread_attr_t *restrict att
 
 	if (ret < 0) {
 		if (map) __munmap(map, size);
+		MUSL_LOGE("pthread_create: ret:%{public}d, err:%{public}s", ret, strerror(errno));
 		return -ret;
 	}
 
@@ -430,4 +530,4 @@ pid_t __pthread_gettid_np(pthread_t t)
     __tl_unlock();
     return thread ? thread->tid : -1;
 }
-weak_alias(__pthread_gettid_np, pthread_gettid_np);
\ No newline at end of file
+weak_alias(__pthread_gettid_np, pthread_gettid_np);
diff --git a/src/thread/pthread_mutex_clocklock.c b/src/thread/pthread_mutex_clocklock.c
new file mode 100644
index 00000000..5028e74d
--- /dev/null
+++ b/src/thread/pthread_mutex_clocklock.c
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "pthread_impl.h"
+
+int pthread_mutex_clocklock(pthread_mutex_t* mutex_interface, clockid_t clock_id,
+                            const struct timespec* abs_timeout)
+{
+    if (mutex_interface == NULL) {
+        return EINVAL;
+    }
+
+    switch (clock_id) {
+        case CLOCK_MONOTONIC:
+            mutex_interface->_m_clock = CLOCK_MONOTONIC;
+            return __pthread_mutex_timedlock(mutex_interface, abs_timeout);
+        case CLOCK_REALTIME:
+            mutex_interface->_m_clock = CLOCK_REALTIME;
+            return __pthread_mutex_timedlock(mutex_interface, abs_timeout);
+        default:
+            return EINVAL;
+    }
+}
\ No newline at end of file
diff --git a/src/thread/pthread_mutex_init.c b/src/thread/pthread_mutex_init.c
index acf45a74..f606428d 100644
--- a/src/thread/pthread_mutex_init.c
+++ b/src/thread/pthread_mutex_init.c
@@ -2,7 +2,7 @@
 
 int pthread_mutex_init(pthread_mutex_t *restrict m, const pthread_mutexattr_t *restrict a)
 {
-	*m = (pthread_mutex_t){0};
+	__builtin_memset(m, 0, sizeof(pthread_mutex_t));
 	if (a) m->_m_type = a->__attr;
 	return 0;
 }
diff --git a/src/thread/pthread_mutex_lock.c b/src/thread/pthread_mutex_lock.c
index 638d4b86..4049a873 100644
--- a/src/thread/pthread_mutex_lock.c
+++ b/src/thread/pthread_mutex_lock.c
@@ -1,12 +1,12 @@
 #include "pthread_impl.h"
-
+extern int __pthread_mutex_timedlock_inner(pthread_mutex_t *restrict m, const struct timespec *restrict at);
 int __pthread_mutex_lock(pthread_mutex_t *m)
 {
 	if ((m->_m_type&15) == PTHREAD_MUTEX_NORMAL
 	    && !a_cas(&m->_m_lock, 0, EBUSY))
 		return 0;
 
-	return __pthread_mutex_timedlock(m, 0);
+	return __pthread_mutex_timedlock_inner(m, 0);
 }
 
 weak_alias(__pthread_mutex_lock, pthread_mutex_lock);
diff --git a/src/thread/pthread_mutex_lock_timeout_np.c b/src/thread/pthread_mutex_lock_timeout_np.c
new file mode 100644
index 00000000..30293931
--- /dev/null
+++ b/src/thread/pthread_mutex_lock_timeout_np.c
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "pthread_impl.h"
+
+#define NS_PER_S 1000000000
+
+int pthread_mutex_lock_timeout_np(pthread_mutex_t* mutex_interface, unsigned int ms)
+{
+    struct timespec ts;
+    __timespec_from_ms(&ts, ms);
+    struct timespec abs_timeout;
+    __absolute_timespec_from_timespec(&abs_timeout, &ts, CLOCK_MONOTONIC);
+    return pthread_mutex_timedlock_monotonic_np(mutex_interface, &abs_timeout);
+}
\ No newline at end of file
diff --git a/src/thread/pthread_mutex_timedlock.c b/src/thread/pthread_mutex_timedlock.c
index 9279fc54..c71f7fc0 100644
--- a/src/thread/pthread_mutex_timedlock.c
+++ b/src/thread/pthread_mutex_timedlock.c
@@ -1,3 +1,18 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include "pthread_impl.h"
 
 #define IS32BIT(x) !((x)+0x80000000ULL>>32)
@@ -20,6 +35,7 @@ static int __futex4(volatile void *addr, int op, int val, const struct timespec
 
 static int pthread_mutex_timedlock_pi(pthread_mutex_t *restrict m, const struct timespec *restrict at)
 {
+	int clock = m->_m_clock;
 	int type = m->_m_type;
 	int priv = (type & 128) ^ 128;
 	pthread_t self = __pthread_self();
@@ -42,31 +58,31 @@ static int pthread_mutex_timedlock_pi(pthread_mutex_t *restrict m, const struct
 		}
 		/* Signal to trylock that we already have the lock. */
 		m->_m_count = -1;
-		return __pthread_mutex_trylock(m);
+		return __pthread_mutex_trylock_owner(m);
 	case ETIMEDOUT:
 		return e;
 	case EDEADLK:
 		if ((type&3) == PTHREAD_MUTEX_ERRORCHECK) return e;
 	}
-	do e = __timedwait(&(int){0}, 0, CLOCK_REALTIME, at, 1);
+	do e = __timedwait(&(int){0}, 0, clock, at, 1);
 	while (e != ETIMEDOUT);
 	return e;
 }
 
-int __pthread_mutex_timedlock(pthread_mutex_t *restrict m, const struct timespec *restrict at)
+int __pthread_mutex_timedlock_inner(pthread_mutex_t *restrict m, const struct timespec *restrict at)
 {
-	if ((m->_m_type&15) == PTHREAD_MUTEX_NORMAL
-	    && !a_cas(&m->_m_lock, 0, EBUSY))
-		return 0;
-
 	int type = m->_m_type;
-	int r, t, priv = (type & 128) ^ 128;
-
+	int r;
+	// PI
+	if (type&8) {
+		r = __pthread_mutex_trylock_owner(m);
+		if (r != EBUSY) return r;
+		return pthread_mutex_timedlock_pi(m, at);
+	}
 	r = __pthread_mutex_trylock(m);
 	if (r != EBUSY) return r;
-
-	if (type&8) return pthread_mutex_timedlock_pi(m, at);
-	
+	int clock = (m->_m_clock == CLOCK_MONOTONIC) ? CLOCK_MONOTONIC : CLOCK_REALTIME;
+	int t, priv = (type & 128) ^ 128;
 	int spins = 100;
 	while (spins-- && m->_m_lock && !m->_m_waiters) a_spin();
 
@@ -82,11 +98,19 @@ int __pthread_mutex_timedlock(pthread_mutex_t *restrict m, const struct timespec
 		a_inc(&m->_m_waiters);
 		t = r | 0x80000000;
 		a_cas(&m->_m_lock, r, t);
-		r = __timedwait(&m->_m_lock, t, CLOCK_REALTIME, at, priv);
+		r = __timedwait(&m->_m_lock, t, clock, at, priv);
 		a_dec(&m->_m_waiters);
 		if (r && r != EINTR) break;
 	}
 	return r;
 }
 
-weak_alias(__pthread_mutex_timedlock, pthread_mutex_timedlock);
+int __pthread_mutex_timedlock(pthread_mutex_t *restrict m, const struct timespec *restrict at)
+{
+	if ((m->_m_type&15) == PTHREAD_MUTEX_NORMAL
+		&& !a_cas(&m->_m_lock, 0, EBUSY))
+		return 0;
+	return __pthread_mutex_timedlock_inner(m, at);
+}
+
+weak_alias(__pthread_mutex_timedlock, pthread_mutex_timedlock);
\ No newline at end of file
diff --git a/src/thread/pthread_mutex_timedlock_monotonic_np.c b/src/thread/pthread_mutex_timedlock_monotonic_np.c
new file mode 100644
index 00000000..6094621b
--- /dev/null
+++ b/src/thread/pthread_mutex_timedlock_monotonic_np.c
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "pthread_impl.h"
+
+int pthread_mutex_timedlock_monotonic_np(pthread_mutex_t* mutex_interface, const struct timespec* abs_timeout)
+{
+    if (mutex_interface == NULL) {
+        return EINVAL;
+    }
+    mutex_interface->_m_clock = CLOCK_MONOTONIC;
+    return __pthread_mutex_timedlock(mutex_interface, abs_timeout);
+}
diff --git a/src/thread/pthread_once.c b/src/thread/pthread_once.c
index 8e8d40ae..6b4d6809 100644
--- a/src/thread/pthread_once.c
+++ b/src/thread/pthread_once.c
@@ -36,6 +36,17 @@ hidden int __pthread_once_full(pthread_once_t *control, void (*init)(void))
 	}
 }
 
+#if defined(MUSL_AARCH64_ARCH) || defined(MUSL_ARM_ARCH)
+int __pthread_once(pthread_once_t *control, void (*init)(void))
+{
+	/* Return immediately if init finished before, use load aquire to ensure that
+	 * effects of the init routine are visible to the caller. */
+	if (a_ll((volatile int *)control) == 2) {
+		return 0;
+	}
+	return __pthread_once_full(control, init);
+}
+#else
 int __pthread_once(pthread_once_t *control, void (*init)(void))
 {
 	/* Return immediately if init finished before, but ensure that
@@ -46,5 +57,6 @@ int __pthread_once(pthread_once_t *control, void (*init)(void))
 	}
 	return __pthread_once_full(control, init);
 }
+#endif
 
 weak_alias(__pthread_once, pthread_once);
diff --git a/src/thread/pthread_rwlock_clockrdlock.c b/src/thread/pthread_rwlock_clockrdlock.c
new file mode 100644
index 00000000..a3108640
--- /dev/null
+++ b/src/thread/pthread_rwlock_clockrdlock.c
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "pthread_impl.h"
+
+int pthread_rwlock_clockrdlock(pthread_rwlock_t *rw, clockid_t clock_id, const struct timespec *at)
+{
+    if (rw == NULL) {
+        return EINVAL;
+    }
+
+    switch (clock_id) {
+        case CLOCK_MONOTONIC:
+            rw->_rw_clock = CLOCK_MONOTONIC;
+            return __pthread_rwlock_timedrdlock(rw, at);
+        case CLOCK_REALTIME:
+            rw->_rw_clock = CLOCK_REALTIME;
+            return __pthread_rwlock_timedrdlock(rw, at);
+        default:
+            return EINVAL;
+    }
+}
\ No newline at end of file
diff --git a/src/thread/pthread_rwlock_clockwrlock.c b/src/thread/pthread_rwlock_clockwrlock.c
new file mode 100644
index 00000000..84e95cd9
--- /dev/null
+++ b/src/thread/pthread_rwlock_clockwrlock.c
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "pthread_impl.h"
+
+int pthread_rwlock_clockwrlock(pthread_rwlock_t *rw, clockid_t clock_id, const struct timespec *at)
+{
+    if (rw == NULL) {
+        return EINVAL;
+    }
+
+    switch (clock_id) {
+        case CLOCK_MONOTONIC:
+            rw->_rw_clock = CLOCK_MONOTONIC;
+            return __pthread_rwlock_timedwrlock(rw, at);
+        case CLOCK_REALTIME:
+            rw->_rw_clock = CLOCK_REALTIME;
+            return __pthread_rwlock_timedwrlock(rw, at);
+        default:
+            return EINVAL;
+    }
+}
\ No newline at end of file
diff --git a/src/thread/pthread_rwlock_init.c b/src/thread/pthread_rwlock_init.c
index a2c0b478..27cf8723 100644
--- a/src/thread/pthread_rwlock_init.c
+++ b/src/thread/pthread_rwlock_init.c
@@ -2,7 +2,7 @@
 
 int pthread_rwlock_init(pthread_rwlock_t *restrict rw, const pthread_rwlockattr_t *restrict a)
 {
-	*rw = (pthread_rwlock_t){0};
+	__builtin_memset(rw, 0, sizeof(pthread_rwlock_t));
 	if (a) rw->_rw_shared = a->__attr[0]*128;
 	return 0;
 }
diff --git a/src/thread/pthread_rwlock_timedrdlock.c b/src/thread/pthread_rwlock_timedrdlock.c
index 8cdd8ecf..f4adab2f 100644
--- a/src/thread/pthread_rwlock_timedrdlock.c
+++ b/src/thread/pthread_rwlock_timedrdlock.c
@@ -1,25 +1,41 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include "pthread_impl.h"
 
 int __pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rw, const struct timespec *restrict at)
 {
-	int r, t;
+    int r, t;
+    int clock = (rw->_rw_clock == CLOCK_MONOTONIC) ? CLOCK_MONOTONIC : CLOCK_REALTIME;
+
+    r = pthread_rwlock_tryrdlock(rw);
+    if (r != EBUSY) return r;
 
-	r = pthread_rwlock_tryrdlock(rw);
-	if (r != EBUSY) return r;
-	
-	int spins = 100;
-	while (spins-- && rw->_rw_lock && !rw->_rw_waiters) a_spin();
+    int spins = 100;
+    while (spins-- && rw->_rw_lock && !rw->_rw_waiters) a_spin();
 
-	while ((r=__pthread_rwlock_tryrdlock(rw))==EBUSY) {
-		if (!(r=rw->_rw_lock) || (r&0x7fffffff)!=0x7fffffff) continue;
-		t = r | 0x80000000;
-		a_inc(&rw->_rw_waiters);
-		a_cas(&rw->_rw_lock, r, t);
-		r = __timedwait(&rw->_rw_lock, t, CLOCK_REALTIME, at, rw->_rw_shared^128);
-		a_dec(&rw->_rw_waiters);
-		if (r && r != EINTR) return r;
-	}
-	return r;
+    while ((r=__pthread_rwlock_tryrdlock(rw))==EBUSY) {
+        if (!(r=rw->_rw_lock) || (r&0x7fffffff)!=0x7fffffff) continue;
+        t = r | 0x80000000;
+        a_inc(&rw->_rw_waiters);
+        a_cas(&rw->_rw_lock, r, t);
+        r = __timedwait(&rw->_rw_lock, t, clock, at, rw->_rw_shared^128);
+        a_dec(&rw->_rw_waiters);
+        if (r && r != EINTR) return r;
+    }
+    return r;
 }
 
-weak_alias(__pthread_rwlock_timedrdlock, pthread_rwlock_timedrdlock);
+weak_alias(__pthread_rwlock_timedrdlock, pthread_rwlock_timedrdlock);
\ No newline at end of file
diff --git a/src/thread/pthread_rwlock_timedrdlock_monotonic_np.c b/src/thread/pthread_rwlock_timedrdlock_monotonic_np.c
new file mode 100644
index 00000000..e8e01266
--- /dev/null
+++ b/src/thread/pthread_rwlock_timedrdlock_monotonic_np.c
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "pthread_impl.h"
+
+int pthread_rwlock_timedrdlock_monotonic_np(pthread_rwlock_t *rw, const struct timespec *at)
+{
+    if (rw == NULL) {
+        return EINVAL;
+    }
+    rw->_rw_clock = CLOCK_MONOTONIC;
+    return __pthread_rwlock_timedrdlock(rw, at);
+}
\ No newline at end of file
diff --git a/src/thread/pthread_rwlock_timedwrlock.c b/src/thread/pthread_rwlock_timedwrlock.c
index d77706e6..fead6491 100644
--- a/src/thread/pthread_rwlock_timedwrlock.c
+++ b/src/thread/pthread_rwlock_timedwrlock.c
@@ -1,25 +1,44 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include "pthread_impl.h"
 
 int __pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rw, const struct timespec *restrict at)
 {
-	int r, t;
-	
-	r = pthread_rwlock_trywrlock(rw);
-	if (r != EBUSY) return r;
-	
-	int spins = 100;
-	while (spins-- && rw->_rw_lock && !rw->_rw_waiters) a_spin();
+    if (rw == NULL) {
+        return EINVAL;
+    }
+    int r, t;
+    int clock = (rw->_rw_clock == CLOCK_MONOTONIC) ? CLOCK_MONOTONIC : CLOCK_REALTIME;
+
+    r = pthread_rwlock_trywrlock(rw);
+    if (r != EBUSY) return r;
+
+    int spins = 100;
+    while (spins-- && rw->_rw_lock && !rw->_rw_waiters) a_spin();
 
-	while ((r=__pthread_rwlock_trywrlock(rw))==EBUSY) {
-		if (!(r=rw->_rw_lock)) continue;
-		t = r | 0x80000000;
-		a_inc(&rw->_rw_waiters);
-		a_cas(&rw->_rw_lock, r, t);
-		r = __timedwait(&rw->_rw_lock, t, CLOCK_REALTIME, at, rw->_rw_shared^128);
-		a_dec(&rw->_rw_waiters);
-		if (r && r != EINTR) return r;
-	}
-	return r;
+    while ((r=__pthread_rwlock_trywrlock(rw))==EBUSY) {
+        if (!(r=rw->_rw_lock)) continue;
+        t = r | 0x80000000;
+        a_inc(&rw->_rw_waiters);
+        a_cas(&rw->_rw_lock, r, t);
+        r = __timedwait(&rw->_rw_lock, t, clock, at, rw->_rw_shared^128);
+        a_dec(&rw->_rw_waiters);
+        if (r && r != EINTR) return r;
+    }
+    return r;
 }
 
 weak_alias(__pthread_rwlock_timedwrlock, pthread_rwlock_timedwrlock);
diff --git a/src/thread/pthread_rwlock_timedwrlock_monotonic_np.c b/src/thread/pthread_rwlock_timedwrlock_monotonic_np.c
new file mode 100644
index 00000000..06551e4c
--- /dev/null
+++ b/src/thread/pthread_rwlock_timedwrlock_monotonic_np.c
@@ -0,0 +1,25 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "pthread_impl.h"
+
+int pthread_rwlock_timedwrlock_monotonic_np(pthread_rwlock_t *rw, const struct timespec *at)
+{
+    if (rw == NULL) {
+        return EINVAL;
+    }
+    rw->_rw_clock = CLOCK_MONOTONIC;
+    return __pthread_rwlock_timedwrlock(rw, at);
+}
\ No newline at end of file
diff --git a/src/thread/pthread_setcancelstate.c b/src/thread/pthread_setcancelstate.c
index 5ab8c338..bbb22abd 100644
--- a/src/thread/pthread_setcancelstate.c
+++ b/src/thread/pthread_setcancelstate.c
@@ -2,11 +2,13 @@
 
 int __pthread_setcancelstate(int new, int *old)
 {
+#ifdef FEATURE_PTHREAD_CANCEL
 	if (new > 2U) return EINVAL;
 	struct pthread *self = __pthread_self();
 	if (old) *old = self->canceldisable;
 	self->canceldisable = new;
 	return 0;
+#endif
 }
 
 weak_alias(__pthread_setcancelstate, pthread_setcancelstate);
diff --git a/src/thread/pthread_setcanceltype.c b/src/thread/pthread_setcanceltype.c
index bf0a3f38..85148586 100644
--- a/src/thread/pthread_setcanceltype.c
+++ b/src/thread/pthread_setcanceltype.c
@@ -2,10 +2,12 @@
 
 int pthread_setcanceltype(int new, int *old)
 {
+#ifdef FEATURE_PTHREAD_CANCEL
 	struct pthread *self = __pthread_self();
 	if (new > 1U) return EINVAL;
 	if (old) *old = self->cancelasync;
 	self->cancelasync = new;
 	if (new) pthread_testcancel();
 	return 0;
+#endif
 }
diff --git a/src/thread/pthread_sigmask.c b/src/thread/pthread_sigmask.c
index f188782a..dc3be454 100644
--- a/src/thread/pthread_sigmask.c
+++ b/src/thread/pthread_sigmask.c
@@ -1,12 +1,67 @@
+/*
+ * Copyright (c) 2023 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <signal.h>
 #include <errno.h>
+#include <sigchain.h>
+#include <stddef.h>
+#include <hilog_adapter.h>
+#include <string.h>
 #include "syscall.h"
+#ifdef OHOS_ENABLE_PARAMETER
+#include "sys_param.h"
+#endif
+
+extern void intercept_pthread_sigmask(int how, sigset_t *restrict set);
+static const char *param_name = "musl.sigchain.procmask";
+
+/**
+  * @brief Get whether sigchain mask is enabled
+  * @retval True if the sigchain mask is enable, or false.
+  */
+bool get_sigchain_mask_enable()
+{
+#ifdef OHOS_ENABLE_PARAMETER
+	static CachedHandle sigchain_procmask_handle = NULL;
+	if (sigchain_procmask_handle == NULL) {
+		sigchain_procmask_handle = CachedParameterCreate(param_name, "false");
+	}
+	char *param_value = CachedParameterGet(sigchain_procmask_handle);
+	if (param_value != NULL) {
+		if (strcmp(param_value, "true") == 0) {
+			return true;
+		}
+	}
+#endif
+	return false;
+}
 
 int pthread_sigmask(int how, const sigset_t *restrict set, sigset_t *restrict old)
 {
 	int ret;
 	if (set && (unsigned)how - SIG_BLOCK > 2U) return EINVAL;
-	ret = -__syscall(SYS_rt_sigprocmask, how, set, old, _NSIG/8);
+	/* sigchain intercepts pthread_sigmask */
+	if (set && get_sigchain_mask_enable()) {
+		sigset_t tmpset = *set;
+		intercept_pthread_sigmask(how, &tmpset);
+		const sigset_t *new_set_ptr = &tmpset;
+		ret = -__syscall(SYS_rt_sigprocmask, how, new_set_ptr, old, _NSIG/8);
+	} else {
+		ret = -__syscall(SYS_rt_sigprocmask, how, set, old, _NSIG/8);
+	}
+
 	if (!ret && old) {
 		if (sizeof old->__bits[0] == 8) {
 			old->__bits[0] &= ~0x380000000ULL;
diff --git a/src/thread/sem_timedwait.c b/src/thread/sem_timedwait.c
index 58d3ebfe..a17dd96b 100644
--- a/src/thread/sem_timedwait.c
+++ b/src/thread/sem_timedwait.c
@@ -5,13 +5,8 @@ static void cleanup(void *p)
 {
 	a_dec(p);
 }
-
-int sem_timedwait(sem_t *restrict sem, const struct timespec *restrict at)
+int __sem_timedwait(sem_t *restrict sem, const struct timespec *restrict at)
 {
-	pthread_testcancel();
-
-	if (!sem_trywait(sem)) return 0;
-
 	int spins = 100;
 	while (spins-- && sem->__val[0] <= 0 && !sem->__val[1]) a_spin();
 
@@ -29,3 +24,11 @@ int sem_timedwait(sem_t *restrict sem, const struct timespec *restrict at)
 	}
 	return 0;
 }
+int sem_timedwait(sem_t *restrict sem, const struct timespec *restrict at)
+{
+	pthread_testcancel();
+
+	if (!sem_trywait(sem)) return 0;
+
+	return __sem_timedwait(sem, at);
+}
diff --git a/src/time/__tz.c b/src/time/__tz.c
index c34b3eb7..a20e1b67 100644
--- a/src/time/__tz.c
+++ b/src/time/__tz.c
@@ -1,4 +1,18 @@
-#include "time_impl.h"
+/**
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <stdint.h>
 #include <limits.h>
 #include <stdlib.h>
@@ -8,11 +22,17 @@
 #include "libc.h"
 #include "lock.h"
 #include "fork_impl.h"
+#include "time_impl.h"
+#ifdef OHOS_ENABLE_PARAMETER
+#include "sys_param.h"
+#define SYSPARAM_LENGTH 40
+#endif
 
 #define malloc __libc_malloc
 #define calloc undef
 #define realloc undef
 #define free undef
+#define __TZ_VERSION__ '2'
 
 long  __timezone = 0;
 int   __daylight = 0;
@@ -25,6 +45,7 @@ weak_alias(__tzname, tzname);
 static char std_name[TZNAME_MAX+1];
 static char dst_name[TZNAME_MAX+1];
 const char __utc[] = "UTC";
+const char __gmt[] = "GMT";
 
 static int dst_off;
 static int r0[5], r1[5];
@@ -41,52 +62,60 @@ volatile int *const __timezone_lockptr = lock;
 
 static int getint(const char **p)
 {
-	unsigned x;
-	for (x=0; **p-'0'<10U; (*p)++) x = **p-'0' + 10*x;
-	return x;
+    unsigned x;
+    for (x=0; **p-'0'<10U; (*p)++) {
+        x = **p-'0' + 10*x;
+    }
+    return x;
 }
 
 static int getoff(const char **p)
 {
-	int neg = 0;
-	if (**p == '-') {
-		++*p;
-		neg = 1;
-	} else if (**p == '+') {
-		++*p;
-	}
-	int off = 3600*getint(p);
-	if (**p == ':') {
-		++*p;
-		off += 60*getint(p);
-		if (**p == ':') {
-			++*p;
-			off += getint(p);
-		}
-	}
-	return neg ? -off : off;
+    int neg = 0;
+    if (**p == '-') {
+        ++*p;
+        neg = 1;
+    } else if (**p == '+') {
+        ++*p;
+    }
+    int off = 3600*getint(p);
+    if (**p == ':') {
+        ++*p;
+        off += 60*getint(p);
+        if (**p == ':') {
+            ++*p;
+            off += getint(p);
+        }
+    }
+    return neg ? -off : off;
 }
 
 static void getrule(const char **p, int rule[5])
 {
-	int r = rule[0] = **p;
-
-	if (r!='M') {
-		if (r=='J') ++*p;
-		else rule[0] = 0;
-		rule[1] = getint(p);
-	} else {
-		++*p; rule[1] = getint(p);
-		++*p; rule[2] = getint(p);
-		++*p; rule[3] = getint(p);
-	}
-
-	if (**p=='/') {
-		++*p;
-		rule[4] = getoff(p);
-	} else {
-		rule[4] = 7200;
-	}
+    int r = rule[0] = **p;
+
+    if (r!='M') {
+        if (r=='J') {
+            ++*p;
+        } else {
+            rule[0] = 0;
+        }
+        rule[1] = getint(p);
+    } else {
+        ++*p;
+        rule[1] = getint(p);
+        ++*p;
+        rule[2] = getint(p);
+        ++*p;
+        rule[3] = getint(p);
+    }
+
+    if (**p=='/') {
+        ++*p;
+        rule[4] = getoff(p);
+    } else {
+        rule[4] = 7200;
+    }
 }
 
 static void getname(char *d, const char **p)
@@ -105,55 +134,78 @@ static void getname(char *d, const char **p)
 	d[i<TZNAME_MAX?i:TZNAME_MAX] = 0;
 }
 
-#define VEC(...) ((const unsigned char[]){__VA_ARGS__})
+#define VEC(...) ((const unsigned char[]) {__VA_ARGS__})
 
 static uint32_t zi_read32(const unsigned char *z)
 {
-	return (unsigned)z[0]<<24 | z[1]<<16 | z[2]<<8 | z[3];
+    return (unsigned)(z[0]<<24) | (z[1]<<16) | (z[2]<<8) | z[3];
 }
 
 static size_t zi_dotprod(const unsigned char *z, const unsigned char *v, size_t n)
 {
-	size_t y;
-	uint32_t x;
-	for (y=0; n; n--, z+=4, v++) {
-		x = zi_read32(z);
-		y += x * *v;
-	}
-	return y;
+    size_t y;
+    uint32_t x;
+    for (y=0; n; n--, z+=4, v++) {
+        x = zi_read32(z);
+        y += x * *v;
+    }
+    return y;
 }
 
 static void do_tzset()
 {
-	char buf[NAME_MAX+25], *pathname=buf+24;
-	const char *try, *s, *p;
-	const unsigned char *map = 0;
-	size_t i;
-	static const char search[] =
-		"/usr/share/zoneinfo/\0/share/zoneinfo/\0/etc/zoneinfo/\0";
-
-	s = getenv("TZ");
-	if (!s) s = "/etc/localtime";
-	if (!*s) s = __utc;
-
-	if (old_tz && !strcmp(s, old_tz)) return;
-
-	for (i=0; i<5; i++) r0[i] = r1[i] = 0;
-
-	if (zi) __munmap((void *)zi, map_size);
-
-	/* Cache the old value of TZ to check if it has changed. Avoid
-	 * free so as not to pull it into static programs. Growth
-	 * strategy makes it so free would have minimal benefit anyway. */
-	i = strlen(s);
-	if (i > PATH_MAX+1) s = __utc, i = 3;
-	if (i >= old_tz_size) {
-		old_tz_size *= 2;
-		if (i >= old_tz_size) old_tz_size = i+1;
-		if (old_tz_size > PATH_MAX+2) old_tz_size = PATH_MAX+2;
-		old_tz = malloc(old_tz_size);
-	}
-	if (old_tz) memcpy(old_tz, s, i+1);
+    char buf[NAME_MAX+25], *pathname = buf+24;
+    const char *try, *s, *p;
+    const unsigned char *map = 0;
+    size_t i;
+    static const char search[] =
+        "/etc/zoneinfo/\0/usr/share/zoneinfo/\0/share/zoneinfo/\0";
+
+    s = getenv("TZ");
+    if (!s) {
+#ifdef OHOS_ENABLE_PARAMETER
+        static CachedHandle tz_param_handle = NULL;
+        if (tz_param_handle == NULL) {
+            tz_param_handle = CachedParameterCreate("persist.time.timezone", "/etc/localtime");
+        }
+        const char *tz_param_value = CachedParameterGet(tz_param_handle);
+        if (tz_param_value != NULL){
+            s = tz_param_value;
+        } else {
+            s = "/etc/localtime";
+        }
+#else
+        s = "/etc/localtime";
+#endif
+    }
+    if (!*s) {
+        s = __utc;
+    }
+
+    if (old_tz && !strcmp(s, old_tz)) {
+        return;
+    }
+
+    for (i=0; i<5; i++) {
+        r0[i] = r1[i] = 0;
+    }
+
+    if (zi) {
+        __munmap((void *)zi, map_size);
+    }
+
+    /* Cache the old value of TZ to check if it has changed. Avoid
+     * free so as not to pull it into static programs. Growth
+     * strategy makes it so free would have minimal benefit anyway. */
+    i = strlen(s);
+    if (i > PATH_MAX+1) s = __utc, i = 3;
+    if (i >= old_tz_size) {
+        old_tz_size *= 2;
+        if (i >= old_tz_size) old_tz_size = i+1;
+        if (old_tz_size > PATH_MAX+2) old_tz_size = PATH_MAX+2;
+        old_tz = malloc(old_tz_size);
+    }
+    if (old_tz) memcpy(old_tz, s, i+1);
 
 	int posix_form = 0;
 	if (*s != ':') {
@@ -164,97 +216,130 @@ static void do_tzset()
 		             || !strcmp(dummy_name, "UTC")
 		             || !strcmp(dummy_name, "GMT")))
 			posix_form = 1;
-	}	
-
-	/* Non-suid can use an absolute tzfile pathname or a relative
-	 * pathame beginning with "."; in secure mode, only the
-	 * standard path will be searched. */
-	if (!posix_form) {
-		if (*s == ':') s++;
-		if (*s == '/' || *s == '.') {
-			if (!libc.secure || !strcmp(s, "/etc/localtime"))
-				map = __map_file(s, &map_size);
-		} else {
-			size_t l = strlen(s);
-			if (l <= NAME_MAX && !strchr(s, '.')) {
-				memcpy(pathname, s, l+1);
-				pathname[l] = 0;
-				for (try=search; !map && *try; try+=l+1) {
-					l = strlen(try);
-					memcpy(pathname-l, try, l);
-					map = __map_file(pathname-l, &map_size);
-				}
-			}
-		}
-		if (!map) s = __utc;
 	}
-	if (map && (map_size < 44 || memcmp(map, "TZif", 4))) {
-		__munmap((void *)map, map_size);
-		map = 0;
-		s = __utc;
-	}
-
-	zi = map;
-	if (map) {
-		int scale = 2;
-		if (map[4]!='1') {
-			size_t skip = zi_dotprod(zi+20, VEC(1,1,8,5,6,1), 6);
-			trans = zi+skip+44+44;
-			scale++;
-		} else {
-			trans = zi+44;
-		}
-		index = trans + (zi_read32(trans-12) << scale);
-		types = index + zi_read32(trans-12);
-		abbrevs = types + 6*zi_read32(trans-8);
-		abbrevs_end = abbrevs + zi_read32(trans-4);
-		if (zi[map_size-1] == '\n') {
-			for (s = (const char *)zi+map_size-2; *s!='\n'; s--);
-			s++;
-		} else {
-			const unsigned char *p;
-			__tzname[0] = __tzname[1] = 0;
-			__daylight = __timezone = dst_off = 0;
-			for (p=types; p<abbrevs; p+=6) {
-				if (!p[4] && !__tzname[0]) {
-					__tzname[0] = (char *)abbrevs + p[5];
-					__timezone = -zi_read32(p);
-				}
-				if (p[4] && !__tzname[1]) {
-					__tzname[1] = (char *)abbrevs + p[5];
-					dst_off = -zi_read32(p);
-					__daylight = 1;
-				}
-			}
-			if (!__tzname[0]) __tzname[0] = __tzname[1];
-			if (!__tzname[0]) __tzname[0] = (char *)__utc;
-			if (!__daylight) {
-				__tzname[1] = __tzname[0];
-				dst_off = __timezone;
-			}
-			return;
-		}
-	}
-
-	if (!s) s = __utc;
-	getname(std_name, &s);
-	__tzname[0] = std_name;
-	__timezone = getoff(&s);
-	getname(dst_name, &s);
-	__tzname[1] = dst_name;
-	if (dst_name[0]) {
-		__daylight = 1;
-		if (*s == '+' || *s=='-' || *s-'0'<10U)
-			dst_off = getoff(&s);
-		else
-			dst_off = __timezone - 3600;
-	} else {
-		__daylight = 0;
-		dst_off = __timezone;
-	}
-
-	if (*s == ',') s++, getrule(&s, r0);
-	if (*s == ',') s++, getrule(&s, r1);
+    /* Non-suid can use an absolute tzfile pathname or a relative
+     * pathame beginning with "."; in secure mode, only the
+     * standard path will be searched. */
+    int flag = 1;
+    if (!posix_form) {
+        if (*s == ':') s++;
+        if (*s == '/' || *s == '.') {
+            /* The path is invalid, use the default value. */
+            flag = 0;
+            if (!libc.secure || !strcmp(s, "/etc/localtime")) {
+                map = __map_file(s, &map_size);
+            }
+        }
+    }
+
+    if (flag) {
+        /* Adapt to time zone names, such as Asia/Shanghai or Shanghai*/
+        size_t l = strlen(s);
+        if (l <= NAME_MAX && !strchr(s, '.')) {
+            memcpy(pathname, s, l+1);
+            pathname[l] = 0;
+            for (try=search; !map && *try; try+=l+1) {
+                l = strlen(try);
+                memcpy(pathname-l, try, l);
+                map = __map_file(pathname-l, &map_size);
+            }
+        }
+    }
+
+    if (map && (map_size < 44 || memcmp(map, "TZif", 4))) {
+        __munmap((void *)map, map_size);
+        map = 0;
+        s = __utc;
+    }
+
+    zi = map;
+    if (map) {
+        int scale = 2;
+
+        /*
+         * map[0]-map[3]: magic, it is TZif
+         * map[4]:        version, '\0' or '2' or '3' as of 2013
+         * map[5]-map[19]: reserved; must be zero
+         * map[20]-map[23]: The number of UT/local indicators stored in the file.
+         * map[24]-map[27]: The number of standard/wall indicators stored in the file.
+         * map[24]-map[31]: The number of leap seconds for which data entries are stored in the file.
+         * map[32]-map[35]: The number of transition times for which data entries are stored in the file.
+         * map[36]-map[39]: The number of local time types for which data entries are
+         *                  stored in the file (must not be zero).
+         * map[40]-map[43]: The number of bytes of time zone abbreviation strings stored in the file.
+
+         * If map[4] is '2' or greater, the above is followed by a second instance
+         * of tzhead and a second instance of the data in which each coded transition
+         * time uses 8 rather than 4 chars,
+         * then a POSIX-TZ-environment-variable-style string for use in handling
+         * instants after the last transition time stored in the file
+         * (with nothing between the newlines if there is no POSIX representation for
+         * such instants).
+
+         * If map[4] is '3' or greater, the above is extended as follows.
+         * First, the POSIX TZ string's hour offset may range from -167
+         * through 167 as compared to the POSIX-required 0 through 24.
+         * Second, its DST start time may be January 1 at 00:00 and its stop
+         * time December 31 at 24:00 plus the difference between DST and
+         * standard time, indicating DST all year. */
+        if (map[4]!='1') {
+            size_t skip = zi_dotprod(zi+20, VEC(1, 1, 8, 5, 6, 1), 6);
+            trans = zi+skip+44+44;
+            scale++;
+        } else {
+            trans = zi+44;
+        }
+        index = trans + (zi_read32(trans-12) << scale);
+        types = index + zi_read32(trans-12);
+        abbrevs = types + 6*zi_read32(trans-8);
+        abbrevs_end = abbrevs + zi_read32(trans-4);
+        if (zi[map_size-1] == '\n') {
+            for (s = (const char *)zi+map_size-2; *s!='\n'; s--);
+            s++;
+        } else {
+            const unsigned char *p;
+            __tzname[0] = __tzname[1] = 0;
+            __daylight = __timezone = dst_off = 0;
+            for (p=types; p<abbrevs; p+=6) {
+                if (!p[4] && !__tzname[0]) {
+                    __tzname[0] = (char *)abbrevs + p[5];
+                    __timezone = -zi_read32(p);
+                }
+                if (p[4] && !__tzname[1]) {
+                    __tzname[1] = (char *)abbrevs + p[5];
+                    dst_off = -zi_read32(p);
+                    __daylight = 1;
+                }
+            }
+            if (!__tzname[0]) __tzname[0] = __tzname[1];
+            if (!__tzname[0]) __tzname[0] = (char *)__utc;
+            if (!__daylight) {
+                __tzname[1] = __tzname[0];
+                dst_off = __timezone;
+            }
+            return;
+        }
+    }
+
+    if (!s) s = __utc;
+    getname(std_name, &s);
+    __tzname[0] = std_name;
+    __timezone = getoff(&s);
+    getname(dst_name, &s);
+    __tzname[1] = dst_name;
+    if (dst_name[0]) {
+        __daylight = 1;
+        if (*s == '+' || *s=='-' || *s-'0'<10U)
+            dst_off = getoff(&s);
+        else
+            dst_off = __timezone - 3600;
+    } else {
+        __daylight = 0;
+        dst_off = __timezone;
+    }
+
+    if (*s == ',') s++, getrule(&s, r0);
+    if (*s == ',') s++, getrule(&s, r1);
 }
 
 /* Search zoneinfo rules to find the one that applies to the given time,
@@ -262,31 +347,31 @@ static void do_tzset()
 
 static size_t scan_trans(long long t, int local, size_t *alt)
 {
-	int scale = 3 - (trans == zi+44);
-	uint64_t x;
-	int off = 0;
-
-	size_t a = 0, n = (index-trans)>>scale, m;
-
-	if (!n) {
-		if (alt) *alt = 0;
-		return 0;
-	}
-
-	/* Binary search for 'most-recent rule before t'. */
-	while (n > 1) {
-		m = a + n/2;
-		x = zi_read32(trans + (m<<scale));
-		if (scale == 3) x = x<<32 | zi_read32(trans + (m<<scale) + 4);
-		else x = (int32_t)x;
-		if (local) off = (int32_t)zi_read32(types + 6 * index[m-1]);
-		if (t - off < (int64_t)x) {
-			n /= 2;
-		} else {
-			a = m;
-			n -= n/2;
-		}
-	}
+    int scale = 3 - (trans == zi+44);
+    uint64_t x;
+    int off = 0;
+
+    size_t a = 0, n = (index-trans)>>scale, m;
+
+    if (!n) {
+        if (alt) *alt = 0;
+        return 0;
+    }
+
+    /* Binary search for 'most-recent rule before t'. */
+    while (n > 1) {
+        m = a + n/2;
+        x = zi_read32(trans + (m<<scale));
+        if (scale == 3) x = (x<<32) | zi_read32(trans + (m<<scale) + 4);
+        else x = (int32_t)x;
+        if (local) off = (int32_t)zi_read32(types + 6 * index[m-1]);
+        if (t - off < (int64_t)x) {
+            n /= 2;
+        } else {
+            a = m;
+            n -= n/2;
+        }
+    }
 
 	/* First and last entry are special. First means to use lowest-index
 	 * non-DST type. Last means to apply POSIX-style rule if available. */
@@ -294,7 +379,7 @@ static size_t scan_trans(long long t, int local, size_t *alt)
 	if (a == n-1) return -1;
 	if (a == 0) {
 		x = zi_read32(trans);
-		if (scale == 3) x = x<<32 | zi_read32(trans + 4);
+		if (scale == 3) x = (x<<32) | zi_read32(trans + 4);
 		else x = (int32_t)x;
 		/* Find the lowest non-DST type, or 0 if none. */
 		size_t j = 0;
@@ -310,49 +395,49 @@ static size_t scan_trans(long long t, int local, size_t *alt)
 		}
 	}
 
-	/* Try to find a neighboring opposite-DST-status rule. */
-	if (alt) {
-		if (a && types[6*index[a-1]+4] != types[6*index[a]+4])
-			*alt = index[a-1];
-		else if (a+1<n && types[6*index[a+1]+4] != types[6*index[a]+4])
-			*alt = index[a+1];
-		else
-			*alt = index[a];
-	}
-
-	return index[a];
+    /* Try to find a neighboring opposite-DST-status rule. */
+    if (alt) {
+        if (a && types[6*index[a-1]+4] != types[6*index[a]+4])
+            *alt = index[a-1];
+        else if (a+1<n && types[6*index[a+1]+4] != types[6*index[a]+4])
+            *alt = index[a+1];
+        else
+            *alt = index[a];
+    }
+
+    return index[a];
 }
 
 static int days_in_month(int m, int is_leap)
 {
-	if (m==2) return 28+is_leap;
-	else return 30+((0xad5>>(m-1))&1);
+    if (m==2) return 28+is_leap;
+    else return 30+((0xad5>>(m-1))&1);
 }
 
 /* Convert a POSIX DST rule plus year to seconds since epoch. */
 
 static long long rule_to_secs(const int *rule, int year)
 {
-	int is_leap;
-	long long t = __year_to_secs(year, &is_leap);
-	int x, m, n, d;
-	if (rule[0]!='M') {
-		x = rule[1];
-		if (rule[0]=='J' && (x < 60 || !is_leap)) x--;
-		t += 86400 * x;
-	} else {
-		m = rule[1];
-		n = rule[2];
-		d = rule[3];
-		t += __month_to_secs(m-1, is_leap);
-		int wday = (int)((t + 4*86400) % (7*86400)) / 86400;
-		int days = d - wday;
-		if (days < 0) days += 7;
-		if (n == 5 && days+28 >= days_in_month(m, is_leap)) n = 4;
-		t += 86400 * (days + 7*(n-1));
-	}
-	t += rule[4];
-	return t;
+    int is_leap;
+    long long t = __year_to_secs(year, &is_leap);
+    int x, m, n, d;
+    if (rule[0]!='M') {
+        x = rule[1];
+        if (rule[0]=='J' && (x < 60 || !is_leap)) x--;
+        t += 86400 * x;
+    } else {
+        m = rule[1];
+        n = rule[2];
+        d = rule[3];
+        t += __month_to_secs(m-1, is_leap);
+        int wday = (int)((t + 4*86400) % (7*86400)) / 86400;
+        int days = d - wday;
+        if (days < 0) days += 7;
+        if (n == 5 && days+28 >= days_in_month(m, is_leap)) n = 4;
+        t += 86400 * (days + 7*(n-1));
+    }
+    t += rule[4];
+    return t;
 }
 
 /* Determine the time zone in effect for a given time in seconds since the
@@ -364,76 +449,79 @@ static long long rule_to_secs(const int *rule, int year)
 
 void __secs_to_zone(long long t, int local, int *isdst, long *offset, long *oppoff, const char **zonename)
 {
-	LOCK(lock);
-
-	do_tzset();
-
-	if (zi) {
-		size_t alt, i = scan_trans(t, local, &alt);
-		if (i != -1) {
-			*isdst = types[6*i+4];
-			*offset = (int32_t)zi_read32(types+6*i);
-			*zonename = (const char *)abbrevs + types[6*i+5];
-			if (oppoff) *oppoff = (int32_t)zi_read32(types+6*alt);
-			UNLOCK(lock);
-			return;
-		}
-	}
-
-	if (!__daylight) goto std;
-
-	/* FIXME: may be broken if DST changes right at year boundary?
-	 * Also, this could be more efficient.*/
-	long long y = t / 31556952 + 70;
-	while (__year_to_secs(y, 0) > t) y--;
-	while (__year_to_secs(y+1, 0) < t) y++;
-
-	long long t0 = rule_to_secs(r0, y);
-	long long t1 = rule_to_secs(r1, y);
-
-	if (!local) {
-		t0 += __timezone;
-		t1 += dst_off;
-	}
-	if (t0 < t1) {
-		if (t >= t0 && t < t1) goto dst;
-		goto std;
-	} else {
-		if (t >= t1 && t < t0) goto std;
-		goto dst;
-	}
+    LOCK(lock);
+
+    do_tzset();
+
+    if (zi) {
+        size_t alt, i = scan_trans(t, local, &alt);
+        if (i != -1) {
+            *isdst = types[6*i+4];
+            *offset = (int32_t)zi_read32(types+6*i);
+            *zonename = (const char *)abbrevs + types[6*i+5];
+            if (oppoff) *oppoff = (int32_t)zi_read32(types+6*alt);
+            UNLOCK(lock);
+            return;
+        }
+    }
+
+    if (!__daylight) goto std;
+
+    long long y = t / 31556952 + 70;
+    while (__year_to_secs(y, 0) > t) y--;
+    while (__year_to_secs(y+1, 0) < t) y++;
+
+    long long t0 = rule_to_secs(r0, y);
+    long long t1 = rule_to_secs(r1, y);
+
+    if (!local) {
+        t0 += __timezone;
+        t1 += dst_off;
+    }
+    if (t0 < t1) {
+        if (t >= t0 && t < t1) goto dst;
+        goto std;
+    } else {
+        if (t >= t1 && t < t0) goto std;
+        goto dst;
+    }
 std:
-	*isdst = 0;
-	*offset = -__timezone;
-	if (oppoff) *oppoff = -dst_off;
-	*zonename = __tzname[0];
-	UNLOCK(lock);
-	return;
+    *isdst = 0;
+    *offset = -__timezone;
+    if (oppoff) {
+        *oppoff = -dst_off;
+    }
+    *zonename = __tzname[0];
+    UNLOCK(lock);
+    return;
 dst:
-	*isdst = 1;
-	*offset = -dst_off;
-	if (oppoff) *oppoff = -__timezone;
-	*zonename = __tzname[1];
-	UNLOCK(lock);
+    *isdst = 1;
+    *offset = -dst_off;
+    if (oppoff) {
+        *oppoff = -__timezone;
+    }
+    *zonename = __tzname[1];
+    UNLOCK(lock);
 }
 
 static void __tzset()
 {
-	LOCK(lock);
-	do_tzset();
-	UNLOCK(lock);
+    LOCK(lock);
+    do_tzset();
+    UNLOCK(lock);
 }
 
 weak_alias(__tzset, tzset);
 
 const char *__tm_to_tzname(const struct tm *tm)
 {
-	const void *p = tm->__tm_zone;
-	LOCK(lock);
-	do_tzset();
-	if (p != __utc && p != __tzname[0] && p != __tzname[1] &&
-	    (!zi || (uintptr_t)p-(uintptr_t)abbrevs >= abbrevs_end - abbrevs))
-		p = "";
-	UNLOCK(lock);
-	return p;
+    const void *p = tm->__tm_zone;
+    LOCK(lock);
+    do_tzset();
+    if (p != __utc && p != __tzname[0] && p != __tzname[1] &&
+        (!zi || (uintptr_t)p-(uintptr_t)abbrevs >= abbrevs_end - abbrevs)) {
+        p = "";
+    }
+    UNLOCK(lock);
+    return p;
 }
diff --git a/src/time/clock_getres.c b/src/time/clock_getres.c
index 81c67037..d594b646 100644
--- a/src/time/clock_getres.c
+++ b/src/time/clock_getres.c
@@ -1,13 +1,60 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <time.h>
+#include <errno.h>
+#include <stdint.h>
 #include "syscall.h"
+#include "atomic.h"
+
+#ifdef VDSO_CGR_SYM
+
+static void *volatile vdso_cgr;
+
+static int cgr_init(clockid_t clk, struct timespec *ts)
+{
+	__get_vdso_info();
+	void *p = __get_vdso_addr(VDSO_CGR_VER, VDSO_CGR_SYM);
+	int (*f)(clockid_t, struct timespec *) =
+		(int (*)(clockid_t, struct timespec *))p;
+	a_cas_p(&vdso_cgr, (void *)cgr_init, p);
+	return f ? f(clk, ts) : -ENOSYS;
+}
+
+static void *volatile vdso_cgr = (void *)cgr_init;
+
+#endif
 
 int clock_getres(clockid_t clk, struct timespec *ts)
 {
+	int r;
+#ifdef VDSO_CGR_SYM
+	int (*f)(clockid_t, struct timespec *) =
+		(int (*)(clockid_t, struct timespec *))vdso_cgr;
+	if (f) {
+		r = f(clk, ts);
+		if (!r) return r;
+		if (r == -EINVAL) return __syscall_ret(r);
+	}
+#endif
+
 #ifdef SYS_clock_getres_time64
 	/* On a 32-bit arch, use the old syscall if it exists. */
 	if (SYS_clock_getres != SYS_clock_getres_time64) {
 		long ts32[2];
-		int r = __syscall(SYS_clock_getres, clk, ts32);
+		r = __syscall(SYS_clock_getres, clk, ts32);
 		if (!r && ts) {
 			ts->tv_sec = ts32[0];
 			ts->tv_nsec = ts32[1];
diff --git a/src/time/clock_gettime.c b/src/time/clock_gettime.c
index 3e1d0975..b1912f14 100644
--- a/src/time/clock_gettime.c
+++ b/src/time/clock_gettime.c
@@ -1,3 +1,18 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <time.h>
 #include <errno.h>
 #include <stdint.h>
@@ -33,10 +48,11 @@ static int cgt_time32_wrap(clockid_t clk, struct timespec *ts)
 
 static int cgt_init(clockid_t clk, struct timespec *ts)
 {
-	void *p = __vdsosym(VDSO_CGT_VER, VDSO_CGT_SYM);
+	__get_vdso_info();
+    void *p = __get_vdso_addr(VDSO_CGT_VER, VDSO_CGT_SYM);
 #ifdef VDSO_CGT32_SYM
 	if (!p) {
-		void *q = __vdsosym(VDSO_CGT32_VER, VDSO_CGT32_SYM);
+		void *q = __get_vdso_addr(VDSO_CGT32_VER, VDSO_CGT32_SYM);
 		if (q) {
 			a_cas_p(&vdso_func_32, 0, q);
 			p = cgt_time32_wrap;
diff --git a/src/time/gettimeofday.c b/src/time/gettimeofday.c
index 691f8e90..836655ac 100644
--- a/src/time/gettimeofday.c
+++ b/src/time/gettimeofday.c
@@ -1,9 +1,57 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <time.h>
 #include <sys/time.h>
+#include <time.h>
+#include <errno.h>
+#include <stdint.h>
 #include "syscall.h"
+#include "atomic.h"
+
+#ifdef VDSO_GTD_SYM
+
+static void *volatile vdso_gtd;
+
+static int gtd_init(struct timeval *tv, void *tz)
+{
+	__get_vdso_info();
+	void *p = __get_vdso_addr(VDSO_GTD_VER, VDSO_GTD_SYM);
+	int (*f)(struct timeval *, void *) =
+		(int (*)(struct timval *, void *))p;
+	a_cas_p(&vdso_gtd, (void *)gtd_init, p);
+	return f ? f(tv, tz) : -ENOSYS;
+}
+
+static void *volatile vdso_gtd = (void *)gtd_init;
+
+#endif
 
 int gettimeofday(struct timeval *restrict tv, void *restrict tz)
 {
+#ifdef VDSO_GTD_SYM
+    int r;
+	int (*f)(struct timeval *, void *) =
+	(int (*)(struct timeval *, void *))vdso_gtd;
+    if (f) {
+		r = f(tv, tz);
+		if (!r) return r;
+		if (r == -EINVAL) return __syscall_ret(r);
+	}
+#endif
+	
 	struct timespec ts;
 	if (!tv) return 0;
 	clock_gettime(CLOCK_REALTIME, &ts);
diff --git a/src/time/gmtime_r.c b/src/time/gmtime_r.c
index 22aec2c2..fe2eb943 100644
--- a/src/time/gmtime_r.c
+++ b/src/time/gmtime_r.c
@@ -1,16 +1,31 @@
-#include "time_impl.h"
+/**
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <errno.h>
+#include "time_impl.h"
 
 struct tm *__gmtime_r(const time_t *restrict t, struct tm *restrict tm)
 {
-	if (__secs_to_tm(*t, tm) < 0) {
-		errno = EOVERFLOW;
-		return 0;
-	}
-	tm->tm_isdst = 0;
-	tm->__tm_gmtoff = 0;
-	tm->__tm_zone = __utc;
-	return tm;
+    if (__secs_to_tm(*t, tm) < 0) {
+        errno = EOVERFLOW;
+        return 0;
+    }
+    tm->tm_isdst = 0;
+    tm->__tm_gmtoff = 0;
+    tm->__tm_zone = __gmt;
+    return tm;
 }
 
-weak_alias(__gmtime_r, gmtime_r);
+weak_alias(__gmtime_r, gmtime_r);
\ No newline at end of file
diff --git a/src/time/strftime.c b/src/time/strftime.c
index cc53d536..6a0f5bfd 100644
--- a/src/time/strftime.c
+++ b/src/time/strftime.c
@@ -1,3 +1,18 @@
+/**
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -8,274 +23,348 @@
 #include "locale_impl.h"
 #include "time_impl.h"
 
+#define __YEAR_BASE__ 1900
+#define __WEEKS_IN_YEAR__ 52
+#define __WEEKS_IN_YEAR2__ 53
+#define __DAY_LAST_WEEK__ 4
+#define __DAY_LAST_WEEK2__ 3
+#define __YEARS_PER_CENTURY__ 100
+#define __DAYS_IN_YEAR__ 360
+#define __LEN_YEAR__ 4
+#define __HALF_HOUR__ 12
+#define __LEN_DAY__ 3
+
 static int is_leap(int y)
 {
-	/* Avoid overflow */
-	if (y>INT_MAX-1900) y -= 2000;
-	y += 1900;
-	return !(y%4) && ((y%100) || !(y%400));
+    /* Avoid overflow */
+    if (y > INT_MAX - __YEAR_BASE__) {
+        y -= 2000;
+    }
+    y += __YEAR_BASE__;
+    return !(y%4) && ((y%100) || !(y%400));
 }
 
 static int week_num(const struct tm *tm)
 {
-	int val = (tm->tm_yday + 7U - (tm->tm_wday+6U)%7) / 7;
-	/* If 1 Jan is just 1-3 days past Monday,
-	 * the previous week is also in this year. */
-	if ((tm->tm_wday + 371U - tm->tm_yday - 2) % 7 <= 2)
-		val++;
-	if (!val) {
-		val = 52;
-		/* If 31 December of prev year a Thursday,
-		 * or Friday of a leap year, then the
-		 * prev year has 53 weeks. */
-		int dec31 = (tm->tm_wday + 7U - tm->tm_yday - 1) % 7;
-		if (dec31 == 4 || (dec31 == 5 && is_leap(tm->tm_year%400-1)))
-			val++;
-	} else if (val == 53) {
-		/* If 1 January is not a Thursday, and not
-		 * a Wednesday of a leap year, then this
-		 * year has only 52 weeks. */
-		int jan1 = (tm->tm_wday + 371U - tm->tm_yday) % 7;
-		if (jan1 != 4 && (jan1 != 3 || !is_leap(tm->tm_year)))
-			val = 1;
-	}
-	return val;
+    int val = (tm->tm_yday + 7U - (tm->tm_wday+6U)%7) / 7;
+    /* If 1 Jan is just 1-3 days past Monday,
+     * the previous week is also in this year. */
+    if ((tm->tm_wday + 371U - tm->tm_yday - 2) % 7 <= 2)
+        val++;
+    if (!val) {
+        val = __WEEKS_IN_YEAR__;
+        /* If 31 December of prev year a Thursday,
+         * or Friday of a leap year, then the
+         * prev year has 53 weeks. */
+        int dec31 = (tm->tm_wday + 7U - tm->tm_yday - 1) % 7;
+        if (dec31 == 4 || (dec31 == 5 && is_leap(tm->tm_year%400-1)))
+            val++;
+    } else if (val == __WEEKS_IN_YEAR2__) {
+        /* If 1 January is not a Thursday, and not
+         * a Wednesday of a leap year, then this
+         * year has only 52 weeks. */
+        int jan1 = (tm->tm_wday + 371U - tm->tm_yday) % 7;
+        if (jan1 != __DAY_LAST_WEEK__ && (jan1 != 3 || !is_leap(tm->tm_year)))
+            val = 1;
+    }
+    return val;
 }
 
 const char *__strftime_fmt_1(char (*s)[100], size_t *l, int f, const struct tm *tm, locale_t loc, int pad)
 {
-	nl_item item;
-	long long val;
-	const char *fmt = "-";
-	int width = 2, def_pad = '0';
+    nl_item item;
+    long long val;
+    const char *fmt = "-";
+    int width = 2, def_pad = '0';
 
-	switch (f) {
-	case 'a':
-		if (tm->tm_wday > 6U) goto string;
-		item = ABDAY_1 + tm->tm_wday;
-		goto nl_strcat;
-	case 'A':
-		if (tm->tm_wday > 6U) goto string;
-		item = DAY_1 + tm->tm_wday;
-		goto nl_strcat;
-	case 'h':
-	case 'b':
-		if (tm->tm_mon > 11U) goto string;
-		item = ABMON_1 + tm->tm_mon;
-		goto nl_strcat;
-	case 'B':
-		if (tm->tm_mon > 11U) goto string;
-		item = MON_1 + tm->tm_mon;
-		goto nl_strcat;
-	case 'c':
-		item = D_T_FMT;
-		goto nl_strftime;
-	case 'C':
-		val = (1900LL+tm->tm_year) / 100;
-		goto number;
-	case 'e':
-		def_pad = '_';
-	case 'd':
-		val = tm->tm_mday;
-		goto number;
-	case 'D':
-		fmt = "%m/%d/%y";
-		goto recu_strftime;
-	case 'F':
-		fmt = "%Y-%m-%d";
-		goto recu_strftime;
-	case 'g':
-	case 'G':
-		val = tm->tm_year + 1900LL;
-		if (tm->tm_yday < 3 && week_num(tm) != 1) val--;
-		else if (tm->tm_yday > 360 && week_num(tm) == 1) val++;
-		if (f=='g') val %= 100;
-		else width = 4;
-		goto number;
-	case 'H':
-		val = tm->tm_hour;
-		goto number;
-	case 'I':
-		val = tm->tm_hour;
-		if (!val) val = 12;
-		else if (val > 12) val -= 12;
-		goto number;
-	case 'j':
-		val = tm->tm_yday+1;
-		width = 3;
-		goto number;
-	case 'm':
-		val = tm->tm_mon+1;
-		goto number;
-	case 'M':
-		val = tm->tm_min;
-		goto number;
-	case 'n':
-		*l = 1;
-		return "\n";
-	case 'p':
-		item = tm->tm_hour >= 12 ? PM_STR : AM_STR;
-		goto nl_strcat;
-	case 'r':
-		item = T_FMT_AMPM;
-		goto nl_strftime;
-	case 'R':
-		fmt = "%H:%M";
-		goto recu_strftime;
-	case 's':
-		val = __tm_to_secs(tm) - tm->__tm_gmtoff;
-		width = 1;
-		goto number;
-	case 'S':
-		val = tm->tm_sec;
-		goto number;
-	case 't':
-		*l = 1;
-		return "\t";
-	case 'T':
-		fmt = "%H:%M:%S";
-		goto recu_strftime;
-	case 'u':
-		val = tm->tm_wday ? tm->tm_wday : 7;
-		width = 1;
-		goto number;
-	case 'U':
-		val = (tm->tm_yday + 7U - tm->tm_wday) / 7;
-		goto number;
-	case 'W':
-		val = (tm->tm_yday + 7U - (tm->tm_wday+6U)%7) / 7;
-		goto number;
-	case 'V':
-		val = week_num(tm);
-		goto number;
-	case 'w':
-		val = tm->tm_wday;
-		width = 1;
-		goto number;
-	case 'x':
-		item = D_FMT;
-		goto nl_strftime;
-	case 'X':
-		item = T_FMT;
-		goto nl_strftime;
-	case 'y':
-		val = (tm->tm_year + 1900LL) % 100;
-		if (val < 0) val = -val;
-		goto number;
-	case 'Y':
-		val = tm->tm_year + 1900LL;
-		if (val >= 10000) {
-			*l = snprintf(*s, sizeof *s, "+%lld", val);
-			return *s;
-		}
-		width = 4;
-		goto number;
-	case 'z':
-		if (tm->tm_isdst < 0) {
-			*l = 0;
-			return "";
-		}
-		*l = snprintf(*s, sizeof *s, "%+.4ld",
-			tm->__tm_gmtoff/3600*100 + tm->__tm_gmtoff%3600/60);
-		return *s;
-	case 'Z':
-		if (tm->tm_isdst < 0) {
-			*l = 0;
-			return "";
-		}
-		fmt = __tm_to_tzname(tm);
-		goto string;
-	case '%':
-		*l = 1;
-		return "%";
-	default:
-		return 0;
-	}
+    switch (f) {
+        case 'a':
+            if (tm->tm_wday > 6U) goto string;
+            item = ABDAY_1 + tm->tm_wday;
+            goto nl_strcat;
+        case 'A':
+            if (tm->tm_wday > 6U) goto string;
+            item = DAY_1 + tm->tm_wday;
+            goto nl_strcat;
+        case 'h':
+        case 'b':
+            if (tm->tm_mon > 11U) {
+                goto string;
+            }
+            item = ABMON_1 + tm->tm_mon;
+            goto nl_strcat;
+        case 'B':
+            if (tm->tm_mon > 11U) {
+                goto string;
+            }
+            item = MON_1 + tm->tm_mon;
+            goto nl_strcat;
+        case 'c':
+            item = D_T_FMT;
+            goto nl_strftime;
+        case 'C':
+            val = (1900LL+tm->tm_year) / __YEARS_PER_CENTURY__;
+            goto number;
+        case 'e':
+            def_pad = '_';
+        case 'd':
+            val = tm->tm_mday;
+            goto number;
+        case 'D':
+            fmt = "%m/%d/%y";
+            goto recu_strftime;
+        case 'F':
+            fmt = "%Y-%m-%d";
+            goto recu_strftime;
+        case 'g':
+        case 'G':
+            val = tm->tm_year + 1900LL;
+            if (tm->tm_yday < __DAY_LAST_WEEK2__ && week_num(tm) != 1) {
+                val--;
+            } else if (tm->tm_yday > __DAYS_IN_YEAR__ && week_num(tm) == 1) {
+                val++;
+            }
+            if (f=='g') {
+                val %= __YEARS_PER_CENTURY__;
+            } else {
+                width = __LEN_YEAR__;
+            }
+            goto number;
+        case 'H':
+            val = tm->tm_hour;
+            goto number;
+        case 'I':
+            val = tm->tm_hour;
+            if (!val) {
+                val = __HALF_HOUR__;
+            } else if (val > __HALF_HOUR__) {
+                val -= __HALF_HOUR__;
+            }
+            goto number;
+        case 'j':
+            val = tm->tm_yday+1;
+            width = __LEN_DAY__;
+            goto number;
+        case 'k':
+            def_pad = '_';
+            val = tm->tm_hour;
+            goto number;
+        case 'l':
+            def_pad = '_';
+            val = tm->tm_hour;
+            if (!val) {
+                val = __HALF_HOUR__;
+            } else if (val > __HALF_HOUR__) {
+                val -= __HALF_HOUR__;
+            }
+            goto number;
+        case 'm':
+            val = tm->tm_mon+1;
+            goto number;
+        case 'M':
+            val = tm->tm_min;
+            goto number;
+        case 'n':
+            *l = 1;
+            return "\n";
+        case 'p':
+            item = tm->tm_hour >= __HALF_HOUR__ ? PM_STR : AM_STR;
+            goto nl_strcat;
+        case 'P':
+            item = tm->tm_hour >= __HALF_HOUR__ ? PM_STR_LOWER : AM_STR_LOWER;
+            goto nl_strcat;
+        case 'r':
+            item = T_FMT_AMPM;
+            goto nl_strftime;
+        case 'R':
+            fmt = "%H:%M";
+            goto recu_strftime;
+        case 's':
+            val = __tm_to_secs(tm) - tm->__tm_gmtoff;
+            width = 1;
+            goto number;
+        case 'S':
+            val = tm->tm_sec;
+            goto number;
+        case 't':
+            *l = 1;
+            return "\t";
+        case 'T':
+            fmt = "%H:%M:%S";
+            goto recu_strftime;
+        case 'u':
+            val = tm->tm_wday ? tm->tm_wday : 7;
+            width = 1;
+            goto number;
+        case 'U':
+            val = (tm->tm_yday + 7U - tm->tm_wday) / 7;
+            goto number;
+        case 'W':
+            val = (tm->tm_yday + 7U - (tm->tm_wday+6U)%7) / 7;
+            goto number;
+        case 'V':
+            val = week_num(tm);
+            goto number;
+        case 'v':
+            fmt = "%e-%b-%Y";
+            goto recu_strftime;
+        case 'w':
+            val = tm->tm_wday;
+            width = 1;
+            goto number;
+        case 'x':
+            item = D_FMT;
+            goto nl_strftime;
+        case 'X':
+            item = T_FMT;
+            goto nl_strftime;
+        case 'y':
+            val = (tm->tm_year + 1900LL) % 100;
+            if (val < 0) {
+                val = -val;
+            }
+            goto number;
+        case 'Y':
+            val = tm->tm_year + 1900LL;
+            if (val >= 10000) {
+                *l = snprintf(*s, sizeof *s, "+%lld", val);
+                return *s;
+            }
+            width = __LEN_YEAR__;
+            goto number;
+        case 'z':
+            if (tm->tm_isdst < 0) {
+                *l = 0;
+                return "";
+            }
+            *l = snprintf(*s, sizeof *s, "%+.4ld",
+                tm->__tm_gmtoff/3600*100 + tm->__tm_gmtoff%3600/60);
+            return *s;
+        case 'Z':
+            if (tm->tm_isdst < 0) {
+                *l = 0;
+                return "";
+            }
+            fmt = __tm_to_tzname(tm);
+            goto string;
+        case '%':
+            *l = 1;
+            return "%";
+        default:
+            return 0;
+    }
 number:
-	switch (pad ? pad : def_pad) {
-	case '-': *l = snprintf(*s, sizeof *s, "%lld", val); break;
-	case '_': *l = snprintf(*s, sizeof *s, "%*lld", width, val); break;
-	case '0':
-	default:  *l = snprintf(*s, sizeof *s, "%0*lld", width, val); break;
-	}
-	return *s;
+    switch (pad ? pad : def_pad) {
+        case '-':
+            *l = snprintf(*s, sizeof *s, "%lld", val);
+            break;
+        case '_':
+            *l = snprintf(*s, sizeof *s, "%*lld", width, val);
+            break;
+        case '0':
+        default:
+            *l = snprintf(*s, sizeof *s, "%0*lld", width, val);
+            break;
+    }
+    return *s;
 nl_strcat:
-	fmt = __nl_langinfo_l(item, loc);
+    fmt = __nl_langinfo_l(item, loc);
 string:
-	*l = strlen(fmt);
-	return fmt;
+    *l = strlen(fmt);
+    return fmt;
 nl_strftime:
-	fmt = __nl_langinfo_l(item, loc);
+    fmt = __nl_langinfo_l(item, loc);
 recu_strftime:
-	*l = __strftime_l(*s, sizeof *s, fmt, tm, loc);
-	if (!*l) return 0;
-	return *s;
+    *l = __strftime_l(*s, sizeof *s, fmt, tm, loc);
+    if (!*l) {
+        return 0;
+    }
+    return *s;
 }
 
 size_t __strftime_l(char *restrict s, size_t n, const char *restrict f, const struct tm *restrict tm, locale_t loc)
 {
-	size_t l, k;
-	char buf[100];
-	char *p;
-	const char *t;
-	int pad, plus;
-	unsigned long width;
-	for (l=0; l<n; f++) {
-		if (!*f) {
-			s[l] = 0;
-			return l;
-		}
-		if (*f != '%') {
-			s[l++] = *f;
-			continue;
-		}
-		f++;
-		pad = 0;
-		if (*f == '-' || *f == '_' || *f == '0') pad = *f++;
-		if ((plus = (*f == '+'))) f++;
-		width = strtoul(f, &p, 10);
-		if (*p == 'C' || *p == 'F' || *p == 'G' || *p == 'Y') {
-			if (!width && p!=f) width = 1;
-		} else {
-			width = 0;
-		}
-		f = p;
-		if (*f == 'E' || *f == 'O') f++;
-		t = __strftime_fmt_1(&buf, &k, *f, tm, loc, pad);
-		if (!t) break;
-		if (width) {
-			/* Trim off any sign and leading zeros, then
-			 * count remaining digits to determine behavior
-			 * for the + flag. */
-			if (*t=='+' || *t=='-') t++, k--;
-			for (; *t=='0' && t[1]-'0'<10U; t++, k--);
-			if (width < k) width = k;
-			size_t d;
-			for (d=0; t[d]-'0'<10U; d++);
-			if (tm->tm_year < -1900) {
-				s[l++] = '-';
-				width--;
-			} else if (plus && d+(width-k) >= (*p=='C'?3:5)) {
-				s[l++] = '+';
-				width--;
-			}
-			for (; width > k && l < n; width--)
-				s[l++] = '0';
-		}
-		if (k > n-l) k = n-l;
-		memcpy(s+l, t, k);
-		l += k;
-	}
-	if (n) {
-		if (l==n) l=n-1;
-		s[l] = 0;
-	}
-	return 0;
+    size_t l, k;
+    char buf[100];
+    char *p;
+    const char *t;
+    int pad, plus;
+    unsigned long width;
+    for (l=0; l<n; f++) {
+        if (!*f) {
+            s[l] = 0;
+            return l;
+        }
+        if (*f != '%') {
+            s[l++] = *f;
+            continue;
+        }
+        f++;
+        pad = 0;
+        if (*f == '-' || *f == '_' || *f == '0') {
+            pad = *f++;
+        }
+        if ((plus = (*f == '+'))) {
+            f++;
+        }
+        width = strtoul(f, &p, 10);
+        if (*p == 'C' || *p == 'F' || *p == 'G' || *p == 'Y') {
+            if (!width && p!=f) {
+                width = 1;
+            }
+        } else {
+            width = 0;
+        }
+        f = p;
+        if (*f == 'E' || *f == 'O') {
+            f++;
+        }
+        t = __strftime_fmt_1(&buf, &k, *f, tm, loc, pad);
+        if (!t) {
+            break;
+        }
+        if (width) {
+            /* Trim off any sign and leading zeros, then
+             * count remaining digits to determine behavior
+             * for the + flag. */
+            if (*t=='+' || *t=='-') {
+                t++, k--;
+            }
+            for (; *t=='0' && t[1]-'0'<10U; t++, k--) {}
+            if (width < k) {
+                width = k;
+            }
+            size_t d;
+            for (d=0; t[d]-'0'<10U; d++) {}
+            if (tm->tm_year < -1900) {
+                s[l++] = '-';
+                width--;
+            } else if (plus && d+(width-k) >= (*p=='C'?3:5)) {
+                s[l++] = '+';
+                width--;
+            }
+            for (; width > k && l < n; width--) {
+                s[l++] = '0';
+            }
+        }
+        if (k > n-l) {
+            k = n-l;
+        }
+        memcpy(s+l, t, k);
+        l += k;
+    }
+    if (n) {
+        if (l==n) {
+            l=n-1;
+        }
+        s[l] = 0;
+    }
+    return 0;
 }
 
 size_t strftime(char *restrict s, size_t n, const char *restrict f, const struct tm *restrict tm)
 {
-	return __strftime_l(s, n, f, tm, CURRENT_LOCALE);
+    return __strftime_l(s, n, f, tm, CURRENT_LOCALE);
 }
 
-weak_alias(__strftime_l, strftime_l);
+weak_alias(__strftime_l, strftime_l);
\ No newline at end of file
diff --git a/src/time/strptime.c b/src/time/strptime.c
index c54a0d8c..fd357d90 100644
--- a/src/time/strptime.c
+++ b/src/time/strptime.c
@@ -1,3 +1,18 @@
+/**
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <stdlib.h>
 #include <langinfo.h>
 #include <time.h>
@@ -5,202 +20,431 @@
 #include <stddef.h>
 #include <string.h>
 #include <strings.h>
+/* seconds per hour */
+#define __STRPTIME_SECOND_IN_HOUR 3600
+/* character-to-number base */
+#define __STRPTIME_NUMBER_BASE 10
+/* epoch time */
+#define __STRPTIME_EPOCH 1900
+/* receive data buffer size */
+#define __STRPTIME_BUFFER_SIZE 16
+/* Width of hours and minutes when formatting %z */
+#define __STRPTIME_ZONE_WIDTH 2
+/* time base */
+#define __STRPTIME_TIME_BASE 60
+/* number of weeks per year */
+#define __STRPTIME_WEEKS_IN_YEAR 53
+/* days of the week */
+#define __STRPTIME_DAYS_IN_WEEK 7
+/* 12 hour clock */
+#define __STRPTIME_HOUR_CLOCK_12 12
+/* 24 hour clock */
+#define __STRPTIME_HOUR_CLOCK_24 24
+/* days per year */
+#define __STRPTIME_DAYS_PER_YEAR 366
+/* Years in each century */
+#define __STRPTIME_YEARS_PER_CENTURY 100
 
-char *strptime(const char *restrict s, const char *restrict f, struct tm *restrict tm)
+int __getzonename(const char *restrict s, struct tm *restrict tm)
 {
-	int i, w, neg, adj, min, range, *dest, dummy;
-	const char *ex;
-	size_t len;
-	int want_century = 0, century = 0, relyear = 0;
-	while (*f) {
-		if (*f != '%') {
-			if (isspace(*f)) for (; *s && isspace(*s); s++);
-			else if (*s != *f) return 0;
-			else s++;
-			f++;
-			continue;
-		}
-		f++;
-		if (*f == '+') f++;
-		if (isdigit(*f)) {
-			char *new_f;
-			w=strtoul(f, &new_f, 10);
-			f = new_f;
-		} else {
-			w=-1;
-		}
-		adj=0;
-		switch (*f++) {
-		case 'a': case 'A':
-			dest = &tm->tm_wday;
-			min = ABDAY_1;
-			range = 7;
-			goto symbolic_range;
-		case 'b': case 'B': case 'h':
-			dest = &tm->tm_mon;
-			min = ABMON_1;
-			range = 12;
-			goto symbolic_range;
-		case 'c':
-			s = strptime(s, nl_langinfo(D_T_FMT), tm);
-			if (!s) return 0;
-			break;
-		case 'C':
-			dest = &century;
-			if (w<0) w=2;
-			want_century |= 2;
-			goto numeric_digits;
-		case 'd': case 'e':
-			dest = &tm->tm_mday;
-			min = 1;
-			range = 31;
-			goto numeric_range;
-		case 'D':
-			s = strptime(s, "%m/%d/%y", tm);
-			if (!s) return 0;
-			break;
-		case 'H':
-			dest = &tm->tm_hour;
-			min = 0;
-			range = 24;
-			goto numeric_range;
-		case 'I':
-			dest = &tm->tm_hour;
-			min = 1;
-			range = 12;
-			goto numeric_range;
-		case 'j':
-			dest = &tm->tm_yday;
-			min = 1;
-			range = 366;
-			adj = 1;
-			goto numeric_range;
-		case 'm':
-			dest = &tm->tm_mon;
-			min = 1;
-			range = 12;
-			adj = 1;
-			goto numeric_range;
-		case 'M':
-			dest = &tm->tm_min;
-			min = 0;
-			range = 60;
-			goto numeric_range;
-		case 'n': case 't':
-			for (; *s && isspace(*s); s++);
-			break;
-		case 'p':
-			ex = nl_langinfo(AM_STR);
-			len = strlen(ex);
-			if (!strncasecmp(s, ex, len)) {
-				tm->tm_hour %= 12;
-				s += len;
-				break;
-			}
-			ex = nl_langinfo(PM_STR);
-			len = strlen(ex);
-			if (!strncasecmp(s, ex, len)) {
-				tm->tm_hour %= 12;
-				tm->tm_hour += 12;
-				s += len;
-				break;
-			}
-			return 0;
-		case 'r':
-			s = strptime(s, nl_langinfo(T_FMT_AMPM), tm);
-			if (!s) return 0;
-			break;
-		case 'R':
-			s = strptime(s, "%H:%M", tm);
-			if (!s) return 0;
-			break;
-		case 'S':
-			dest = &tm->tm_sec;
-			min = 0;
-			range = 61;
-			goto numeric_range;
-		case 'T':
-			s = strptime(s, "%H:%M:%S", tm);
-			if (!s) return 0;
-			break;
-		case 'U':
-		case 'W':
-			/* Throw away result, for now. (FIXME?) */
-			dest = &dummy;
-			min = 0;
-			range = 54;
-			goto numeric_range;
-		case 'w':
-			dest = &tm->tm_wday;
-			min = 0;
-			range = 7;
-			goto numeric_range;
-		case 'x':
-			s = strptime(s, nl_langinfo(D_FMT), tm);
-			if (!s) return 0;
-			break;
-		case 'X':
-			s = strptime(s, nl_langinfo(T_FMT), tm);
-			if (!s) return 0;
-			break;
-		case 'y':
-			dest = &relyear;
-			w = 2;
-			want_century |= 1;
-			goto numeric_digits;
-		case 'Y':
-			dest = &tm->tm_year;
-			if (w<0) w=4;
-			adj = 1900;
-			want_century = 0;
-			goto numeric_digits;
-		case '%':
-			if (*s++ != '%') return 0;
-			break;
-		default:
-			return 0;
-		numeric_range:
-			if (!isdigit(*s)) return 0;
-			*dest = 0;
-			for (i=1; i<=min+range && isdigit(*s); i*=10)
-				*dest = *dest * 10 + *s++ - '0';
-			if (*dest - min >= (unsigned)range) return 0;
-			*dest -= adj;
-			switch((char *)dest - (char *)tm) {
-			case offsetof(struct tm, tm_yday):
-				;
-			}
-			goto update;
-		numeric_digits:
-			neg = 0;
-			if (*s == '+') s++;
-			else if (*s == '-') neg=1, s++;
-			if (!isdigit(*s)) return 0;
-			for (*dest=i=0; i<w && isdigit(*s); i++)
-				*dest = *dest * 10 + *s++ - '0';
-			if (neg) *dest = -*dest;
-			*dest -= adj;
-			goto update;
-		symbolic_range:
-			for (i=2*range-1; i>=0; i--) {
-				ex = nl_langinfo(min+i);
-				len = strlen(ex);
-				if (strncasecmp(s, ex, len)) continue;
-				s += len;
-				*dest = i % range;
-				break;
-			}
-			if (i<0) return 0;
-			goto update;
-		update:
-			//FIXME
-			;
-		}
-	}
-	if (want_century) {
-		tm->tm_year = relyear;
-		if (want_century & 2) tm->tm_year += century * 100 - 1900;
-		else if (tm->tm_year <= 68) tm->tm_year += 100;
-	}
-	return (char *)s;
+    const char *p = s;
+    struct tm old;
+    memcpy(&old, tm, sizeof(struct tm));
+    /* Possible time zone names like +XXX or -XXX */
+    if (*p == '+' || *p == '-') {
+        p++;
+    }
+
+    /* The time zone name is adjacent to the offset second data,
+     * and the following symbol belongs to the offset second */
+    while (*p && (*p != '+' && *p != '-' && *p != ' ')) {
+        p++;
+    }
+
+    /* In the structure struct tm, tm_zone is declared as const char * type, so use static */
+    static char buf[__STRPTIME_BUFFER_SIZE] = {0};
+    memset(buf, 0x0, sizeof(buf));
+    int len = p - s;
+    memcpy(buf, s, len);
+    tm->__tm_zone = buf;
+
+    /* Re-fetch local data, extract tm_isdst flag. */
+    time_t t = mktime(&old);
+    struct tm *tmp = localtime(&t);
+    if (tmp) {
+        tm->tm_isdst = tmp->tm_isdst;
+    }
+    return len;
 }
+
+int __getgmtoff(const char *restrict s, struct tm *restrict tm)
+{
+    const char *p = s;
+    int sign = 1;
+    int i;
+    int isexit = 0;
+    long m = 0;
+    long h = 0;
+
+    /* The possible formats for time offset are HHMM(-HHMM) or HH:MM(-HH:MM) */
+    if (*p == '-') {
+        sign = -1;
+    }
+    p++;
+    tm->__tm_gmtoff = 0;
+
+    /* get hours */
+    for (i=0; i<__STRPTIME_ZONE_WIDTH && *p; i++, p++) {
+        if (isdigit(*p)) {
+            h = h * __STRPTIME_NUMBER_BASE + (*p - 0x30);
+        } else {
+            p--;
+            isexit = 1;
+            break;
+        }
+    }
+
+    if (!isexit) {
+        /* Possible time zone formats are HH:MM. */
+        if (*p == ':') {
+            *p++;
+        }
+
+        /* get minutes */
+        for (i=0; i<__STRPTIME_ZONE_WIDTH && *p; i++, p++) {
+            if (isdigit(*p)) {
+                m = m * __STRPTIME_NUMBER_BASE + (*p - 0x30);
+            } else {
+                p--;
+                isexit = 1;
+                break;
+            }
+        }
+    }
+
+    /* Convert hours and minutes to seconds */
+    tm->__tm_gmtoff = sign * (h * __STRPTIME_SECOND_IN_HOUR + m * __STRPTIME_TIME_BASE);
+
+    return p - s;
+}
+
+char *strptime(const char *restrict s, const char *restrict f, struct tm *restrict tm)
+{
+    int i, w, neg, adj, min, range, *dest, dummy;
+    const char *ex;
+    size_t len;
+    int want_century = 0, century = 0, relyear = 0;
+    while (*f) {
+        if (*f != '%') {
+            if (isspace(*f)) {
+                for (; *s && isspace(*s); s++);
+            } else if (*s != *f) {
+                return 0;
+            } else {
+                s++;
+            }
+            f++;
+            continue;
+        }
+        f++;
+        if (*f == '+') {
+            f++;
+        }
+        if (isdigit(*f)) {
+            char *new_f;
+            w=strtoul(f, &new_f, __STRPTIME_NUMBER_BASE);
+            f = new_f;
+        } else {
+            w=-1;
+        }
+        adj=0;
+        switch (*f++) {
+            case 'a': case 'A':
+                dest = &tm->tm_wday;
+                min = ABDAY_1;
+                range = __STRPTIME_DAYS_IN_WEEK;
+                goto symbolic_range;
+            case 'b': case 'B': case 'h':
+                dest = &tm->tm_mon;
+                min = ABMON_1;
+                range = __STRPTIME_HOUR_CLOCK_12;
+                goto symbolic_range;
+            case 'c':
+                s = strptime(s, nl_langinfo(D_T_FMT), tm);
+                if (!s) {
+                    return 0;
+                }
+                break;
+            case 'C':
+                dest = &century;
+                if (w<0) {
+                    w=__STRPTIME_ZONE_WIDTH;
+                }
+                want_century |= __STRPTIME_ZONE_WIDTH;
+                goto numeric_digits;
+            case 'd': case 'e':
+                dest = &tm->tm_mday;
+                min = 1;
+                range = 31;
+                goto numeric_range;
+            case 'D':
+                s = strptime(s, "%m/%d/%y", tm);
+                if (!s) {
+                    return 0;
+                }
+                break;
+            case 'F':
+                s = strptime(s, "%Y-%m-%d", tm);
+                if (!s) {
+                    return 0;
+                }
+                break;
+            case 'g':
+                dest = &tm->tm_year;
+                min = 0;
+                range = 99;
+                w = __STRPTIME_ZONE_WIDTH;
+                want_century = 0;
+                goto numeric_digits;
+            case 'G':
+                do {
+                    ++s;
+                } while (isdigit(*s));
+                continue;
+            case 'k':
+            case 'H':
+                dest = &tm->tm_hour;
+                min = 0;
+                range = __STRPTIME_HOUR_CLOCK_24;
+                goto numeric_range;
+            case 'l':
+            case 'I':
+                dest = &tm->tm_hour;
+                min = 1;
+                range = __STRPTIME_HOUR_CLOCK_12;
+                goto numeric_range;
+            case 'j':
+                dest = &tm->tm_yday;
+                min = 1;
+                range = __STRPTIME_DAYS_PER_YEAR;
+                adj = 1;
+                goto numeric_range;
+            case 'm':
+                dest = &tm->tm_mon;
+                min = 1;
+                range = __STRPTIME_HOUR_CLOCK_12;
+                adj = 1;
+                goto numeric_range;
+            case 'M':
+                dest = &tm->tm_min;
+                min = 0;
+                range = __STRPTIME_TIME_BASE;
+                goto numeric_range;
+            case 'n': case 't':
+                for (; *s && isspace(*s); s++) {}
+                break;
+            case 'p':
+            case 'P':
+                ex = nl_langinfo(AM_STR);
+                len = strlen(ex);
+                if (!strncasecmp(s, ex, len)) {
+                    tm->tm_hour %= __STRPTIME_HOUR_CLOCK_12;
+                    s += len;
+                    break;
+                }
+                ex = nl_langinfo(PM_STR);
+                len = strlen(ex);
+                if (!strncasecmp(s, ex, len)) {
+                    tm->tm_hour %= __STRPTIME_HOUR_CLOCK_12;
+                    tm->tm_hour += __STRPTIME_HOUR_CLOCK_12;
+                    s += len;
+                    break;
+                }
+                return 0;
+            case 'r':
+                s = strptime(s, nl_langinfo(T_FMT_AMPM), tm);
+                if (!s) {
+                    return 0;
+                }
+                break;
+            case 'R':
+                s = strptime(s, "%H:%M", tm);
+                if (!s) {
+                    return 0;
+                }
+                break;
+            case 's': {
+                time_t secs = 0;
+                if (!isdigit(*s)) {
+                    return 0;
+                }
+                do {
+                    secs *= __STRPTIME_NUMBER_BASE;
+                    secs += *s - '0';
+                    s++;
+                } while (isdigit(*s));
+                if (localtime_r(&secs, tm) == NULL) {
+                    return 0;
+                }
+                break;
+            }
+            case 'S':
+                dest = &tm->tm_sec;
+                min = 0;
+                range = 61;
+                goto numeric_range;
+            case 'T':
+                s = strptime(s, "%H:%M:%S", tm);
+                if (!s) {
+                    return 0;
+                }
+                break;
+            case 'u': {
+                if (!isdigit(*s)) {
+                    return 0;
+                }
+                int wday = 0;
+                int rulim = __STRPTIME_DAYS_IN_WEEK;
+                do {
+                    wday *= __STRPTIME_NUMBER_BASE;
+                    wday += *s++ - '0';
+                    rulim /= __STRPTIME_NUMBER_BASE;
+                } while ((wday * __STRPTIME_NUMBER_BASE < __STRPTIME_DAYS_IN_WEEK) && rulim && isdigit(*s));
+                if (wday < 1 || wday > __STRPTIME_DAYS_IN_WEEK) {
+                    return 0;
+                }
+                tm->tm_wday = wday % __STRPTIME_DAYS_IN_WEEK;
+                continue;
+            }
+            case 'U':
+            case 'W':
+                dest = &dummy;
+                min = 0;
+                range = __STRPTIME_WEEKS_IN_YEAR + 1;
+                goto numeric_range;
+            case 'w':
+                dest = &tm->tm_wday;
+                min = 0;
+                range = __STRPTIME_DAYS_IN_WEEK;
+                goto numeric_range;
+            case 'v':
+                if (!(s = strptime(s, "%e-%b-%Y", tm))) {
+                    return 0;
+                }
+                break;
+            case 'V': {
+                int r = 0;
+                int rulim = __STRPTIME_WEEKS_IN_YEAR;
+                if (!isdigit(*s)) {
+                    return 0;
+                }
+                do {
+                    r *= __STRPTIME_NUMBER_BASE;
+                    r += *s++ - '0';
+                    rulim /= __STRPTIME_NUMBER_BASE;
+                } while ((r * __STRPTIME_NUMBER_BASE < __STRPTIME_WEEKS_IN_YEAR) && rulim && isdigit(*s));
+                if (r < 0 || r > __STRPTIME_WEEKS_IN_YEAR) {
+                    return 0;
+                }
+                continue;
+            }
+            case 'x':
+                s = strptime(s, nl_langinfo(D_FMT), tm);
+                if (!s) {
+                    return 0;
+                }
+                break;
+            case 'X':
+                s = strptime(s, nl_langinfo(T_FMT), tm);
+                if (!s) {
+                    return 0;
+                }
+                break;
+            case 'y':
+                dest = &relyear;
+                w = __STRPTIME_ZONE_WIDTH;
+                want_century |= 1;
+                goto numeric_digits;
+            case 'Y':
+                dest = &tm->tm_year;
+                if (w<0) {
+                    w=4;
+                }
+                adj = __STRPTIME_EPOCH;
+                want_century = 0;
+                goto numeric_digits;
+            case 'Z':
+                tzset();
+                s += __getzonename((const char *)s, tm);
+                continue;
+            case 'z':
+                s += __getgmtoff((const char *)s, tm);
+                continue;
+            case '%':
+                if (*s++ != '%') {
+                    return 0;
+                }
+                break;
+            default:
+                return 0;
+                numeric_range:
+                if (!isdigit(*s)) {
+                    return 0;
+                }
+                *dest = 0;
+                for (i=1; i<=min+range && isdigit(*s); i*=__STRPTIME_NUMBER_BASE) {
+                    *dest = *dest * __STRPTIME_NUMBER_BASE + *s++ - '0';
+                }
+                if (*dest - min >= (unsigned)range) {
+                    return 0;
+                }
+                *dest -= adj;
+                switch ((char *)dest - (char *)tm) {
+                    case offsetof(struct tm, tm_yday):
+                        ;
+                }
+                goto update;
+                numeric_digits:
+                neg = 0;
+                if (*s == '+') {
+                    s++;
+                } else if (*s == '-') {
+                    neg=1, s++;
+                }
+                if (!isdigit(*s)) {
+                    return 0;
+                }
+                for (*dest=i=0; i<w && isdigit(*s); i++) {
+                    *dest = *dest * __STRPTIME_NUMBER_BASE + *s++ - '0';
+                }
+                if (neg) {
+                    *dest = -*dest;
+                }
+                *dest -= adj;
+                goto update;
+                symbolic_range:
+                for (i=__STRPTIME_ZONE_WIDTH*range-1; i>=0; i--) {
+                    ex = nl_langinfo(min+i);
+                    len = strlen(ex);
+                    if (strncasecmp(s, ex, len)) continue;
+                    s += len;
+                    *dest = i % range;
+                    break;
+                }
+                if (i<0) {
+                    return 0;
+                }
+                goto update;
+            update:
+                ;
+            }
+        }
+    if (want_century) {
+        tm->tm_year = relyear;
+        if (want_century & __STRPTIME_ZONE_WIDTH) {
+            tm->tm_year += century * __STRPTIME_YEARS_PER_CENTURY - __STRPTIME_EPOCH;
+        }
+        else if (tm->tm_year <= 68) tm->tm_year += __STRPTIME_YEARS_PER_CENTURY;
+    }
+    return (char *)s;
+}
\ No newline at end of file
diff --git a/src/time/time.c b/src/time/time.c
index ad0480f9..679c1428 100644
--- a/src/time/time.c
+++ b/src/time/time.c
@@ -1,8 +1,52 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 #include <time.h>
+#include <errno.h>
+#include <stdint.h>
 #include "syscall.h"
+#include "atomic.h"
+
+#ifdef VDSO_TIME_SYM
+
+static void *volatile vdso_time;
+
+static time_t time_init(time_t *t)
+{
+	__get_vdso_info();
+	void *p = __get_vdso_addr(VDSO_TIME_VER, VDSO_TIME_SYM);
+	time_t (*f)(time_t *) =
+		(time_t (*)(time_t *))p;
+	a_cas_p(&vdso_time, (void *)time_init, p);
+	return f ? f(t) : -ENOSYS;
+}
+
+static void *volatile vdso_time = (void *)time_init;
+
+#endif
 
 time_t time(time_t *t)
 {
+#ifdef VDSO_TIME_SYM
+	time_t (*f)(time_t *) =
+	(time_t (*)(time_t *))vdso_time;
+    if (f) {
+		return f(t);
+	}
+#endif
+
 	struct timespec ts;
 	__clock_gettime(CLOCK_REALTIME, &ts);
 	if (t) *t = ts.tv_sec;
diff --git a/src/time/time_impl.h b/src/time/time_impl.h
index f26d8005..5474e41e 100644
--- a/src/time/time_impl.h
+++ b/src/time/time_impl.h
@@ -1,3 +1,21 @@
+/**
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef __TIME_IMPL_H__
+#define __TIME_IMPL_H__
+
 #include <time.h>
 
 hidden int __days_in_month(int, int);
@@ -9,3 +27,6 @@ hidden int __secs_to_tm(long long, struct tm *);
 hidden void __secs_to_zone(long long, int, int *, long *, long *, const char **);
 hidden const char *__strftime_fmt_1(char (*)[100], size_t *, int, const struct tm *, locale_t, int);
 extern hidden const char __utc[];
+extern hidden const char __gmt[];
+
+#endif
\ No newline at end of file
diff --git a/src/time/timer_create.c b/src/time/timer_create.c
index 4bef2390..09d3d134 100644
--- a/src/time/timer_create.c
+++ b/src/time/timer_create.c
@@ -25,10 +25,12 @@ static void cleanup_fromsig(void *p)
 {
 	pthread_t self = __pthread_self();
 	__pthread_tsd_run_dtors();
+#ifdef FEATURE_PTHREAD_CANCEL
 	self->cancel = 0;
-	self->cancelbuf = 0;
 	self->canceldisable = 0;
 	self->cancelasync = 0;
+#endif
+	self->cancelbuf = 0;
 	__reset_tls();
 	longjmp(p, 1);
 }
diff --git a/src/trace/trace_marker.c b/src/trace/trace_marker.c
new file mode 100644
index 00000000..60ddf6e6
--- /dev/null
+++ b/src/trace/trace_marker.c
@@ -0,0 +1,243 @@
+/*
+ * Copyright (c) 2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <trace/trace_marker.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include "musl_log.h"
+#ifdef OHOS_ENABLE_PARAMETER
+#include "sys_param.h"
+#endif
+
+#ifndef MUSL_TEMP_FAILURE_RETRY
+#define MUSL_TEMP_FAILURE_RETRY(exp)           \
+    ({                                         \
+    long int _rc;                              \
+    do {                                       \
+        _rc = (long int)(exp);                 \
+    } while ((_rc == -1) && (errno == EINTR)); \
+    _rc;                                       \
+    })
+#endif
+
+#define LIKELY(exp) (__builtin_expect(!!(exp), 1))
+
+#ifdef OHOS_ENABLE_PARAMETER
+#define TRACE_PROPERTY_FLAG "debug.hitrace.tags.enableflags"
+static uint64_t g_trace_switch_status = 0;
+
+uint64_t get_uint64_sysparam(CachedHandle cachedhandle)
+{
+    char *param_value = CachedParameterGet(cachedhandle);
+    if (param_value != NULL) {
+        return strtoull(param_value, NULL, 0);
+    }
+    return 0;
+}
+#endif
+
+void trace_marker_reset(void)
+{
+#ifdef OHOS_ENABLE_PARAMETER
+    static CachedHandle trace_switch_handle = NULL;
+    if (trace_switch_handle == NULL) {
+        trace_switch_handle = CachedParameterCreate(TRACE_PROPERTY_FLAG, "0");
+    }
+    g_trace_switch_status = get_uint64_sysparam(trace_switch_handle);
+#else
+    return;
+#endif
+}
+
+// Check whether the user space trace function is enabled
+static inline bool is_enable_trace(uint64_t label)
+{
+#ifdef OHOS_ENABLE_PARAMETER
+    return (((g_trace_switch_status & label) != 0) || ((g_trace_switch_status & HITRACE_TAG_ALWAYS) != 0));
+#else
+    return false;
+#endif
+}
+
+// Get the fd of trace_marker
+static inline int get_trace_marker_fd(void)
+{
+    int trace_marker_fd = MUSL_TEMP_FAILURE_RETRY(open("/sys/kernel/tracing/trace_marker", O_CLOEXEC | O_WRONLY | O_APPEND));
+    if (trace_marker_fd == -1) {
+        trace_marker_fd = MUSL_TEMP_FAILURE_RETRY(open("/sys/kernel/debug/tracing/trace_marker", O_CLOEXEC | O_WRONLY | O_APPEND));
+    }
+    return trace_marker_fd;
+}
+
+/* Write the function call information to the trace_marker node in kernel space,
+used on the same thread as trace_marker_end(),with the symbol "B". */
+void trace_marker_begin(uint64_t label, const char *message, const char *value)
+{
+    if (LIKELY((!is_enable_trace(label) || message == NULL))) {
+        return;
+    }
+
+    int trace_marker_fd = get_trace_marker_fd();
+    if (trace_marker_fd == -1) {
+        return;
+    }
+
+    char buf[TRACE_MARKER_MESSAGE_LEN] = {0};
+    int len = 0;
+    if (value == NULL) {
+        len = snprintf(buf, TRACE_MARKER_MESSAGE_LEN, "B|%d|%s", getpid(), message);
+    } else {
+        len = snprintf(buf, TRACE_MARKER_MESSAGE_LEN, "B|%d|%s %s", getpid(), message, value);
+    }
+    if (len > 0 && len < sizeof(buf)) {
+        int ret = MUSL_TEMP_FAILURE_RETRY(write(trace_marker_fd, buf, len));
+        if (ret == -1) {
+            MUSL_LOGE("fail to write B. %d", ret);
+        }
+    } else {
+        MUSL_LOGE("B length error. %d", len);
+    }
+
+    // close file descriptor of trace_marker
+    close(trace_marker_fd);
+}
+
+/* Write the terminator to the trace_marker node of the kernel space,
+used on the same thread as trace_marker_begin(),with the symbol "E". */
+void trace_marker_end(uint64_t label)
+{
+    if (LIKELY(!is_enable_trace(label))) {
+        return;
+    }
+
+    int trace_marker_fd = get_trace_marker_fd();
+    if (trace_marker_fd == -1) {
+        return;
+    }
+
+    char buf[TRACE_MARKER_MESSAGE_LEN] = {0};
+    int len = snprintf(buf, TRACE_MARKER_MESSAGE_LEN, "E|%d", getpid());
+    if (len > 0 && len < sizeof(buf)) {
+        int ret = MUSL_TEMP_FAILURE_RETRY(write(trace_marker_fd, buf, len));
+        if (ret == -1) {
+            MUSL_LOGE("fail to write E. %d", ret);
+        }
+    } else {
+        MUSL_LOGE("E length error. %d", len);
+    }
+
+    // close file descriptor of trace_marker
+    close(trace_marker_fd);
+}
+
+/* Write the function call information to the trace_marker node in kernel space,
+used in a different thread than trace_marker_async_end(),with the symbol "S". */
+void trace_marker_async_begin(uint64_t label, const char *message, const char *value, int taskId)
+{
+    if (LIKELY((!is_enable_trace(label) || message == NULL))) {
+        return;
+    }
+
+    int trace_marker_fd = get_trace_marker_fd();
+    if (trace_marker_fd == -1) {
+        return;
+    }
+
+    char buf[TRACE_MARKER_MESSAGE_LEN] = {0};
+    int len = 0;
+    if (value == NULL) {
+        len = snprintf(buf, TRACE_MARKER_MESSAGE_LEN, "S|%d|%s %d", getpid(), message, taskId);
+    } else {
+        len = snprintf(buf, TRACE_MARKER_MESSAGE_LEN, "S|%d|%s|%s %d", getpid(), message, value, taskId);
+    }
+    if (len > 0 && len < sizeof(buf)) {
+        int ret = MUSL_TEMP_FAILURE_RETRY(write(trace_marker_fd, buf, len));
+        if (ret == -1) {
+            MUSL_LOGE("fail to write S. %d", ret);
+        }
+    } else {
+        MUSL_LOGE("S length error. %d", len);
+    }
+
+    // close file descriptor of trace_marker
+    close(trace_marker_fd);
+}
+
+/* Write the terminator to the trace_marker node in kernel space,
+used in a different thread than trace_marker_async_begin(),with the symbol "F". */
+void trace_marker_async_end(uint64_t label, const char *message, const char *value, int taskId)
+{
+    if (LIKELY((!is_enable_trace(label) || message == NULL))) {
+        return;
+    }
+
+    int trace_marker_fd = get_trace_marker_fd();
+    if (trace_marker_fd == -1) {
+        return;
+    }
+
+    char buf[TRACE_MARKER_MESSAGE_LEN] = {0};
+    int len = 0;
+    if (value == NULL) {
+        len = snprintf(buf, TRACE_MARKER_MESSAGE_LEN, "F|%d|%s %d", getpid(), message, taskId);
+    } else {
+        len = snprintf(buf, TRACE_MARKER_MESSAGE_LEN, "F|%d|%s|%s %d", getpid(), message, value, taskId);
+    }
+    if (len > 0 && len < sizeof(buf)) {
+        int ret = MUSL_TEMP_FAILURE_RETRY(write(trace_marker_fd, buf, len));
+        if (ret == -1) {
+            MUSL_LOGE("fail to write F. %d", ret);
+        }
+    } else {
+        MUSL_LOGE("F length error. %d", len);
+    }
+
+    // close file descriptor of trace_marker
+    close(trace_marker_fd);
+}
+
+// A numeric variable used to mark a pre trace, with the symbol "C".
+void trace_marker_count(uint64_t label, const char *message, int value)
+{
+    if (LIKELY((!is_enable_trace(label) || message == NULL))) {
+        return;
+    }
+
+    int trace_marker_fd = get_trace_marker_fd();
+    if (trace_marker_fd == -1) {
+        return;
+    }
+
+    char buf[TRACE_MARKER_MESSAGE_LEN] = {0};
+    int len = snprintf(buf, TRACE_MARKER_MESSAGE_LEN, "C|%d|%s %d", getpid(), message, value);
+    if (len > 0 && len < sizeof(buf)) {
+        int ret = MUSL_TEMP_FAILURE_RETRY(write(trace_marker_fd, buf, len));
+        if (ret == -1) {
+            MUSL_LOGE("fail to write C. %d", ret);
+        }
+    } else {
+        MUSL_LOGE("C length error. %d", len);
+    }
+
+    // close file descriptor of trace_marker
+    close(trace_marker_fd);
+}
diff --git a/src/unistd/getpid.c b/src/unistd/getpid.c
index a6d4e6d1..ccc62e77 100644
--- a/src/unistd/getpid.c
+++ b/src/unistd/getpid.c
@@ -1,7 +1,17 @@
 #include <unistd.h>
+#include "pthread_impl.h"
 #include "syscall.h"
 
+static pid_t __get_cached_pid()
+{
+	return __pthread_self()->pid;
+}
+
 pid_t getpid(void)
 {
+	pid_t pid = __get_cached_pid();
+	if (pid != 0) {
+		return pid;
+	}
 	return __syscall(SYS_getpid);
 }
-- 
2.25.1

